[
  {
    "Constant" : [
      {
        "desc" : "A table containing key-value pairs mapping encoding names to their integer representation used by the methods in this module.",
        "stripped_doc" : [
          "A table containing key-value pairs mapping encoding names to their integer representation used by the methods in this module.",
          "",
          "This table will contain all of the encodings recognized by the macOS Objective-C runtime. Key values (strings) will be the localized name of the encoding based on the users locale at the time this module is loaded.",
          "",
          "In addition to the localized names generated at load time, the following common encoding shorthands are also defined and are guaranteed to be consistent across all locales:",
          "",
          " * `rawData`           - The data of the textObject is treated as 8-bit bytes with no special meaning or encodings.",
          " * `ASCII`             - Strict 7-bit ASCII encoding within 8-bit chars; ASCII values 0…127 only.",
          " * `ISO2022JP`         - ISO 2022 Japanese encoding for email.",
          " * `ISOLatin1`         - 8-bit ISO Latin 1 encoding.",
          " * `ISOLatin2`         - 8-bit ISO Latin 2 encoding.",
          " * `JapaneseEUC`       - 8-bit EUC encoding for Japanese text.",
          " * `MacOSRoman`        - Classic Macintosh Roman encoding.",
          " * `NEXTSTEP`          - 8-bit ASCII encoding with NEXTSTEP extensions.",
          " * `NonLossyASCII`     - 7-bit verbose ASCII to represent all Unicode characters.",
          " * `ShiftJIS`          - 8-bit Shift-JIS encoding for Japanese text.",
          " * `Symbol`            - 8-bit Adobe Symbol encoding vector.",
          " * `Unicode`           - The canonical Unicode encoding for string objects.",
          " * `UTF16`             - A synonym for `Unicode`. The default encoding used by macOS and `hs.text.utf16` for direct manipulation of encoded text.",
          " * `UTF16BigEndian`    - UTF16 encoding with explicit endianness specified.",
          " * `UTF16LittleEndian` - UTF16 encoding with explicit endianness specified.",
          " * `UTF32`             - 32-bit UTF encoding.",
          " * `UTF32BigEndian`    - 32-bit UTF encoding with explicit endianness specified.",
          " * `UTF32LittleEndian` - 32-bit UTF encoding with explicit endianness specified.",
          " * `UTF8`              - An 8-bit representation of Unicode characters, suitable for transmission or storage by ASCII-based systems.",
          " * `WindowsCP1250`     - Microsoft Windows codepage 1250; equivalent to WinLatin2.",
          " * `WindowsCP1251`     - Microsoft Windows codepage 1251, encoding Cyrillic characters; equivalent to AdobeStandardCyrillic font encoding.",
          " * `WindowsCP1252`     - Microsoft Windows codepage 1252; equivalent to WinLatin1.",
          " * `WindowsCP1253`     - Microsoft Windows codepage 1253, encoding Greek characters.",
          " * `WindowsCP1254`     - Microsoft Windows codepage 1254, encoding Turkish characters."
        ],
        "name" : "encodingTypes",
        "doc" : "A table containing key-value pairs mapping encoding names to their integer representation used by the methods in this module.\n\nThis table will contain all of the encodings recognized by the macOS Objective-C runtime. Key values (strings) will be the localized name of the encoding based on the users locale at the time this module is loaded.\n\nIn addition to the localized names generated at load time, the following common encoding shorthands are also defined and are guaranteed to be consistent across all locales:\n\n * `rawData`           - The data of the textObject is treated as 8-bit bytes with no special meaning or encodings.\n * `ASCII`             - Strict 7-bit ASCII encoding within 8-bit chars; ASCII values 0…127 only.\n * `ISO2022JP`         - ISO 2022 Japanese encoding for email.\n * `ISOLatin1`         - 8-bit ISO Latin 1 encoding.\n * `ISOLatin2`         - 8-bit ISO Latin 2 encoding.\n * `JapaneseEUC`       - 8-bit EUC encoding for Japanese text.\n * `MacOSRoman`        - Classic Macintosh Roman encoding.\n * `NEXTSTEP`          - 8-bit ASCII encoding with NEXTSTEP extensions.\n * `NonLossyASCII`     - 7-bit verbose ASCII to represent all Unicode characters.\n * `ShiftJIS`          - 8-bit Shift-JIS encoding for Japanese text.\n * `Symbol`            - 8-bit Adobe Symbol encoding vector.\n * `Unicode`           - The canonical Unicode encoding for string objects.\n * `UTF16`             - A synonym for `Unicode`. The default encoding used by macOS and `hs.text.utf16` for direct manipulation of encoded text.\n * `UTF16BigEndian`    - UTF16 encoding with explicit endianness specified.\n * `UTF16LittleEndian` - UTF16 encoding with explicit endianness specified.\n * `UTF32`             - 32-bit UTF encoding.\n * `UTF32BigEndian`    - 32-bit UTF encoding with explicit endianness specified.\n * `UTF32LittleEndian` - 32-bit UTF encoding with explicit endianness specified.\n * `UTF8`              - An 8-bit representation of Unicode characters, suitable for transmission or storage by ASCII-based systems.\n * `WindowsCP1250`     - Microsoft Windows codepage 1250; equivalent to WinLatin2.\n * `WindowsCP1251`     - Microsoft Windows codepage 1251, encoding Cyrillic characters; equivalent to AdobeStandardCyrillic font encoding.\n * `WindowsCP1252`     - Microsoft Windows codepage 1252; equivalent to WinLatin1.\n * `WindowsCP1253`     - Microsoft Windows codepage 1253, encoding Greek characters.\n * `WindowsCP1254`     - Microsoft Windows codepage 1254, encoding Turkish characters.",
        "notes" : [

        ],
        "signature" : "hs.text.encodingTypes",
        "type" : "Constant",
        "returns" : [

        ],
        "def" : "hs.text.encodingTypes",
        "parameters" : [

        ]
      }
    ],
    "submodules" : [
      "http",
      "utf16"
    ],
    "Function" : [
      {
        "desc" : "Returns the localzed name for the encoding.",
        "stripped_doc" : [
          "Returns the localzed name for the encoding.",
          ""
        ],
        "name" : "encodingName",
        "doc" : "Returns the localzed name for the encoding.\n\nParameters:\n * `encoding` - an integer specifying the encoding\n\nReturns:\n * a string specifying the localized name for the encoding specified or an empty string if the number does not refer to a valid encoding.\n\nNotes:\n * the name returned will match the name of one of the keys in [hs.text.encodingTypes](#encodingTypes) unless the system locale has changed since the module was first loaded.",
        "notes" : [
          " * the name returned will match the name of one of the keys in [hs.text.encodingTypes](#encodingTypes) unless the system locale has changed since the module was first loaded."
        ],
        "signature" : "hs.text.encodingName(encoding) -> string",
        "type" : "Function",
        "returns" : [
          " * a string specifying the localized name for the encoding specified or an empty string if the number does not refer to a valid encoding.",
          ""
        ],
        "def" : "hs.text.encodingName(encoding) -> string",
        "parameters" : [
          " * `encoding` - an integer specifying the encoding",
          ""
        ]
      }
    ],
    "Variable" : [

    ],
    "stripped_doc" : [

    ],
    "desc" : "This module provides functions and methods for converting text between the various encodings supported by macOS.",
    "Deprecated" : [

    ],
    "type" : "Module",
    "Constructor" : [
      {
        "desc" : "Creates a new text object from a lua string or `hs.text.utf16` object.",
        "stripped_doc" : [
          "Creates a new text object from a lua string or `hs.text.utf16` object.",
          "",
          "Params:",
          " * `text`      - a lua string or `hs.text.utf16` object. When this parameter is an `hs.text.utf16` object, no other parameters are allowed.",
          " * `encoding`  - an optional integer, specifying the encoding of the contents of the lua string. Valid encodings are contained within the [hs.text.encodingTypes](#encodingTypes) table.",
          " * If `encoding` is not provided, this contructor will attempt to guess the encoding (see [hs.text:guessEncoding](#guessEncoding) for more details).",
          "   * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when guessing the encoding.",
          "   * `windows` - an optional boolean, default false, specifying whether or not to consider encodings corresponding to Windows codepage numbers when guessing the encoding.",
          ""
        ],
        "name" : "new",
        "doc" : "Creates a new text object from a lua string or `hs.text.utf16` object.\n\nParams:\n * `text`      - a lua string or `hs.text.utf16` object. When this parameter is an `hs.text.utf16` object, no other parameters are allowed.\n * `encoding`  - an optional integer, specifying the encoding of the contents of the lua string. Valid encodings are contained within the [hs.text.encodingTypes](#encodingTypes) table.\n * If `encoding` is not provided, this contructor will attempt to guess the encoding (see [hs.text:guessEncoding](#guessEncoding) for more details).\n   * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when guessing the encoding.\n   * `windows` - an optional boolean, default false, specifying whether or not to consider encodings corresponding to Windows codepage numbers when guessing the encoding.\n\nReturns:\n * a new textObject\n\nNotes:\n * The contents of `text` is stored exactly as provided, even if the specified encoding (or guessed encoding) is not valid for the entire contents of the data.",
        "notes" : [
          " * The contents of `text` is stored exactly as provided, even if the specified encoding (or guessed encoding) is not valid for the entire contents of the data."
        ],
        "signature" : "hs.text.new(text, [encoding] | [lossy, [windows]]) -> textObject",
        "type" : "Constructor",
        "returns" : [
          " * a new textObject",
          ""
        ],
        "def" : "hs.text.new(text, [encoding] | [lossy, [windows]]) -> textObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create text object with the contents of the file at the specified path.",
        "stripped_doc" : [
          "Create text object with the contents of the file at the specified path.",
          ""
        ],
        "name" : "readFile",
        "doc" : "Create text object with the contents of the file at the specified path.\n\nParameters:\n * `path`     - a string specifying the absolute or relative (to your Hammerspoon configuration directory) path to the file to read.\n * `encoding` - an optional integer specifying the encoding of the data in the file. See [hs.text.encodingTypes](#encodingTypes) for possible values.\n\nReturns:\n * a new textObject containing the contents of the specified file, or nil and a string specifying the error\n\nNotes:\n * if no encoding is specified, the encoding will be determined by macOS when the file is read. If no encoding can be determined, the file will be read as if the encoding had been specified as [hs.text.encodingTypes.rawData](#encodingTypes)\n   * to identify the encoding determined, see [hs.text:encoding](#encoding)",
        "notes" : [
          " * if no encoding is specified, the encoding will be determined by macOS when the file is read. If no encoding can be determined, the file will be read as if the encoding had been specified as [hs.text.encodingTypes.rawData](#encodingTypes)",
          "   * to identify the encoding determined, see [hs.text:encoding](#encoding)"
        ],
        "signature" : "hs.text.readFile(path, [encoding]) -> textObject | nil, errorString",
        "type" : "Constructor",
        "returns" : [
          " * a new textObject containing the contents of the specified file, or nil and a string specifying the error",
          ""
        ],
        "def" : "hs.text.readFile(path, [encoding]) -> textObject | nil, errorString",
        "parameters" : [
          " * `path`     - a string specifying the absolute or relative (to your Hammerspoon configuration directory) path to the file to read.",
          " * `encoding` - an optional integer specifying the encoding of the data in the file. See [hs.text.encodingTypes](#encodingTypes) for possible values.",
          ""
        ]
      }
    ],
    "Field" : [

    ],
    "Method" : [
      {
        "desc" : "Returns the textObject as a UTF8 string that can be printed and manipulated directly by lua.",
        "stripped_doc" : [
          "Returns the textObject as a UTF8 string that can be printed and manipulated directly by lua.",
          ""
        ],
        "name" : "tostring",
        "doc" : "Returns the textObject as a UTF8 string that can be printed and manipulated directly by lua.\n\nParameters:\n * `lossy`    - a boolean, defailt false, specifying whether or not characters can be removed or altered in the conversion to UTF8.\n\nReturns:\n * a lua string containing the UTF8 representation of the textObject. The string will be empty (i.e. \"\") if the conversion to UTF8 could not be performed.\n\nNotes:\n * this method is basically a wrapper for `textObject:asEncoding(hs.text.encodingTypes.UTF8, [lossy]):rawData()`",
        "notes" : [
          " * this method is basically a wrapper for `textObject:asEncoding(hs.text.encodingTypes.UTF8, [lossy]):rawData()`"
        ],
        "signature" : "hs.text:tostring([lossy]) -> string",
        "type" : "Method",
        "returns" : [
          " * a lua string containing the UTF8 representation of the textObject. The string will be empty (i.e. \"\") if the conversion to UTF8 could not be performed.",
          ""
        ],
        "def" : "hs.text:tostring([lossy]) -> string",
        "parameters" : [
          " * `lossy`    - a boolean, defailt false, specifying whether or not characters can be removed or altered in the conversion to UTF8.",
          ""
        ]
      },
      {
        "desc" : "Returns a new hs.text.utf16 object representing the textObject for use with the `hs.text.utf16` submodule and its methods.",
        "stripped_doc" : [
          "Returns a new hs.text.utf16 object representing the textObject for use with the `hs.text.utf16` submodule and its methods.",
          ""
        ],
        "name" : "toUTF16",
        "doc" : "Returns a new hs.text.utf16 object representing the textObject for use with the `hs.text.utf16` submodule and its methods.\n\nParameters:\n * `lossy`    - a boolean, defailt false, specifying whether or not characters can be removed or altered in the conversion to UTF16.\n\nReturns:\n * a new `hs.text.utf16` object or nil if the conversion could not be performed.",
        "notes" : [

        ],
        "signature" : "hs.text:toUTF16([lossy]) -> utf16TextObject | nil",
        "type" : "Method",
        "returns" : [
          " * a new `hs.text.utf16` object or nil if the conversion could not be performed."
        ],
        "def" : "hs.text:toUTF16([lossy]) -> utf16TextObject | nil",
        "parameters" : [
          " * `lossy`    - a boolean, defailt false, specifying whether or not characters can be removed or altered in the conversion to UTF16.",
          ""
        ]
      },
      {
        "desc" : "Get the actual bytes of data present between the specified indices of the textObject",
        "stripped_doc" : [
          "Get the actual bytes of data present between the specified indices of the textObject",
          "",
          "Paramaters:",
          " * `i` - an optional integer, default 1, specifying the starting index. Negative numbers start from the end of the texObject.",
          " * `j` - an optional integer, defaults to the value of `i`, specifying the ending index. Negative numbers start from the end of the texObject.",
          ""
        ],
        "name" : "byte",
        "doc" : "Get the actual bytes of data present between the specified indices of the textObject\n\nParamaters:\n * `i` - an optional integer, default 1, specifying the starting index. Negative numbers start from the end of the texObject.\n * `j` - an optional integer, defaults to the value of `i`, specifying the ending index. Negative numbers start from the end of the texObject.\n\nReturns:\n * 0 or more integers representing the bytes within the range specified by the indicies.\n\nNotes:\n * This is syntactic sugar for `string.bytes(hs.text:rawData() [, i [, j]])`\n * This method returns the byte values of the actual data present in the textObject. Depending upon the encoding of the textObject, these bytes may or may not represent individual or complete characters within the text itself.",
        "notes" : [
          " * This is syntactic sugar for `string.bytes(hs.text:rawData() [, i [, j]])`",
          " * This method returns the byte values of the actual data present in the textObject. Depending upon the encoding of the textObject, these bytes may or may not represent individual or complete characters within the text itself."
        ],
        "signature" : "hs.text:byte([i, [j]]) -> 0 or more integeres",
        "type" : "Method",
        "returns" : [
          " * 0 or more integers representing the bytes within the range specified by the indicies.",
          ""
        ],
        "def" : "hs.text:byte([i, [j]]) -> 0 or more integeres",
        "parameters" : [

        ]
      },
      {
        "desc" : "Write the textObject to the specified file.",
        "stripped_doc" : [
          "Write the textObject to the specified file.",
          ""
        ],
        "name" : "writeToFile",
        "doc" : "Write the textObject to the specified file.\n\nParameters:\n * `path`     - a string specifying the absolute or relative (to your Hammerspoon configuration directory) path to save the data to.\n * `encoding` - an optional integer specifying the encoding to use when writing the file. If not specified, the current encoding of the textObject is used. See [hs.text.encodingTypes](#encodingTypes) for possible values.\n\nReturns:\n * the textObject, or nil and a string specifying the error",
        "notes" : [

        ],
        "signature" : "hs.text:writeToFile(path, [encoding]) -> textObject | nil, errorString",
        "type" : "Method",
        "returns" : [
          " * the textObject, or nil and a string specifying the error"
        ],
        "def" : "hs.text:writeToFile(path, [encoding]) -> textObject | nil, errorString",
        "parameters" : [
          " * `path`     - a string specifying the absolute or relative (to your Hammerspoon configuration directory) path to save the data to.",
          " * `encoding` - an optional integer specifying the encoding to use when writing the file. If not specified, the current encoding of the textObject is used. See [hs.text.encodingTypes](#encodingTypes) for possible values.",
          ""
        ]
      },
      {
        "desc" : "Guess the encoding for the data held in the textObject",
        "stripped_doc" : [
          "Guess the encoding for the data held in the textObject",
          "",
          "Paramters:",
          " * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when guessing the encoding.",
          " * `windows` - an optional boolean, default false, specifying whether or not to consider encodings corresponding to Windows codepage numbers when guessing the encoding.",
          ""
        ],
        "name" : "guessEncoding",
        "doc" : "Guess the encoding for the data held in the textObject\n\nParamters:\n * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when guessing the encoding.\n * `windows` - an optional boolean, default false, specifying whether or not to consider encodings corresponding to Windows codepage numbers when guessing the encoding.\n\nReturns:\n * an integer specifying the guessed encoding and a boolean indicating whether or not the guess results in partial data loss (lossy)\n\nNotes:\n * this method works with the raw data contents of the textObject and ignores the currently assigned encoding.\n * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
        "notes" : [
          " * this method works with the raw data contents of the textObject and ignores the currently assigned encoding.",
          " * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)"
        ],
        "signature" : "hs.text:guessEncoding([lossy], [windows]) -> integer, boolean",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the guessed encoding and a boolean indicating whether or not the guess results in partial data loss (lossy)",
          ""
        ],
        "def" : "hs.text:guessEncoding([lossy], [windows]) -> integer, boolean",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the fastest encoding to which the textObject may be converted without loss of information.",
        "stripped_doc" : [
          "Returns the fastest encoding to which the textObject may be converted without loss of information.",
          ""
        ],
        "name" : "fastestEncoding",
        "doc" : "Returns the fastest encoding to which the textObject may be converted without loss of information.\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the encoding\n\nNotes:\n * this method works with string representation of the textObject in its current encoding.\n * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)\n * “Fastest” applies to retrieval of characters from the string. This encoding may not be space efficient. See also [hs.text:smallestEncoding](#smallestEncoding).",
        "notes" : [
          " * this method works with string representation of the textObject in its current encoding.",
          " * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
          " * “Fastest” applies to retrieval of characters from the string. This encoding may not be space efficient. See also [hs.text:smallestEncoding](#smallestEncoding)."
        ],
        "signature" : "hs.text:fastestEncoding() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the encoding",
          ""
        ],
        "def" : "hs.text:fastestEncoding() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the smallest encoding to which the textObject may be converted without loss of information.",
        "stripped_doc" : [
          "Returns the smallest encoding to which the textObject may be converted without loss of information.",
          ""
        ],
        "name" : "smallestEncoding",
        "doc" : "Returns the smallest encoding to which the textObject may be converted without loss of information.\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the encoding\n\nNotes:\n * this method works with string representation of the textObject in its current encoding.\n * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)\n * This encoding may not be the fastest for accessing characters, but is space-efficient. See also [hs.text:fastestEncoding](#fastestEncoding).",
        "notes" : [
          " * this method works with string representation of the textObject in its current encoding.",
          " * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
          " * This encoding may not be the fastest for accessing characters, but is space-efficient. See also [hs.text:fastestEncoding](#fastestEncoding)."
        ],
        "signature" : "hs.text:smallestEncoding() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the encoding",
          ""
        ],
        "def" : "hs.text:smallestEncoding() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the encoding currently assigned for the textObject",
        "stripped_doc" : [
          "Returns the encoding currently assigned for the textObject",
          ""
        ],
        "name" : "encoding",
        "doc" : "Returns the encoding currently assigned for the textObject\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the encoding\n\nNotes:\n * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
        "notes" : [
          " * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)"
        ],
        "signature" : "hs.text:encoding() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the encoding",
          ""
        ],
        "def" : "hs.text:encoding() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the raw data which makes up the contents of the textObject",
        "stripped_doc" : [
          "Returns the raw data which makes up the contents of the textObject",
          ""
        ],
        "name" : "rawData",
        "doc" : "Returns the raw data which makes up the contents of the textObject\n\nParameters:\n * None\n\nReturns:\n * a lua string containing the raw data of the textObject",
        "notes" : [

        ],
        "signature" : "hs.text:rawData() -> string",
        "type" : "Method",
        "returns" : [
          " * a lua string containing the raw data of the textObject"
        ],
        "def" : "hs.text:rawData() -> string",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Generate a list of possible encodings for the data represented by the hs.text object",
        "stripped_doc" : [
          "Generate a list of possible encodings for the data represented by the hs.text object",
          "",
          "Paramters:",
          " * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when evaluating each potential encoding.",
          ""
        ],
        "name" : "validEncodings",
        "doc" : "Generate a list of possible encodings for the data represented by the hs.text object\n\nParamters:\n * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when evaluating each potential encoding.\n\nReturns:\n * a table of integers specifying identified potential encodings for the data. Each integer will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)\n\nNotes:\n * this method works with the raw data contents of the textObject and ignores the currently assigned encoding.\n * the encodings identified are ones for which the bytes of data can represent valid character or formatting sequences within the encoding -- the specific textual representation for each encoding may differ. See the notes for [hs.text:asEncoding](#asEncoding) for an example of a byte sequence which has very different textual meanings for different encodings.",
        "notes" : [
          " * this method works with the raw data contents of the textObject and ignores the currently assigned encoding.",
          " * the encodings identified are ones for which the bytes of data can represent valid character or formatting sequences within the encoding -- the specific textual representation for each encoding may differ. See the notes for [hs.text:asEncoding](#asEncoding) for an example of a byte sequence which has very different textual meanings for different encodings."
        ],
        "signature" : "hs.text:validEncodings([lossy]) -> table of integers",
        "type" : "Method",
        "returns" : [
          " * a table of integers specifying identified potential encodings for the data. Each integer will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
          ""
        ],
        "def" : "hs.text:validEncodings([lossy]) -> table of integers",
        "parameters" : [

        ]
      },
      {
        "desc" : "Convert the textObject to a different encoding.",
        "stripped_doc" : [
          "Convert the textObject to a different encoding.",
          ""
        ],
        "name" : "asEncoding",
        "doc" : "Convert the textObject to a different encoding.\n\nParameters:\n * `encoding` - an integer specifying the new encoding. Valid encoding values can be looked up in [hs.text.encodingTypes](#encodingTypes)\n * `lossy`    - a optional boolean, defailt false, specifying whether or not characters can be removed or altered when converted to the new encoding.\n\nReturns:\n * a new textObject with the text converted to the new encoding, or nil if the object cannot be converted to the new encoding.\n\nNotes:\n * If the encoding is not 0 ([hs.text.encodingTypes.rawData](#encodingTypes)), the actual data in the new textObject may be different then the original if the new encoding represents the characters differently.\n\n * The encoding type 0 is special in that it creates a new textObject with the exact same data as the original but with no information as to the encoding type. This can be useful when the textObject has assumed an incorrect encoding and you wish to change it without loosing data. For example:\n\n      ~~~\n      a = hs.text.new(\"abcd\")\n      print(a:encoding(), #a, #(a:rawData()), a:tostring()) -- prints `1\t4\t4\tabcd`\n\n      b = a:asEncoding(hs.text.encodingTypes.UTF16)\n      print(b:encoding(), #b, #(b:rawData()), b:tostring()) -- prints `10\t4\t10\tabcd`\n          -- note the change in the length of the raw data (the first two bytes will be the UTF16 BOM, but even factoring that out, the size went from 4 to 8), but not the text represented\n\n      c = a:asEncoding(0):asEncoding(hs.text.encodingTypes.UTF16)\n      print(c:encoding(), #c, #(c:rawData()), c:tostring()) -- prints `10\t2\t6\t慢捤`\n          -- note the change in the length of both the text and the raw data, as well as the actual text represented. Factoring out the UTF16 BOM, the data length is still 4, like the original object.\n      ~~~",
        "notes" : [
          " * If the encoding is not 0 ([hs.text.encodingTypes.rawData](#encodingTypes)), the actual data in the new textObject may be different then the original if the new encoding represents the characters differently.",
          "",
          " * The encoding type 0 is special in that it creates a new textObject with the exact same data as the original but with no information as to the encoding type. This can be useful when the textObject has assumed an incorrect encoding and you wish to change it without loosing data. For example:",
          "",
          "      ~~~",
          "      a = hs.text.new(\"abcd\")",
          "      print(a:encoding(), #a, #(a:rawData()), a:tostring()) -- prints `1\t4\t4\tabcd`",
          "",
          "      b = a:asEncoding(hs.text.encodingTypes.UTF16)",
          "      print(b:encoding(), #b, #(b:rawData()), b:tostring()) -- prints `10\t4\t10\tabcd`",
          "          -- note the change in the length of the raw data (the first two bytes will be the UTF16 BOM, but even factoring that out, the size went from 4 to 8), but not the text represented",
          "",
          "      c = a:asEncoding(0):asEncoding(hs.text.encodingTypes.UTF16)",
          "      print(c:encoding(), #c, #(c:rawData()), c:tostring()) -- prints `10\t2\t6\t慢捤`",
          "          -- note the change in the length of both the text and the raw data, as well as the actual text represented. Factoring out the UTF16 BOM, the data length is still 4, like the original object.",
          "      ~~~"
        ],
        "signature" : "hs.text:asEncoding(encoding, [lossy]) -> textObject | nil",
        "type" : "Method",
        "returns" : [
          " * a new textObject with the text converted to the new encoding, or nil if the object cannot be converted to the new encoding.",
          ""
        ],
        "def" : "hs.text:asEncoding(encoding, [lossy]) -> textObject | nil",
        "parameters" : [
          " * `encoding` - an integer specifying the new encoding. Valid encoding values can be looked up in [hs.text.encodingTypes](#encodingTypes)",
          " * `lossy`    - a optional boolean, defailt false, specifying whether or not characters can be removed or altered when converted to the new encoding.",
          ""
        ]
      },
      {
        "desc" : "Returns whether or not the current encoding is valid for the data in the textObject",
        "stripped_doc" : [
          "Returns whether or not the current encoding is valid for the data in the textObject",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "encodingValid",
        "doc" : "Returns whether or not the current encoding is valid for the data in the textObject\n\nParamters:\n * None\n\nReturns:\n * a boolean indicathing whether or not the encoding for the textObject is valid for the data in the textObject\n\nNotes:\n * for an encoding to be considered valid by the macOS, it must be able to be converted to an NSString object within the Objective-C runtime. The resulting string may or may not be an exact representation of the data present (i.e. it may be a lossy representation). See also [hs.text:encodingLossless](#encodingLossless).\n * a textObject with an encoding of 0 (rawData) is always considered invalid (i.e. this method will return false)",
        "notes" : [
          " * for an encoding to be considered valid by the macOS, it must be able to be converted to an NSString object within the Objective-C runtime. The resulting string may or may not be an exact representation of the data present (i.e. it may be a lossy representation). See also [hs.text:encodingLossless](#encodingLossless).",
          " * a textObject with an encoding of 0 (rawData) is always considered invalid (i.e. this method will return false)"
        ],
        "signature" : "hs.text:encodingValid() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicathing whether or not the encoding for the textObject is valid for the data in the textObject",
          ""
        ],
        "def" : "hs.text:encodingValid() -> boolean",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.",
        "stripped_doc" : [
          "Returns whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "encodingLossless",
        "doc" : "Returns whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.\n\nParamters:\n * None\n\nReturns:\n * a boolean indicathing whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.\n\nNotes:\n * for an encoding to be considered lossless, no data may be dropped or changed when evaluating the data within the requirements of the encoding. See also [hs.text:encodingValid](#encodingValid).\n * a textObject with an encoding of 0 (rawData) is always considered lossless (i.e. this method will return true)",
        "notes" : [
          " * for an encoding to be considered lossless, no data may be dropped or changed when evaluating the data within the requirements of the encoding. See also [hs.text:encodingValid](#encodingValid).",
          " * a textObject with an encoding of 0 (rawData) is always considered lossless (i.e. this method will return true)"
        ],
        "signature" : "hs.text:encodingLossless() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicathing whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.",
          ""
        ],
        "def" : "hs.text:encodingLossless() -> boolean",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the length of the textObject",
        "stripped_doc" : [
          "Returns the length of the textObject",
          "",
          "Paramaters:",
          " * None",
          ""
        ],
        "name" : "len",
        "doc" : "Returns the length of the textObject\n\nParamaters:\n * None\n\nReturns:\n * an integer specifying the length of the textObject\n\nNotes:\n * if the textObject's encoding is 0 (rawData), this method will return the number of bytes of data the textObject contains\n * otherwise, the length will be the number of characters the data represents in its current encoding.",
        "notes" : [
          " * if the textObject's encoding is 0 (rawData), this method will return the number of bytes of data the textObject contains",
          " * otherwise, the length will be the number of characters the data represents in its current encoding."
        ],
        "signature" : "hs.text:len() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the length of the textObject",
          ""
        ],
        "def" : "hs.text:len() -> integer",
        "parameters" : [

        ]
      }
    ],
    "Command" : [

    ],
    "items" : [
      {
        "desc" : "A table containing key-value pairs mapping encoding names to their integer representation used by the methods in this module.",
        "stripped_doc" : [
          "A table containing key-value pairs mapping encoding names to their integer representation used by the methods in this module.",
          "",
          "This table will contain all of the encodings recognized by the macOS Objective-C runtime. Key values (strings) will be the localized name of the encoding based on the users locale at the time this module is loaded.",
          "",
          "In addition to the localized names generated at load time, the following common encoding shorthands are also defined and are guaranteed to be consistent across all locales:",
          "",
          " * `rawData`           - The data of the textObject is treated as 8-bit bytes with no special meaning or encodings.",
          " * `ASCII`             - Strict 7-bit ASCII encoding within 8-bit chars; ASCII values 0…127 only.",
          " * `ISO2022JP`         - ISO 2022 Japanese encoding for email.",
          " * `ISOLatin1`         - 8-bit ISO Latin 1 encoding.",
          " * `ISOLatin2`         - 8-bit ISO Latin 2 encoding.",
          " * `JapaneseEUC`       - 8-bit EUC encoding for Japanese text.",
          " * `MacOSRoman`        - Classic Macintosh Roman encoding.",
          " * `NEXTSTEP`          - 8-bit ASCII encoding with NEXTSTEP extensions.",
          " * `NonLossyASCII`     - 7-bit verbose ASCII to represent all Unicode characters.",
          " * `ShiftJIS`          - 8-bit Shift-JIS encoding for Japanese text.",
          " * `Symbol`            - 8-bit Adobe Symbol encoding vector.",
          " * `Unicode`           - The canonical Unicode encoding for string objects.",
          " * `UTF16`             - A synonym for `Unicode`. The default encoding used by macOS and `hs.text.utf16` for direct manipulation of encoded text.",
          " * `UTF16BigEndian`    - UTF16 encoding with explicit endianness specified.",
          " * `UTF16LittleEndian` - UTF16 encoding with explicit endianness specified.",
          " * `UTF32`             - 32-bit UTF encoding.",
          " * `UTF32BigEndian`    - 32-bit UTF encoding with explicit endianness specified.",
          " * `UTF32LittleEndian` - 32-bit UTF encoding with explicit endianness specified.",
          " * `UTF8`              - An 8-bit representation of Unicode characters, suitable for transmission or storage by ASCII-based systems.",
          " * `WindowsCP1250`     - Microsoft Windows codepage 1250; equivalent to WinLatin2.",
          " * `WindowsCP1251`     - Microsoft Windows codepage 1251, encoding Cyrillic characters; equivalent to AdobeStandardCyrillic font encoding.",
          " * `WindowsCP1252`     - Microsoft Windows codepage 1252; equivalent to WinLatin1.",
          " * `WindowsCP1253`     - Microsoft Windows codepage 1253, encoding Greek characters.",
          " * `WindowsCP1254`     - Microsoft Windows codepage 1254, encoding Turkish characters."
        ],
        "name" : "encodingTypes",
        "doc" : "A table containing key-value pairs mapping encoding names to their integer representation used by the methods in this module.\n\nThis table will contain all of the encodings recognized by the macOS Objective-C runtime. Key values (strings) will be the localized name of the encoding based on the users locale at the time this module is loaded.\n\nIn addition to the localized names generated at load time, the following common encoding shorthands are also defined and are guaranteed to be consistent across all locales:\n\n * `rawData`           - The data of the textObject is treated as 8-bit bytes with no special meaning or encodings.\n * `ASCII`             - Strict 7-bit ASCII encoding within 8-bit chars; ASCII values 0…127 only.\n * `ISO2022JP`         - ISO 2022 Japanese encoding for email.\n * `ISOLatin1`         - 8-bit ISO Latin 1 encoding.\n * `ISOLatin2`         - 8-bit ISO Latin 2 encoding.\n * `JapaneseEUC`       - 8-bit EUC encoding for Japanese text.\n * `MacOSRoman`        - Classic Macintosh Roman encoding.\n * `NEXTSTEP`          - 8-bit ASCII encoding with NEXTSTEP extensions.\n * `NonLossyASCII`     - 7-bit verbose ASCII to represent all Unicode characters.\n * `ShiftJIS`          - 8-bit Shift-JIS encoding for Japanese text.\n * `Symbol`            - 8-bit Adobe Symbol encoding vector.\n * `Unicode`           - The canonical Unicode encoding for string objects.\n * `UTF16`             - A synonym for `Unicode`. The default encoding used by macOS and `hs.text.utf16` for direct manipulation of encoded text.\n * `UTF16BigEndian`    - UTF16 encoding with explicit endianness specified.\n * `UTF16LittleEndian` - UTF16 encoding with explicit endianness specified.\n * `UTF32`             - 32-bit UTF encoding.\n * `UTF32BigEndian`    - 32-bit UTF encoding with explicit endianness specified.\n * `UTF32LittleEndian` - 32-bit UTF encoding with explicit endianness specified.\n * `UTF8`              - An 8-bit representation of Unicode characters, suitable for transmission or storage by ASCII-based systems.\n * `WindowsCP1250`     - Microsoft Windows codepage 1250; equivalent to WinLatin2.\n * `WindowsCP1251`     - Microsoft Windows codepage 1251, encoding Cyrillic characters; equivalent to AdobeStandardCyrillic font encoding.\n * `WindowsCP1252`     - Microsoft Windows codepage 1252; equivalent to WinLatin1.\n * `WindowsCP1253`     - Microsoft Windows codepage 1253, encoding Greek characters.\n * `WindowsCP1254`     - Microsoft Windows codepage 1254, encoding Turkish characters.",
        "notes" : [

        ],
        "signature" : "hs.text.encodingTypes",
        "type" : "Constant",
        "returns" : [

        ],
        "def" : "hs.text.encodingTypes",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the localzed name for the encoding.",
        "stripped_doc" : [
          "Returns the localzed name for the encoding.",
          ""
        ],
        "name" : "encodingName",
        "doc" : "Returns the localzed name for the encoding.\n\nParameters:\n * `encoding` - an integer specifying the encoding\n\nReturns:\n * a string specifying the localized name for the encoding specified or an empty string if the number does not refer to a valid encoding.\n\nNotes:\n * the name returned will match the name of one of the keys in [hs.text.encodingTypes](#encodingTypes) unless the system locale has changed since the module was first loaded.",
        "notes" : [
          " * the name returned will match the name of one of the keys in [hs.text.encodingTypes](#encodingTypes) unless the system locale has changed since the module was first loaded."
        ],
        "signature" : "hs.text.encodingName(encoding) -> string",
        "type" : "Function",
        "returns" : [
          " * a string specifying the localized name for the encoding specified or an empty string if the number does not refer to a valid encoding.",
          ""
        ],
        "def" : "hs.text.encodingName(encoding) -> string",
        "parameters" : [
          " * `encoding` - an integer specifying the encoding",
          ""
        ]
      },
      {
        "desc" : "Creates a new text object from a lua string or `hs.text.utf16` object.",
        "stripped_doc" : [
          "Creates a new text object from a lua string or `hs.text.utf16` object.",
          "",
          "Params:",
          " * `text`      - a lua string or `hs.text.utf16` object. When this parameter is an `hs.text.utf16` object, no other parameters are allowed.",
          " * `encoding`  - an optional integer, specifying the encoding of the contents of the lua string. Valid encodings are contained within the [hs.text.encodingTypes](#encodingTypes) table.",
          " * If `encoding` is not provided, this contructor will attempt to guess the encoding (see [hs.text:guessEncoding](#guessEncoding) for more details).",
          "   * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when guessing the encoding.",
          "   * `windows` - an optional boolean, default false, specifying whether or not to consider encodings corresponding to Windows codepage numbers when guessing the encoding.",
          ""
        ],
        "name" : "new",
        "doc" : "Creates a new text object from a lua string or `hs.text.utf16` object.\n\nParams:\n * `text`      - a lua string or `hs.text.utf16` object. When this parameter is an `hs.text.utf16` object, no other parameters are allowed.\n * `encoding`  - an optional integer, specifying the encoding of the contents of the lua string. Valid encodings are contained within the [hs.text.encodingTypes](#encodingTypes) table.\n * If `encoding` is not provided, this contructor will attempt to guess the encoding (see [hs.text:guessEncoding](#guessEncoding) for more details).\n   * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when guessing the encoding.\n   * `windows` - an optional boolean, default false, specifying whether or not to consider encodings corresponding to Windows codepage numbers when guessing the encoding.\n\nReturns:\n * a new textObject\n\nNotes:\n * The contents of `text` is stored exactly as provided, even if the specified encoding (or guessed encoding) is not valid for the entire contents of the data.",
        "notes" : [
          " * The contents of `text` is stored exactly as provided, even if the specified encoding (or guessed encoding) is not valid for the entire contents of the data."
        ],
        "signature" : "hs.text.new(text, [encoding] | [lossy, [windows]]) -> textObject",
        "type" : "Constructor",
        "returns" : [
          " * a new textObject",
          ""
        ],
        "def" : "hs.text.new(text, [encoding] | [lossy, [windows]]) -> textObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create text object with the contents of the file at the specified path.",
        "stripped_doc" : [
          "Create text object with the contents of the file at the specified path.",
          ""
        ],
        "name" : "readFile",
        "doc" : "Create text object with the contents of the file at the specified path.\n\nParameters:\n * `path`     - a string specifying the absolute or relative (to your Hammerspoon configuration directory) path to the file to read.\n * `encoding` - an optional integer specifying the encoding of the data in the file. See [hs.text.encodingTypes](#encodingTypes) for possible values.\n\nReturns:\n * a new textObject containing the contents of the specified file, or nil and a string specifying the error\n\nNotes:\n * if no encoding is specified, the encoding will be determined by macOS when the file is read. If no encoding can be determined, the file will be read as if the encoding had been specified as [hs.text.encodingTypes.rawData](#encodingTypes)\n   * to identify the encoding determined, see [hs.text:encoding](#encoding)",
        "notes" : [
          " * if no encoding is specified, the encoding will be determined by macOS when the file is read. If no encoding can be determined, the file will be read as if the encoding had been specified as [hs.text.encodingTypes.rawData](#encodingTypes)",
          "   * to identify the encoding determined, see [hs.text:encoding](#encoding)"
        ],
        "signature" : "hs.text.readFile(path, [encoding]) -> textObject | nil, errorString",
        "type" : "Constructor",
        "returns" : [
          " * a new textObject containing the contents of the specified file, or nil and a string specifying the error",
          ""
        ],
        "def" : "hs.text.readFile(path, [encoding]) -> textObject | nil, errorString",
        "parameters" : [
          " * `path`     - a string specifying the absolute or relative (to your Hammerspoon configuration directory) path to the file to read.",
          " * `encoding` - an optional integer specifying the encoding of the data in the file. See [hs.text.encodingTypes](#encodingTypes) for possible values.",
          ""
        ]
      },
      {
        "desc" : "Convert the textObject to a different encoding.",
        "stripped_doc" : [
          "Convert the textObject to a different encoding.",
          ""
        ],
        "name" : "asEncoding",
        "doc" : "Convert the textObject to a different encoding.\n\nParameters:\n * `encoding` - an integer specifying the new encoding. Valid encoding values can be looked up in [hs.text.encodingTypes](#encodingTypes)\n * `lossy`    - a optional boolean, defailt false, specifying whether or not characters can be removed or altered when converted to the new encoding.\n\nReturns:\n * a new textObject with the text converted to the new encoding, or nil if the object cannot be converted to the new encoding.\n\nNotes:\n * If the encoding is not 0 ([hs.text.encodingTypes.rawData](#encodingTypes)), the actual data in the new textObject may be different then the original if the new encoding represents the characters differently.\n\n * The encoding type 0 is special in that it creates a new textObject with the exact same data as the original but with no information as to the encoding type. This can be useful when the textObject has assumed an incorrect encoding and you wish to change it without loosing data. For example:\n\n      ~~~\n      a = hs.text.new(\"abcd\")\n      print(a:encoding(), #a, #(a:rawData()), a:tostring()) -- prints `1\t4\t4\tabcd`\n\n      b = a:asEncoding(hs.text.encodingTypes.UTF16)\n      print(b:encoding(), #b, #(b:rawData()), b:tostring()) -- prints `10\t4\t10\tabcd`\n          -- note the change in the length of the raw data (the first two bytes will be the UTF16 BOM, but even factoring that out, the size went from 4 to 8), but not the text represented\n\n      c = a:asEncoding(0):asEncoding(hs.text.encodingTypes.UTF16)\n      print(c:encoding(), #c, #(c:rawData()), c:tostring()) -- prints `10\t2\t6\t慢捤`\n          -- note the change in the length of both the text and the raw data, as well as the actual text represented. Factoring out the UTF16 BOM, the data length is still 4, like the original object.\n      ~~~",
        "notes" : [
          " * If the encoding is not 0 ([hs.text.encodingTypes.rawData](#encodingTypes)), the actual data in the new textObject may be different then the original if the new encoding represents the characters differently.",
          "",
          " * The encoding type 0 is special in that it creates a new textObject with the exact same data as the original but with no information as to the encoding type. This can be useful when the textObject has assumed an incorrect encoding and you wish to change it without loosing data. For example:",
          "",
          "      ~~~",
          "      a = hs.text.new(\"abcd\")",
          "      print(a:encoding(), #a, #(a:rawData()), a:tostring()) -- prints `1\t4\t4\tabcd`",
          "",
          "      b = a:asEncoding(hs.text.encodingTypes.UTF16)",
          "      print(b:encoding(), #b, #(b:rawData()), b:tostring()) -- prints `10\t4\t10\tabcd`",
          "          -- note the change in the length of the raw data (the first two bytes will be the UTF16 BOM, but even factoring that out, the size went from 4 to 8), but not the text represented",
          "",
          "      c = a:asEncoding(0):asEncoding(hs.text.encodingTypes.UTF16)",
          "      print(c:encoding(), #c, #(c:rawData()), c:tostring()) -- prints `10\t2\t6\t慢捤`",
          "          -- note the change in the length of both the text and the raw data, as well as the actual text represented. Factoring out the UTF16 BOM, the data length is still 4, like the original object.",
          "      ~~~"
        ],
        "signature" : "hs.text:asEncoding(encoding, [lossy]) -> textObject | nil",
        "type" : "Method",
        "returns" : [
          " * a new textObject with the text converted to the new encoding, or nil if the object cannot be converted to the new encoding.",
          ""
        ],
        "def" : "hs.text:asEncoding(encoding, [lossy]) -> textObject | nil",
        "parameters" : [
          " * `encoding` - an integer specifying the new encoding. Valid encoding values can be looked up in [hs.text.encodingTypes](#encodingTypes)",
          " * `lossy`    - a optional boolean, defailt false, specifying whether or not characters can be removed or altered when converted to the new encoding.",
          ""
        ]
      },
      {
        "desc" : "Get the actual bytes of data present between the specified indices of the textObject",
        "stripped_doc" : [
          "Get the actual bytes of data present between the specified indices of the textObject",
          "",
          "Paramaters:",
          " * `i` - an optional integer, default 1, specifying the starting index. Negative numbers start from the end of the texObject.",
          " * `j` - an optional integer, defaults to the value of `i`, specifying the ending index. Negative numbers start from the end of the texObject.",
          ""
        ],
        "name" : "byte",
        "doc" : "Get the actual bytes of data present between the specified indices of the textObject\n\nParamaters:\n * `i` - an optional integer, default 1, specifying the starting index. Negative numbers start from the end of the texObject.\n * `j` - an optional integer, defaults to the value of `i`, specifying the ending index. Negative numbers start from the end of the texObject.\n\nReturns:\n * 0 or more integers representing the bytes within the range specified by the indicies.\n\nNotes:\n * This is syntactic sugar for `string.bytes(hs.text:rawData() [, i [, j]])`\n * This method returns the byte values of the actual data present in the textObject. Depending upon the encoding of the textObject, these bytes may or may not represent individual or complete characters within the text itself.",
        "notes" : [
          " * This is syntactic sugar for `string.bytes(hs.text:rawData() [, i [, j]])`",
          " * This method returns the byte values of the actual data present in the textObject. Depending upon the encoding of the textObject, these bytes may or may not represent individual or complete characters within the text itself."
        ],
        "signature" : "hs.text:byte([i, [j]]) -> 0 or more integeres",
        "type" : "Method",
        "returns" : [
          " * 0 or more integers representing the bytes within the range specified by the indicies.",
          ""
        ],
        "def" : "hs.text:byte([i, [j]]) -> 0 or more integeres",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the encoding currently assigned for the textObject",
        "stripped_doc" : [
          "Returns the encoding currently assigned for the textObject",
          ""
        ],
        "name" : "encoding",
        "doc" : "Returns the encoding currently assigned for the textObject\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the encoding\n\nNotes:\n * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
        "notes" : [
          " * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)"
        ],
        "signature" : "hs.text:encoding() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the encoding",
          ""
        ],
        "def" : "hs.text:encoding() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.",
        "stripped_doc" : [
          "Returns whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "encodingLossless",
        "doc" : "Returns whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.\n\nParamters:\n * None\n\nReturns:\n * a boolean indicathing whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.\n\nNotes:\n * for an encoding to be considered lossless, no data may be dropped or changed when evaluating the data within the requirements of the encoding. See also [hs.text:encodingValid](#encodingValid).\n * a textObject with an encoding of 0 (rawData) is always considered lossless (i.e. this method will return true)",
        "notes" : [
          " * for an encoding to be considered lossless, no data may be dropped or changed when evaluating the data within the requirements of the encoding. See also [hs.text:encodingValid](#encodingValid).",
          " * a textObject with an encoding of 0 (rawData) is always considered lossless (i.e. this method will return true)"
        ],
        "signature" : "hs.text:encodingLossless() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicathing whether or not the data representing the textObject is completely valid for the objects currently specified encoding with no loss or conversion of characters required.",
          ""
        ],
        "def" : "hs.text:encodingLossless() -> boolean",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns whether or not the current encoding is valid for the data in the textObject",
        "stripped_doc" : [
          "Returns whether or not the current encoding is valid for the data in the textObject",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "encodingValid",
        "doc" : "Returns whether or not the current encoding is valid for the data in the textObject\n\nParamters:\n * None\n\nReturns:\n * a boolean indicathing whether or not the encoding for the textObject is valid for the data in the textObject\n\nNotes:\n * for an encoding to be considered valid by the macOS, it must be able to be converted to an NSString object within the Objective-C runtime. The resulting string may or may not be an exact representation of the data present (i.e. it may be a lossy representation). See also [hs.text:encodingLossless](#encodingLossless).\n * a textObject with an encoding of 0 (rawData) is always considered invalid (i.e. this method will return false)",
        "notes" : [
          " * for an encoding to be considered valid by the macOS, it must be able to be converted to an NSString object within the Objective-C runtime. The resulting string may or may not be an exact representation of the data present (i.e. it may be a lossy representation). See also [hs.text:encodingLossless](#encodingLossless).",
          " * a textObject with an encoding of 0 (rawData) is always considered invalid (i.e. this method will return false)"
        ],
        "signature" : "hs.text:encodingValid() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicathing whether or not the encoding for the textObject is valid for the data in the textObject",
          ""
        ],
        "def" : "hs.text:encodingValid() -> boolean",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the fastest encoding to which the textObject may be converted without loss of information.",
        "stripped_doc" : [
          "Returns the fastest encoding to which the textObject may be converted without loss of information.",
          ""
        ],
        "name" : "fastestEncoding",
        "doc" : "Returns the fastest encoding to which the textObject may be converted without loss of information.\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the encoding\n\nNotes:\n * this method works with string representation of the textObject in its current encoding.\n * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)\n * “Fastest” applies to retrieval of characters from the string. This encoding may not be space efficient. See also [hs.text:smallestEncoding](#smallestEncoding).",
        "notes" : [
          " * this method works with string representation of the textObject in its current encoding.",
          " * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
          " * “Fastest” applies to retrieval of characters from the string. This encoding may not be space efficient. See also [hs.text:smallestEncoding](#smallestEncoding)."
        ],
        "signature" : "hs.text:fastestEncoding() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the encoding",
          ""
        ],
        "def" : "hs.text:fastestEncoding() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Guess the encoding for the data held in the textObject",
        "stripped_doc" : [
          "Guess the encoding for the data held in the textObject",
          "",
          "Paramters:",
          " * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when guessing the encoding.",
          " * `windows` - an optional boolean, default false, specifying whether or not to consider encodings corresponding to Windows codepage numbers when guessing the encoding.",
          ""
        ],
        "name" : "guessEncoding",
        "doc" : "Guess the encoding for the data held in the textObject\n\nParamters:\n * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when guessing the encoding.\n * `windows` - an optional boolean, default false, specifying whether or not to consider encodings corresponding to Windows codepage numbers when guessing the encoding.\n\nReturns:\n * an integer specifying the guessed encoding and a boolean indicating whether or not the guess results in partial data loss (lossy)\n\nNotes:\n * this method works with the raw data contents of the textObject and ignores the currently assigned encoding.\n * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
        "notes" : [
          " * this method works with the raw data contents of the textObject and ignores the currently assigned encoding.",
          " * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)"
        ],
        "signature" : "hs.text:guessEncoding([lossy], [windows]) -> integer, boolean",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the guessed encoding and a boolean indicating whether or not the guess results in partial data loss (lossy)",
          ""
        ],
        "def" : "hs.text:guessEncoding([lossy], [windows]) -> integer, boolean",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the length of the textObject",
        "stripped_doc" : [
          "Returns the length of the textObject",
          "",
          "Paramaters:",
          " * None",
          ""
        ],
        "name" : "len",
        "doc" : "Returns the length of the textObject\n\nParamaters:\n * None\n\nReturns:\n * an integer specifying the length of the textObject\n\nNotes:\n * if the textObject's encoding is 0 (rawData), this method will return the number of bytes of data the textObject contains\n * otherwise, the length will be the number of characters the data represents in its current encoding.",
        "notes" : [
          " * if the textObject's encoding is 0 (rawData), this method will return the number of bytes of data the textObject contains",
          " * otherwise, the length will be the number of characters the data represents in its current encoding."
        ],
        "signature" : "hs.text:len() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the length of the textObject",
          ""
        ],
        "def" : "hs.text:len() -> integer",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the raw data which makes up the contents of the textObject",
        "stripped_doc" : [
          "Returns the raw data which makes up the contents of the textObject",
          ""
        ],
        "name" : "rawData",
        "doc" : "Returns the raw data which makes up the contents of the textObject\n\nParameters:\n * None\n\nReturns:\n * a lua string containing the raw data of the textObject",
        "notes" : [

        ],
        "signature" : "hs.text:rawData() -> string",
        "type" : "Method",
        "returns" : [
          " * a lua string containing the raw data of the textObject"
        ],
        "def" : "hs.text:rawData() -> string",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the smallest encoding to which the textObject may be converted without loss of information.",
        "stripped_doc" : [
          "Returns the smallest encoding to which the textObject may be converted without loss of information.",
          ""
        ],
        "name" : "smallestEncoding",
        "doc" : "Returns the smallest encoding to which the textObject may be converted without loss of information.\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the encoding\n\nNotes:\n * this method works with string representation of the textObject in its current encoding.\n * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)\n * This encoding may not be the fastest for accessing characters, but is space-efficient. See also [hs.text:fastestEncoding](#fastestEncoding).",
        "notes" : [
          " * this method works with string representation of the textObject in its current encoding.",
          " * the integer returned will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
          " * This encoding may not be the fastest for accessing characters, but is space-efficient. See also [hs.text:fastestEncoding](#fastestEncoding)."
        ],
        "signature" : "hs.text:smallestEncoding() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the encoding",
          ""
        ],
        "def" : "hs.text:smallestEncoding() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a new hs.text.utf16 object representing the textObject for use with the `hs.text.utf16` submodule and its methods.",
        "stripped_doc" : [
          "Returns a new hs.text.utf16 object representing the textObject for use with the `hs.text.utf16` submodule and its methods.",
          ""
        ],
        "name" : "toUTF16",
        "doc" : "Returns a new hs.text.utf16 object representing the textObject for use with the `hs.text.utf16` submodule and its methods.\n\nParameters:\n * `lossy`    - a boolean, defailt false, specifying whether or not characters can be removed or altered in the conversion to UTF16.\n\nReturns:\n * a new `hs.text.utf16` object or nil if the conversion could not be performed.",
        "notes" : [

        ],
        "signature" : "hs.text:toUTF16([lossy]) -> utf16TextObject | nil",
        "type" : "Method",
        "returns" : [
          " * a new `hs.text.utf16` object or nil if the conversion could not be performed."
        ],
        "def" : "hs.text:toUTF16([lossy]) -> utf16TextObject | nil",
        "parameters" : [
          " * `lossy`    - a boolean, defailt false, specifying whether or not characters can be removed or altered in the conversion to UTF16.",
          ""
        ]
      },
      {
        "desc" : "Returns the textObject as a UTF8 string that can be printed and manipulated directly by lua.",
        "stripped_doc" : [
          "Returns the textObject as a UTF8 string that can be printed and manipulated directly by lua.",
          ""
        ],
        "name" : "tostring",
        "doc" : "Returns the textObject as a UTF8 string that can be printed and manipulated directly by lua.\n\nParameters:\n * `lossy`    - a boolean, defailt false, specifying whether or not characters can be removed or altered in the conversion to UTF8.\n\nReturns:\n * a lua string containing the UTF8 representation of the textObject. The string will be empty (i.e. \"\") if the conversion to UTF8 could not be performed.\n\nNotes:\n * this method is basically a wrapper for `textObject:asEncoding(hs.text.encodingTypes.UTF8, [lossy]):rawData()`",
        "notes" : [
          " * this method is basically a wrapper for `textObject:asEncoding(hs.text.encodingTypes.UTF8, [lossy]):rawData()`"
        ],
        "signature" : "hs.text:tostring([lossy]) -> string",
        "type" : "Method",
        "returns" : [
          " * a lua string containing the UTF8 representation of the textObject. The string will be empty (i.e. \"\") if the conversion to UTF8 could not be performed.",
          ""
        ],
        "def" : "hs.text:tostring([lossy]) -> string",
        "parameters" : [
          " * `lossy`    - a boolean, defailt false, specifying whether or not characters can be removed or altered in the conversion to UTF8.",
          ""
        ]
      },
      {
        "desc" : "Generate a list of possible encodings for the data represented by the hs.text object",
        "stripped_doc" : [
          "Generate a list of possible encodings for the data represented by the hs.text object",
          "",
          "Paramters:",
          " * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when evaluating each potential encoding.",
          ""
        ],
        "name" : "validEncodings",
        "doc" : "Generate a list of possible encodings for the data represented by the hs.text object\n\nParamters:\n * `lossy`   - an optional boolean, defailt false, specifying whether or not characters can be removed or altered when evaluating each potential encoding.\n\nReturns:\n * a table of integers specifying identified potential encodings for the data. Each integer will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)\n\nNotes:\n * this method works with the raw data contents of the textObject and ignores the currently assigned encoding.\n * the encodings identified are ones for which the bytes of data can represent valid character or formatting sequences within the encoding -- the specific textual representation for each encoding may differ. See the notes for [hs.text:asEncoding](#asEncoding) for an example of a byte sequence which has very different textual meanings for different encodings.",
        "notes" : [
          " * this method works with the raw data contents of the textObject and ignores the currently assigned encoding.",
          " * the encodings identified are ones for which the bytes of data can represent valid character or formatting sequences within the encoding -- the specific textual representation for each encoding may differ. See the notes for [hs.text:asEncoding](#asEncoding) for an example of a byte sequence which has very different textual meanings for different encodings."
        ],
        "signature" : "hs.text:validEncodings([lossy]) -> table of integers",
        "type" : "Method",
        "returns" : [
          " * a table of integers specifying identified potential encodings for the data. Each integer will correspond to an encoding defined in [hs.text.encodingTypes](#encodingTypes)",
          ""
        ],
        "def" : "hs.text:validEncodings([lossy]) -> table of integers",
        "parameters" : [

        ]
      },
      {
        "desc" : "Write the textObject to the specified file.",
        "stripped_doc" : [
          "Write the textObject to the specified file.",
          ""
        ],
        "name" : "writeToFile",
        "doc" : "Write the textObject to the specified file.\n\nParameters:\n * `path`     - a string specifying the absolute or relative (to your Hammerspoon configuration directory) path to save the data to.\n * `encoding` - an optional integer specifying the encoding to use when writing the file. If not specified, the current encoding of the textObject is used. See [hs.text.encodingTypes](#encodingTypes) for possible values.\n\nReturns:\n * the textObject, or nil and a string specifying the error",
        "notes" : [

        ],
        "signature" : "hs.text:writeToFile(path, [encoding]) -> textObject | nil, errorString",
        "type" : "Method",
        "returns" : [
          " * the textObject, or nil and a string specifying the error"
        ],
        "def" : "hs.text:writeToFile(path, [encoding]) -> textObject | nil, errorString",
        "parameters" : [
          " * `path`     - a string specifying the absolute or relative (to your Hammerspoon configuration directory) path to save the data to.",
          " * `encoding` - an optional integer specifying the encoding to use when writing the file. If not specified, the current encoding of the textObject is used. See [hs.text.encodingTypes](#encodingTypes) for possible values.",
          ""
        ]
      }
    ],
    "doc" : "This module provides functions and methods for converting text between the various encodings supported by macOS.\n\nThis module allows the import and export of text conforming to any of the encodings supported by macOS. Additionally, this module provides methods foc converting between encodings and attempting to identify the encoding of raw data when the original encoding may be unknown.\n\nBecause the macOS natively treats all textual data as UTF-16, additional support is provided in the `hs.text.utf16` submodule for working with textual data that has been converted to UTF16.\n\nFor performance reasons, the text objects are maintained as macOS native objects unless explicitely converted to a lua string with [hs.text:rawData](#rawData) or [hs.text:tostring](#tostring).",
    "name" : "hs.text"
  },
  {
    "Constant" : [

    ],
    "submodules" : [

    ],
    "Function" : [
      {
        "desc" : "Sends an HTTP GET request to a URL",
        "stripped_doc" : [
          "Sends an HTTP GET request to a URL",
          "",
          "Parameters",
          " * `url`     - A string containing the URL to retrieve",
          " * `headers` - A table containing string keys and values representing the request headers, or nil to add no headers",
          ""
        ],
        "name" : "get",
        "doc" : "Sends an HTTP GET request to a URL\n\nParameters\n * `url`     - A string containing the URL to retrieve\n * `headers` - A table containing string keys and values representing the request headers, or nil to add no headers\n\nReturns:\n * A number containing the HTTP response status\n * A textObject containing the response body\n * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions\n * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.asyncGet](#asyncGet) to avoid this.",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions",
          " * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.asyncGet](#asyncGet) to avoid this."
        ],
        "signature" : "hs.text.http.get(url, headers) -> int, textObject, table",
        "type" : "Function",
        "returns" : [
          " * A number containing the HTTP response status",
          " * A textObject containing the response body",
          " * A table containing the response headers",
          ""
        ],
        "def" : "hs.text.http.get(url, headers) -> int, textObject, table",
        "parameters" : [

        ]
      },
      {
        "desc" : "Sends an HTTP POST request to a URL",
        "stripped_doc" : [
          "Sends an HTTP POST request to a URL",
          "",
          "Parameters",
          " * `url`     - A string containing the URL to submit to",
          " * `data`    - A string or hs.text object containing the request body, or nil to send no body",
          " * `headers` - A table containing string keys and values representing the request headers, or nil to add no headers",
          ""
        ],
        "name" : "post",
        "doc" : "Sends an HTTP POST request to a URL\n\nParameters\n * `url`     - A string containing the URL to submit to\n * `data`    - A string or hs.text object containing the request body, or nil to send no body\n * `headers` - A table containing string keys and values representing the request headers, or nil to add no headers\n\nReturns:\n * A number containing the HTTP response status\n * A textObject containing the response body\n * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions\n * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.asyncPost](#asyncPost) to avoid this.",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions",
          " * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.asyncPost](#asyncPost) to avoid this."
        ],
        "signature" : "hs.text.http.post(url, data, headers) -> int, textObject, table",
        "type" : "Function",
        "returns" : [
          " * A number containing the HTTP response status",
          " * A textObject containing the response body",
          " * A table containing the response headers",
          ""
        ],
        "def" : "hs.text.http.post(url, data, headers) -> int, textObject, table",
        "parameters" : [

        ]
      },
      {
        "desc" : "Sends an HTTP GET request asynchronously",
        "stripped_doc" : [
          "Sends an HTTP GET request asynchronously",
          ""
        ],
        "name" : "asyncGet",
        "doc" : "Sends an HTTP GET request asynchronously\n\nParameters:\n * `url`      - A string containing the URL to retrieve\n * `headers`  - A table containing string keys and values representing the request headers, or nil to add no headers\n * `callback` - A function to be called when the request succeeds or fails. The function will be passed three parameters:\n  * A number containing the HTTP response status\n  * A textObject containing the response body\n  * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil"
        ],
        "signature" : "hs.text.http.asyncGet(url, headers, callback)",
        "type" : "Function",
        "returns" : [

        ],
        "def" : "hs.text.http.asyncGet(url, headers, callback)",
        "parameters" : [
          " * `url`      - A string containing the URL to retrieve",
          " * `headers`  - A table containing string keys and values representing the request headers, or nil to add no headers",
          " * `callback` - A function to be called when the request succeeds or fails. The function will be passed three parameters:",
          "  * A number containing the HTTP response status",
          "  * A textObject containing the response body",
          "  * A table containing the response headers",
          ""
        ]
      },
      {
        "desc" : "Sends an HTTP POST request asynchronously",
        "stripped_doc" : [
          "Sends an HTTP POST request asynchronously",
          ""
        ],
        "name" : "asyncPost",
        "doc" : "Sends an HTTP POST request asynchronously\n\nParameters:\n * `url`      - A string containing the URL to submit to\n * `data`     - A string or hs.text object containing the request body, or nil to send no body\n * `headers`  - A table containing string keys and values representing the request headers, or nil to add no headers\n * `callback` - A function to be called when the request succeeds or fails. The function will be passed three parameters:\n  * A number containing the HTTP response status\n  * A textObject containing the response body\n  * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil"
        ],
        "signature" : "hs.text.http.asyncPost(url, data, headers, callback)",
        "type" : "Function",
        "returns" : [

        ],
        "def" : "hs.text.http.asyncPost(url, data, headers, callback)",
        "parameters" : [
          " * `url`      - A string containing the URL to submit to",
          " * `data`     - A string or hs.text object containing the request body, or nil to send no body",
          " * `headers`  - A table containing string keys and values representing the request headers, or nil to add no headers",
          " * `callback` - A function to be called when the request succeeds or fails. The function will be passed three parameters:",
          "  * A number containing the HTTP response status",
          "  * A textObject containing the response body",
          "  * A table containing the response headers",
          ""
        ]
      },
      {
        "desc" : "Creates an HTTP request and executes it asynchronously",
        "stripped_doc" : [
          "Creates an HTTP request and executes it asynchronously",
          ""
        ],
        "name" : "doAsyncRequest",
        "doc" : "Creates an HTTP request and executes it asynchronously\n\nParameters:\n * `url`         - A string containing the URL\n * `method`      - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)\n * `data`        - A string or `hs.text` object containing the request body, or nil to send no body\n * `headers`     - A table containing string keys and values representing request header keys and values, or nil to add no headers\n * `callback`    - A function to called when the response is received. The function should accept three arguments:\n  * `code`    - A number containing the HTTP response code\n  * `body`    - An `hs.text` object containing the body of the response\n  * `headers` - A table containing the HTTP headers of the response\n * `cachePolicy` - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.\n\nReturns:\n * None\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n * If the Content-Type response header begins `text\/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes.",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          " * If the Content-Type response header begins `text\/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes."
        ],
        "signature" : "hs.text.http.doAsyncRequest(url, method, data, headers, callback, [cachePolicy])",
        "type" : "Function",
        "returns" : [
          " * None",
          ""
        ],
        "def" : "hs.text.http.doAsyncRequest(url, method, data, headers, callback, [cachePolicy])",
        "parameters" : [
          " * `url`         - A string containing the URL",
          " * `method`      - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)",
          " * `data`        - A string or `hs.text` object containing the request body, or nil to send no body",
          " * `headers`     - A table containing string keys and values representing request header keys and values, or nil to add no headers",
          " * `callback`    - A function to called when the response is received. The function should accept three arguments:",
          "  * `code`    - A number containing the HTTP response code",
          "  * `body`    - An `hs.text` object containing the body of the response",
          "  * `headers` - A table containing the HTTP headers of the response",
          " * `cachePolicy` - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.",
          ""
        ]
      },
      {
        "desc" : "Creates an HTTP request and executes it synchronously",
        "stripped_doc" : [
          "Creates an HTTP request and executes it synchronously",
          ""
        ],
        "name" : "doRequest",
        "doc" : "Creates an HTTP request and executes it synchronously\n\nParameters:\n * `url`         - A string containing the URL\n * `method`      - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)\n * `data`        - An optional string or `hs.text` object containing the data to POST to the URL, or nil to send no data\n * `headers`     - An optional table of string keys and values used as headers for the request, or nil to add no headers\n * `cachePolicy` - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.\n\nReturns:\n * A number containing the HTTP response status code\n * An `hs.text` object containing the response body\n * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * This function is synchronous and will therefore block all Lua execution until it completes. You are encouraged to use the asynchronous functions.\n * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.doAsyncRequest](#doAsyncRequest) to avoid this.\n * If the Content-Type response header begins `text\/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes.",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * This function is synchronous and will therefore block all Lua execution until it completes. You are encouraged to use the asynchronous functions.",
          " * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.doAsyncRequest](#doAsyncRequest) to avoid this.",
          " * If the Content-Type response header begins `text\/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes."
        ],
        "signature" : "hs.text.http.doRequest(url, method, [data, headers, cachePolicy]) -> int, textObject, table",
        "type" : "Function",
        "returns" : [
          " * A number containing the HTTP response status code",
          " * An `hs.text` object containing the response body",
          " * A table containing the response headers",
          ""
        ],
        "def" : "hs.text.http.doRequest(url, method, [data, headers, cachePolicy]) -> int, textObject, table",
        "parameters" : [
          " * `url`         - A string containing the URL",
          " * `method`      - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)",
          " * `data`        - An optional string or `hs.text` object containing the data to POST to the URL, or nil to send no data",
          " * `headers`     - An optional table of string keys and values used as headers for the request, or nil to add no headers",
          " * `cachePolicy` - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.",
          ""
        ]
      }
    ],
    "Variable" : [

    ],
    "stripped_doc" : [

    ],
    "desc" : "Perform HTTP requests with hs.text objects",
    "Deprecated" : [

    ],
    "type" : "Module",
    "Constructor" : [

    ],
    "Field" : [

    ],
    "Method" : [

    ],
    "Command" : [

    ],
    "items" : [
      {
        "desc" : "Sends an HTTP GET request asynchronously",
        "stripped_doc" : [
          "Sends an HTTP GET request asynchronously",
          ""
        ],
        "name" : "asyncGet",
        "doc" : "Sends an HTTP GET request asynchronously\n\nParameters:\n * `url`      - A string containing the URL to retrieve\n * `headers`  - A table containing string keys and values representing the request headers, or nil to add no headers\n * `callback` - A function to be called when the request succeeds or fails. The function will be passed three parameters:\n  * A number containing the HTTP response status\n  * A textObject containing the response body\n  * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil"
        ],
        "signature" : "hs.text.http.asyncGet(url, headers, callback)",
        "type" : "Function",
        "returns" : [

        ],
        "def" : "hs.text.http.asyncGet(url, headers, callback)",
        "parameters" : [
          " * `url`      - A string containing the URL to retrieve",
          " * `headers`  - A table containing string keys and values representing the request headers, or nil to add no headers",
          " * `callback` - A function to be called when the request succeeds or fails. The function will be passed three parameters:",
          "  * A number containing the HTTP response status",
          "  * A textObject containing the response body",
          "  * A table containing the response headers",
          ""
        ]
      },
      {
        "desc" : "Sends an HTTP POST request asynchronously",
        "stripped_doc" : [
          "Sends an HTTP POST request asynchronously",
          ""
        ],
        "name" : "asyncPost",
        "doc" : "Sends an HTTP POST request asynchronously\n\nParameters:\n * `url`      - A string containing the URL to submit to\n * `data`     - A string or hs.text object containing the request body, or nil to send no body\n * `headers`  - A table containing string keys and values representing the request headers, or nil to add no headers\n * `callback` - A function to be called when the request succeeds or fails. The function will be passed three parameters:\n  * A number containing the HTTP response status\n  * A textObject containing the response body\n  * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil"
        ],
        "signature" : "hs.text.http.asyncPost(url, data, headers, callback)",
        "type" : "Function",
        "returns" : [

        ],
        "def" : "hs.text.http.asyncPost(url, data, headers, callback)",
        "parameters" : [
          " * `url`      - A string containing the URL to submit to",
          " * `data`     - A string or hs.text object containing the request body, or nil to send no body",
          " * `headers`  - A table containing string keys and values representing the request headers, or nil to add no headers",
          " * `callback` - A function to be called when the request succeeds or fails. The function will be passed three parameters:",
          "  * A number containing the HTTP response status",
          "  * A textObject containing the response body",
          "  * A table containing the response headers",
          ""
        ]
      },
      {
        "desc" : "Creates an HTTP request and executes it asynchronously",
        "stripped_doc" : [
          "Creates an HTTP request and executes it asynchronously",
          ""
        ],
        "name" : "doAsyncRequest",
        "doc" : "Creates an HTTP request and executes it asynchronously\n\nParameters:\n * `url`         - A string containing the URL\n * `method`      - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)\n * `data`        - A string or `hs.text` object containing the request body, or nil to send no body\n * `headers`     - A table containing string keys and values representing request header keys and values, or nil to add no headers\n * `callback`    - A function to called when the response is received. The function should accept three arguments:\n  * `code`    - A number containing the HTTP response code\n  * `body`    - An `hs.text` object containing the body of the response\n  * `headers` - A table containing the HTTP headers of the response\n * `cachePolicy` - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.\n\nReturns:\n * None\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n * If the Content-Type response header begins `text\/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes.",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          " * If the Content-Type response header begins `text\/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes."
        ],
        "signature" : "hs.text.http.doAsyncRequest(url, method, data, headers, callback, [cachePolicy])",
        "type" : "Function",
        "returns" : [
          " * None",
          ""
        ],
        "def" : "hs.text.http.doAsyncRequest(url, method, data, headers, callback, [cachePolicy])",
        "parameters" : [
          " * `url`         - A string containing the URL",
          " * `method`      - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)",
          " * `data`        - A string or `hs.text` object containing the request body, or nil to send no body",
          " * `headers`     - A table containing string keys and values representing request header keys and values, or nil to add no headers",
          " * `callback`    - A function to called when the response is received. The function should accept three arguments:",
          "  * `code`    - A number containing the HTTP response code",
          "  * `body`    - An `hs.text` object containing the body of the response",
          "  * `headers` - A table containing the HTTP headers of the response",
          " * `cachePolicy` - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.",
          ""
        ]
      },
      {
        "desc" : "Creates an HTTP request and executes it synchronously",
        "stripped_doc" : [
          "Creates an HTTP request and executes it synchronously",
          ""
        ],
        "name" : "doRequest",
        "doc" : "Creates an HTTP request and executes it synchronously\n\nParameters:\n * `url`         - A string containing the URL\n * `method`      - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)\n * `data`        - An optional string or `hs.text` object containing the data to POST to the URL, or nil to send no data\n * `headers`     - An optional table of string keys and values used as headers for the request, or nil to add no headers\n * `cachePolicy` - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.\n\nReturns:\n * A number containing the HTTP response status code\n * An `hs.text` object containing the response body\n * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * This function is synchronous and will therefore block all Lua execution until it completes. You are encouraged to use the asynchronous functions.\n * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.doAsyncRequest](#doAsyncRequest) to avoid this.\n * If the Content-Type response header begins `text\/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes.",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * This function is synchronous and will therefore block all Lua execution until it completes. You are encouraged to use the asynchronous functions.",
          " * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.doAsyncRequest](#doAsyncRequest) to avoid this.",
          " * If the Content-Type response header begins `text\/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes."
        ],
        "signature" : "hs.text.http.doRequest(url, method, [data, headers, cachePolicy]) -> int, textObject, table",
        "type" : "Function",
        "returns" : [
          " * A number containing the HTTP response status code",
          " * An `hs.text` object containing the response body",
          " * A table containing the response headers",
          ""
        ],
        "def" : "hs.text.http.doRequest(url, method, [data, headers, cachePolicy]) -> int, textObject, table",
        "parameters" : [
          " * `url`         - A string containing the URL",
          " * `method`      - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)",
          " * `data`        - An optional string or `hs.text` object containing the data to POST to the URL, or nil to send no data",
          " * `headers`     - An optional table of string keys and values used as headers for the request, or nil to add no headers",
          " * `cachePolicy` - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.",
          ""
        ]
      },
      {
        "desc" : "Sends an HTTP GET request to a URL",
        "stripped_doc" : [
          "Sends an HTTP GET request to a URL",
          "",
          "Parameters",
          " * `url`     - A string containing the URL to retrieve",
          " * `headers` - A table containing string keys and values representing the request headers, or nil to add no headers",
          ""
        ],
        "name" : "get",
        "doc" : "Sends an HTTP GET request to a URL\n\nParameters\n * `url`     - A string containing the URL to retrieve\n * `headers` - A table containing string keys and values representing the request headers, or nil to add no headers\n\nReturns:\n * A number containing the HTTP response status\n * A textObject containing the response body\n * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions\n * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.asyncGet](#asyncGet) to avoid this.",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions",
          " * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.asyncGet](#asyncGet) to avoid this."
        ],
        "signature" : "hs.text.http.get(url, headers) -> int, textObject, table",
        "type" : "Function",
        "returns" : [
          " * A number containing the HTTP response status",
          " * A textObject containing the response body",
          " * A table containing the response headers",
          ""
        ],
        "def" : "hs.text.http.get(url, headers) -> int, textObject, table",
        "parameters" : [

        ]
      },
      {
        "desc" : "Sends an HTTP POST request to a URL",
        "stripped_doc" : [
          "Sends an HTTP POST request to a URL",
          "",
          "Parameters",
          " * `url`     - A string containing the URL to submit to",
          " * `data`    - A string or hs.text object containing the request body, or nil to send no body",
          " * `headers` - A table containing string keys and values representing the request headers, or nil to add no headers",
          ""
        ],
        "name" : "post",
        "doc" : "Sends an HTTP POST request to a URL\n\nParameters\n * `url`     - A string containing the URL to submit to\n * `data`    - A string or hs.text object containing the request body, or nil to send no body\n * `headers` - A table containing string keys and values representing the request headers, or nil to add no headers\n\nReturns:\n * A number containing the HTTP response status\n * A textObject containing the response body\n * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions\n * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.asyncPost](#asyncPost) to avoid this.",
        "notes" : [
          " * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http:\/\/user:password@host.com\/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.",
          "",
          " * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions",
          " * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.text.http.asyncPost](#asyncPost) to avoid this."
        ],
        "signature" : "hs.text.http.post(url, data, headers) -> int, textObject, table",
        "type" : "Function",
        "returns" : [
          " * A number containing the HTTP response status",
          " * A textObject containing the response body",
          " * A table containing the response headers",
          ""
        ],
        "def" : "hs.text.http.post(url, data, headers) -> int, textObject, table",
        "parameters" : [

        ]
      }
    ],
    "doc" : "Perform HTTP requests with hs.text objects\n\nThis submodule is a subset of the `hs.http` module modified to return `hs.text` objects for the response body of http requests. For http methods which allow submitting a body (e.g. POST), `hs.text` object may be used instead of lua strings as well.",
    "name" : "hs.text.http"
  },
  {
    "Constant" : [
      {
        "desc" : "Built in transormations which can be used with [hs.text.utf16:transform](#transform).",
        "stripped_doc" : [
          "Built in transormations which can be used with [hs.text.utf16:transform](#transform).",
          "",
          "This table contains key-value pairs identifying built in transforms provided by the macOS Objective-C runtime environment for use with [hs.text.utf16:transform](#transform). See http:\/\/userguide.icu-project.org\/transforms\/general for a more complete discussion on how to specify your own transformations.",
          "",
          "The built in transformations are:",
          " * `fullwidthToHalfwidth` - transform full-width CJK characters to their half-width forms. e.g. “マット” transforms to “ﾏｯﾄ”. This transformation is reversible.",
          " * `hiraganaToKatakana`   - transliterate the text from Hiragana script to Katakana script. e.g. “ひらがな” transliterates to “カタカナ”. This transformation is reversible.",
          " * `latinToArabic`        - transliterate the text from Latin script to Arabic script. e.g. “ạlʿarabīẗ‎” transliterates to “العَرَبِية”. This transformation is reversible.",
          " * `latinToCyrillic`      - transliterate the text from Latin script to Cyrillic script. e.g. “kirillica” transliterates to “кириллица”. This transformation is reversible.",
          " * `latinToGreek`         - transliterate the text from Latin script to Greek script. e.g. “Ellēnikó alphábēto‎” transliterates to “Ελληνικό αλφάβητο”. This transformation is reversible.",
          " * `latinToHangul`        - transliterate the text from Latin script to Hangul script. e.g. “hangul” transliterates to “한굴”. This transformation is reversible.",
          " * `latinToHebrew`        - transliterate the text from Latin script to Hebrew script. e.g. “ʻbryţ” transliterates to “עברית”. This transformation is reversible.",
          " * `latinToHiragana`      - transliterate the text from Latin script to Hiragana script. e.g. “hiragana” transliterates to “ひらがな”. This transformation is reversible.",
          " * `latinToKatakana`      - transliterate the text from Latin script to Katakana script. e.g. “katakana” transliterates to “カタカナ”. This transformation is reversible.",
          " * `latinToThai`          - transliterate the text from Latin script to Thai script. e.g. “p̣hās̄ʹā thịy” transliterates to “ภาษาไทย”. This transformation is reversible.",
          " * `mandarinToLatin`      - transliterate the text from Han script to Latin script. e.g. “hàn zì” transliterates to “汉字”.",
          " * `stripCombiningMarks`  - removes all combining marks (including diacritics and accents) from the text",
          " * `stripDiacritics`      - removes all diacritic marks from the text",
          " * `toLatin`              - transliterate all text possible to Latin script. Ideographs are transliterated as Mandarin Chinese.",
          " * `toUnicodeName`        - converts characters other than printable ASCII to their Unicode character name in braces. e.g. “🐶🐮” transforms to \"\\N{DOG FACE}\\N{COW FACE}\". This transformation is reversible.",
          " * `toXMLHex`             - transliterate characters other than printable ASCII to XML\/HTML numeric entities. e.g. “❦” transforms to “&#x2766;”. This transformation is reversible."
        ],
        "name" : "builtInTransforms",
        "doc" : "Built in transormations which can be used with [hs.text.utf16:transform](#transform).\n\nThis table contains key-value pairs identifying built in transforms provided by the macOS Objective-C runtime environment for use with [hs.text.utf16:transform](#transform). See http:\/\/userguide.icu-project.org\/transforms\/general for a more complete discussion on how to specify your own transformations.\n\nThe built in transformations are:\n * `fullwidthToHalfwidth` - transform full-width CJK characters to their half-width forms. e.g. “マット” transforms to “ﾏｯﾄ”. This transformation is reversible.\n * `hiraganaToKatakana`   - transliterate the text from Hiragana script to Katakana script. e.g. “ひらがな” transliterates to “カタカナ”. This transformation is reversible.\n * `latinToArabic`        - transliterate the text from Latin script to Arabic script. e.g. “ạlʿarabīẗ‎” transliterates to “العَرَبِية”. This transformation is reversible.\n * `latinToCyrillic`      - transliterate the text from Latin script to Cyrillic script. e.g. “kirillica” transliterates to “кириллица”. This transformation is reversible.\n * `latinToGreek`         - transliterate the text from Latin script to Greek script. e.g. “Ellēnikó alphábēto‎” transliterates to “Ελληνικό αλφάβητο”. This transformation is reversible.\n * `latinToHangul`        - transliterate the text from Latin script to Hangul script. e.g. “hangul” transliterates to “한굴”. This transformation is reversible.\n * `latinToHebrew`        - transliterate the text from Latin script to Hebrew script. e.g. “ʻbryţ” transliterates to “עברית”. This transformation is reversible.\n * `latinToHiragana`      - transliterate the text from Latin script to Hiragana script. e.g. “hiragana” transliterates to “ひらがな”. This transformation is reversible.\n * `latinToKatakana`      - transliterate the text from Latin script to Katakana script. e.g. “katakana” transliterates to “カタカナ”. This transformation is reversible.\n * `latinToThai`          - transliterate the text from Latin script to Thai script. e.g. “p̣hās̄ʹā thịy” transliterates to “ภาษาไทย”. This transformation is reversible.\n * `mandarinToLatin`      - transliterate the text from Han script to Latin script. e.g. “hàn zì” transliterates to “汉字”.\n * `stripCombiningMarks`  - removes all combining marks (including diacritics and accents) from the text\n * `stripDiacritics`      - removes all diacritic marks from the text\n * `toLatin`              - transliterate all text possible to Latin script. Ideographs are transliterated as Mandarin Chinese.\n * `toUnicodeName`        - converts characters other than printable ASCII to their Unicode character name in braces. e.g. “🐶🐮” transforms to \"\\N{DOG FACE}\\N{COW FACE}\". This transformation is reversible.\n * `toXMLHex`             - transliterate characters other than printable ASCII to XML\/HTML numeric entities. e.g. “❦” transforms to “&#x2766;”. This transformation is reversible.",
        "notes" : [

        ],
        "signature" : "hs.text.utf16.builtInTransforms",
        "type" : "Constant",
        "returns" : [

        ],
        "def" : "hs.text.utf16.builtInTransforms",
        "parameters" : [

        ]
      },
      {
        "desc" : "A table containing the modifier options for use with the [hs.text.utf16:compare](#compare) method.",
        "stripped_doc" : [
          "A table containing the modifier options for use with the [hs.text.utf16:compare](#compare) method.",
          "",
          "This table contains key-value pairs specifying the numeric values which should be logically OR'ed together (or listed individually in a table as either the integer or the key name) for use with the [hs.text.utf16:compare](#compare) method.",
          "",
          "Valid options are as follows:",
          " * `caseInsensitive`      - sort order is case-insensitive",
          " * `diacriticInsensitive` - ignores diacritic marks",
          " * `finderFileOrder`      - sort order matches what the Finder uses for the locale specified. This is a convienence combination which is equivalent to `{ \"caseInsensitive\", \"numeric\", \"widthInsensitive\", \"forcedOrdering\" }`.",
          " * `forcedOrdering`       - comparisons are forced to return either -1 or 1 if the strings are equivalent but not strictly equal. (e.g.  “aaa” is greater than \"AAA\" if `caseInsensitive` is also set.)",
          " * `literal`              - exact character-by-character equivalence.",
          " * `numeric`              - numbers within the string are compared numerically. This only applies to actual numeric characters, not characters that would have meaning in a numeric representation such as a negative sign, a comma, or a decimal point.",
          " * `widthInsensitive`     - ignores width differences in characters that have full-width and half-width forms, common in East Asian character sets."
        ],
        "name" : "compareOptions",
        "doc" : "A table containing the modifier options for use with the [hs.text.utf16:compare](#compare) method.\n\nThis table contains key-value pairs specifying the numeric values which should be logically OR'ed together (or listed individually in a table as either the integer or the key name) for use with the [hs.text.utf16:compare](#compare) method.\n\nValid options are as follows:\n * `caseInsensitive`      - sort order is case-insensitive\n * `diacriticInsensitive` - ignores diacritic marks\n * `finderFileOrder`      - sort order matches what the Finder uses for the locale specified. This is a convienence combination which is equivalent to `{ \"caseInsensitive\", \"numeric\", \"widthInsensitive\", \"forcedOrdering\" }`.\n * `forcedOrdering`       - comparisons are forced to return either -1 or 1 if the strings are equivalent but not strictly equal. (e.g.  “aaa” is greater than \"AAA\" if `caseInsensitive` is also set.)\n * `literal`              - exact character-by-character equivalence.\n * `numeric`              - numbers within the string are compared numerically. This only applies to actual numeric characters, not characters that would have meaning in a numeric representation such as a negative sign, a comma, or a decimal point.\n * `widthInsensitive`     - ignores width differences in characters that have full-width and half-width forms, common in East Asian character sets.",
        "notes" : [

        ],
        "signature" : "hs.text.utf16.compareOptions",
        "type" : "Constant",
        "returns" : [

        ],
        "def" : "hs.text.utf16.compareOptions",
        "parameters" : [

        ]
      }
    ],
    "submodules" : [

    ],
    "Function" : [
      {
        "desc" : "Returns whether or not the specified 16-bit UTF16 unit character is a High Surrogate",
        "stripped_doc" : [
          "Returns whether or not the specified 16-bit UTF16 unit character is a High Surrogate",
          ""
        ],
        "name" : "isHighSurrogate",
        "doc" : "Returns whether or not the specified 16-bit UTF16 unit character is a High Surrogate\n\nParameters:\n * `unitchar` - an integer specifying a single UTF16 character\n\nReturns:\n * a boolean specifying whether or not the single UTF16 character specified is a High Surrogate (true) or not (false).\n\nNotes:\n * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.\n   * A high surrogate is a single UTF16 \"character\" with an integer representation between 0xD800 and 0xDBFF inclusive\n   * A low surrogate is a single UTF16 \"character\" with an integer representation between 0xDC00 and 0xDFFF inclusive.\n   * It is an encoding error if a high surrogate is not immediately followed by a low surrogate or for either surrogate type to be found by itself or surrounded by UTF16 characters outside of the surrogate pair ranges. However, most implementations silently ignore this and simply treat unpaired surrogates as unprintable (control characters) or equivalent to the Unicode Replacement character (U+FFFD).\n\n* See also [hs.text.utf16.isLowSurrogate](#isLowSurrogate)",
        "notes" : [
          " * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.",
          "   * A high surrogate is a single UTF16 \"character\" with an integer representation between 0xD800 and 0xDBFF inclusive",
          "   * A low surrogate is a single UTF16 \"character\" with an integer representation between 0xDC00 and 0xDFFF inclusive.",
          "   * It is an encoding error if a high surrogate is not immediately followed by a low surrogate or for either surrogate type to be found by itself or surrounded by UTF16 characters outside of the surrogate pair ranges. However, most implementations silently ignore this and simply treat unpaired surrogates as unprintable (control characters) or equivalent to the Unicode Replacement character (U+FFFD).",
          "",
          "* See also [hs.text.utf16.isLowSurrogate](#isLowSurrogate)"
        ],
        "signature" : "hs.text.utf16.isHighSurrogate(unitchar) -> boolean",
        "type" : "Function",
        "returns" : [
          " * a boolean specifying whether or not the single UTF16 character specified is a High Surrogate (true) or not (false).",
          ""
        ],
        "def" : "hs.text.utf16.isHighSurrogate(unitchar) -> boolean",
        "parameters" : [
          " * `unitchar` - an integer specifying a single UTF16 character",
          ""
        ]
      },
      {
        "desc" : "Returns whether or not the specified 16-bit UTF16 unit character is a Low Surrogate",
        "stripped_doc" : [
          "Returns whether or not the specified 16-bit UTF16 unit character is a Low Surrogate",
          ""
        ],
        "name" : "isLowSurrogate",
        "doc" : "Returns whether or not the specified 16-bit UTF16 unit character is a Low Surrogate\n\nParameters:\n * `unitchar` - an integer specifying a single UTF16 character\n\nReturns:\n * a boolean specifying whether or not the single UTF16 character specified is a Low Surrogate (true) or not (false).\n\nNotes:\n * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.\n   * A high surrogate is a single UTF16 \"character\" with an integer representation between 0xD800 and 0xDBFF inclusive\n   * A low surrogate is a single UTF16 \"character\" with an integer representation between 0xDC00 and 0xDFFF inclusive.\n   * It is an encoding error if a high surrogate is not immediately followed by a low surrogate or for either surrogate type to be found by itself or surrounded by UTF16 characters outside of the surrogate pair ranges. However, most implementations silently ignore this and simply treat unpaired surrogates as unprintable (control characters) or equivalent to the Unicode Replacement character (U+FFFD).\n\n* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate)",
        "notes" : [
          " * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.",
          "   * A high surrogate is a single UTF16 \"character\" with an integer representation between 0xD800 and 0xDBFF inclusive",
          "   * A low surrogate is a single UTF16 \"character\" with an integer representation between 0xDC00 and 0xDFFF inclusive.",
          "   * It is an encoding error if a high surrogate is not immediately followed by a low surrogate or for either surrogate type to be found by itself or surrounded by UTF16 characters outside of the surrogate pair ranges. However, most implementations silently ignore this and simply treat unpaired surrogates as unprintable (control characters) or equivalent to the Unicode Replacement character (U+FFFD).",
          "",
          "* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate)"
        ],
        "signature" : "hs.text.utf16.isLowSurrogate(unitchar) -> boolean",
        "type" : "Function",
        "returns" : [
          " * a boolean specifying whether or not the single UTF16 character specified is a Low Surrogate (true) or not (false).",
          ""
        ],
        "def" : "hs.text.utf16.isLowSurrogate(unitchar) -> boolean",
        "parameters" : [
          " * `unitchar` - an integer specifying a single UTF16 character",
          ""
        ]
      },
      {
        "desc" : "Returns the surrogate pair for the specified Unicode Codepoint",
        "stripped_doc" : [
          "Returns the surrogate pair for the specified Unicode Codepoint",
          ""
        ],
        "name" : "surrogatePairForCodepoint",
        "doc" : "Returns the surrogate pair for the specified Unicode Codepoint\n\nParameters:\n * `codepoint` - an integer specifying the Unicode codepoint\n\nReturns:\n * if the codepoint is between U+010000 to U+10FFFF, returns the UTF16 surrogate pair for the character as 2 integers; otherwise returns nil\n\nNotes:\n * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.\n\n* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate)",
        "notes" : [
          " * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.",
          "",
          "* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate)"
        ],
        "signature" : "hs.text.utf16.surrogatePairForCodepoint(codepoint) -> integer, integer | nil",
        "type" : "Function",
        "returns" : [
          " * if the codepoint is between U+010000 to U+10FFFF, returns the UTF16 surrogate pair for the character as 2 integers; otherwise returns nil",
          ""
        ],
        "def" : "hs.text.utf16.surrogatePairForCodepoint(codepoint) -> integer, integer | nil",
        "parameters" : [
          " * `codepoint` - an integer specifying the Unicode codepoint",
          ""
        ]
      },
      {
        "desc" : "Returns the Unicode Codepoint number for the specified high and low surrogate pair",
        "stripped_doc" : [
          "Returns the Unicode Codepoint number for the specified high and low surrogate pair",
          ""
        ],
        "name" : "codepointForSurrogatePair",
        "doc" : "Returns the Unicode Codepoint number for the specified high and low surrogate pair\n\nParameters:\n * `high` - an integer specifying the UTF16 \"character\" specifying the High Surrogate\n * `low` - an integer specifying the UTF16 \"character\" specifying the Low Surrogate\n\nReturns:\n * if the `high` and `low` values specify a valid UTF16 surrogate pair, returns an integer specifying the codepoint for the pair; otherwise returns nil\n\nNotes:\n * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.\n\n* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate)",
        "notes" : [
          " * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.",
          "",
          "* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate)"
        ],
        "signature" : "hs.text.utf16.codepointForSurrogatePair(high, low) -> integer | nil",
        "type" : "Function",
        "returns" : [
          " * if the `high` and `low` values specify a valid UTF16 surrogate pair, returns an integer specifying the codepoint for the pair; otherwise returns nil",
          ""
        ],
        "def" : "hs.text.utf16.codepointForSurrogatePair(high, low) -> integer | nil",
        "parameters" : [
          " * `high` - an integer specifying the UTF16 \"character\" specifying the High Surrogate",
          " * `low` - an integer specifying the UTF16 \"character\" specifying the Low Surrogate",
          ""
        ]
      }
    ],
    "Variable" : [

    ],
    "stripped_doc" : [

    ],
    "desc" : "Perform text manipulation on UTF16 objects created by the `hs.text` module.",
    "Deprecated" : [

    ],
    "type" : "Module",
    "Constructor" : [
      {
        "desc" : "Create a new utf16TextObject from a lua string or `hs.text` object",
        "stripped_doc" : [
          "Create a new utf16TextObject from a lua string or `hs.text` object",
          ""
        ],
        "name" : "new",
        "doc" : "Create a new utf16TextObject from a lua string or `hs.text` object\n\nParameters:\n * `text`  - a lua string or `hs.text` object specifying the text for the new utf16TextObject\n * `lossy` - an optional boolean, default `false`, specifying whether or not characters can be removed or altered when converting the data to the UTF16 encoding.\n\nReturns:\n * a new utf16TextObject, or nil if the data could not be encoded as a utf16TextObject",
        "notes" : [

        ],
        "signature" : "hs.text.utf16.new(text, [lossy]) -> utf16TextObject",
        "type" : "Constructor",
        "returns" : [
          " * a new utf16TextObject, or nil if the data could not be encoded as a utf16TextObject"
        ],
        "def" : "hs.text.utf16.new(text, [lossy]) -> utf16TextObject",
        "parameters" : [
          " * `text`  - a lua string or `hs.text` object specifying the text for the new utf16TextObject",
          " * `lossy` - an optional boolean, default `false`, specifying whether or not characters can be removed or altered when converting the data to the UTF16 encoding.",
          ""
        ]
      },
      {
        "desc" : "Create a new utf16TextObject from the Unicode Codepoints specified.",
        "stripped_doc" : [
          "Create a new utf16TextObject from the Unicode Codepoints specified.",
          "",
          "Paramters:",
          " * zero or more Unicode Codepoints specified as integers",
          ""
        ],
        "name" : "char",
        "doc" : "Create a new utf16TextObject from the Unicode Codepoints specified.\n\nParamters:\n * zero or more Unicode Codepoints specified as integers\n\nReturns:\n * a new utf16TextObject\n\nNotes:\n * Unicode Codepoints are often written as `U+xxxx` where `xxxx` is between 4 and 6 hexadecimal digits. Lua can automatically convert hexadecimal numbers to integers, so replace the `U+` with `0x` when specifying codepoints in this format.",
        "notes" : [
          " * Unicode Codepoints are often written as `U+xxxx` where `xxxx` is between 4 and 6 hexadecimal digits. Lua can automatically convert hexadecimal numbers to integers, so replace the `U+` with `0x` when specifying codepoints in this format."
        ],
        "signature" : "hs.text.utf16.char(...) -> utf16TextObject",
        "type" : "Constructor",
        "returns" : [
          " * a new utf16TextObject",
          ""
        ],
        "def" : "hs.text.utf16.char(...) -> utf16TextObject",
        "parameters" : [

        ]
      }
    ],
    "Field" : [

    ],
    "Method" : [
      {
        "desc" : "Returns an iterator function that iteratively returns the captures (if specified) or the entire match (if no captures are specified) of the pattern over the utf16TextObject.",
        "stripped_doc" : [
          "Returns an iterator function that iteratively returns the captures (if specified) or the entire match (if no captures are specified) of the pattern over the utf16TextObject.",
          "",
          "Paramters:",
          " * `pattern` - a lua string or utf16TextObject specifying the pattern to iteratively match over the utf16TextObject.",
          ""
        ],
        "name" : "gmatch",
        "doc" : "Returns an iterator function that iteratively returns the captures (if specified) or the entire match (if no captures are specified) of the pattern over the utf16TextObject.\n\nParamters:\n * `pattern` - a lua string or utf16TextObject specifying the pattern to iteratively match over the utf16TextObject.\n\nReturns:\n * an iterator function which can be used with the lua `for` command as an iterator.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.gmatch`.\n * This method uses the [hs.text.utf16:find](#find) method on a copy of the original string, so it is safe to modify the original object within the loop. See the documentation for [find](#find) for information on the format of `pattern`.\n\n * The following examples are from the Lua documentation for `string.gmatch` modified with the proper syntax:\n\n     ~~~\n     -- print each word on a separate line\n     s = hs.text.utf16.new(\"hello world from Lua\")\n     for w in s:gmatch([[\\p{Alphabetic}+]]) do\n       print(w)\n     end\n\n     -- collect all pairs key=value from the given string into a table:\n     t = {}\n     s = hs.text.utf16.new(\"from=world, to=Lua\")\n     for k, v in s:gmatch([[(\\w+)=(\\w+)]]) do\n       t[tostring(k)] = tostring(v)\n     end\n     ~~~",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.gmatch`.",
          " * This method uses the [hs.text.utf16:find](#find) method on a copy of the original string, so it is safe to modify the original object within the loop. See the documentation for [find](#find) for information on the format of `pattern`.",
          "",
          " * The following examples are from the Lua documentation for `string.gmatch` modified with the proper syntax:",
          "",
          "     ~~~",
          "     -- print each word on a separate line",
          "     s = hs.text.utf16.new(\"hello world from Lua\")",
          "     for w in s:gmatch([[\\p{Alphabetic}+]]) do",
          "       print(w)",
          "     end",
          "",
          "     -- collect all pairs key=value from the given string into a table:",
          "     t = {}",
          "     s = hs.text.utf16.new(\"from=world, to=Lua\")",
          "     for k, v in s:gmatch([[(\\w+)=(\\w+)]]) do",
          "       t[tostring(k)] = tostring(v)",
          "     end",
          "     ~~~"
        ],
        "signature" : "hs.text.utf16:gmatch(pattern) -> iteratorFunction",
        "type" : "Method",
        "returns" : [
          " * an iterator function which can be used with the lua `for` command as an iterator.",
          ""
        ],
        "def" : "hs.text.utf16:gmatch(pattern) -> iteratorFunction",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns an iterator function that returns the index position (in UTF16 characters) and codepoint of each character in the utf16TextObject.",
        "stripped_doc" : [
          "Returns an iterator function that returns the index position (in UTF16 characters) and codepoint of each character in the utf16TextObject.",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "codes",
        "doc" : "Returns an iterator function that returns the index position (in UTF16 characters) and codepoint of each character in the utf16TextObject.\n\nParamters:\n * None\n\nReturns:\n * an iterator function which can be used with the lua `for` command as an iterator.\n\nNotes:\n * This method is the utf16 equivalent of lua's `utf8.codes`.\n * Example usage:\n\n     ~~~\n     s = hs.text.utf16.new(\"Test 🙂 123\")\n     for p,c in s:codes() do print(p, string.format(\"U+%04x\", c)) end\n     ~~~",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `utf8.codes`.",
          " * Example usage:",
          "",
          "     ~~~",
          "     s = hs.text.utf16.new(\"Test 🙂 123\")",
          "     for p,c in s:codes() do print(p, string.format(\"U+%04x\", c)) end",
          "     ~~~"
        ],
        "signature" : "hs.text.utf16:codes() -> iteratorFunction",
        "type" : "Method",
        "returns" : [
          " * an iterator function which can be used with the lua `for` command as an iterator.",
          ""
        ],
        "def" : "hs.text.utf16:codes() -> iteratorFunction",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns an iterator function that returns the indicies of each character in the utf16TextObject, treating surrogate pairs and composed character sequences as single characters.",
        "stripped_doc" : [
          "Returns an iterator function that returns the indicies of each character in the utf16TextObject, treating surrogate pairs and composed character sequences as single characters.",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "composedCharacters",
        "doc" : "Returns an iterator function that returns the indicies of each character in the utf16TextObject, treating surrogate pairs and composed character sequences as single characters.\n\nParamters:\n * None\n\nReturns:\n * an iterator function which can be used with the lua `for` command as an iterator.\n\nNotes:\n * Example usage:\n\n     ~~~\n     s = hs.text.utf16.new(\"abc🙂123\") .. hs.text.utf16.char(0x073, 0x0323, 0x0307) .. \"xyz\"\n     for i,j in s:composedCharacters() do print(i, j, s:sub(i,j)) end\n     ~~~",
        "notes" : [
          " * Example usage:",
          "",
          "     ~~~",
          "     s = hs.text.utf16.new(\"abc🙂123\") .. hs.text.utf16.char(0x073, 0x0323, 0x0307) .. \"xyz\"",
          "     for i,j in s:composedCharacters() do print(i, j, s:sub(i,j)) end",
          "     ~~~"
        ],
        "signature" : "hs.text.utf16:composedCharacters() -> iteratorFunction",
        "type" : "Method",
        "returns" : [
          " * an iterator function which can be used with the lua `for` command as an iterator.",
          ""
        ],
        "def" : "hs.text.utf16:composedCharacters() -> iteratorFunction",
        "parameters" : [

        ]
      },
      {
        "desc" : "Compare the utf16TextObject to a string or another utf16TextObject and return the order",
        "stripped_doc" : [
          "Compare the utf16TextObject to a string or another utf16TextObject and return the order",
          "",
          "Paramters:",
          " * `text`    - a lua string or another utf16TextObject specifying the value to compare this object to",
          " * `options` - an optional integer or table of integers and strings corresponding to values in the [hs.text.utf16.compareOptions](#compareOptions) constant.",
          "   * if `options` is an integer, it should a combination of 1 or more of the numeric values in the [hs.text.utf16.compareOptions](#compareOptions) constant logically OR'ed together (e.g. `hs.text.utf16.compareOptions.caseInsensitive | hs.text.utf16.compareOptions.numeric`)",
          "   * if `options` is a table, each element of the array table should be a number value from the [hs.text.utf16.compareOptions](#compareOptions) constant or a string matching one of the constant's keys. This method will logically OR the appropriate values together for you (e.g. `{\"caseInsensitive\", \"numeric\"}`)",
          " * `locale`  - an optional string, booleam, or nil value specifying the locale to use when comparing.",
          "   * if this parameter is ommitted, is an explicit `nil` or is the boolean value `false`, the system locale is used",
          "   * if this parameter is a boolean value of `true`, the users current locale is used",
          "   * if this paramter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)",
          ""
        ],
        "name" : "compare",
        "doc" : "Compare the utf16TextObject to a string or another utf16TextObject and return the order\n\nParamters:\n * `text`    - a lua string or another utf16TextObject specifying the value to compare this object to\n * `options` - an optional integer or table of integers and strings corresponding to values in the [hs.text.utf16.compareOptions](#compareOptions) constant.\n   * if `options` is an integer, it should a combination of 1 or more of the numeric values in the [hs.text.utf16.compareOptions](#compareOptions) constant logically OR'ed together (e.g. `hs.text.utf16.compareOptions.caseInsensitive | hs.text.utf16.compareOptions.numeric`)\n   * if `options` is a table, each element of the array table should be a number value from the [hs.text.utf16.compareOptions](#compareOptions) constant or a string matching one of the constant's keys. This method will logically OR the appropriate values together for you (e.g. `{\"caseInsensitive\", \"numeric\"}`)\n * `locale`  - an optional string, booleam, or nil value specifying the locale to use when comparing.\n   * if this parameter is ommitted, is an explicit `nil` or is the boolean value `false`, the system locale is used\n   * if this parameter is a boolean value of `true`, the users current locale is used\n   * if this paramter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)\n\nReturns:\n * -1 if `text` is ordered *after* the object (i.e. they are presented in ascending order)\n *  0 if `text` is ordered the same as the object (i.e. they are equal or equivalent, given the options)\n *  1 if `text` is ordered *before* the object (i.e. they are presented in descending order)\n\nNotes:\n * The locale argument affects both equality and ordering algorithms. For example, in some locales, accented characters are ordered immediately after the base; other locales order them after “z”.\n * This method does *not* consider characters with composed character equivalences as identical or similar; if this is a concern, make sure to normalize the source and `text` as appropriate for your purposes with [hs.text.utf16.unicodeDecomposition](#unicodeDecomposition) or [hs.text.utf16.unicodeComposition](#unicodeComposition) before utilizing this method.",
        "notes" : [
          " * The locale argument affects both equality and ordering algorithms. For example, in some locales, accented characters are ordered immediately after the base; other locales order them after “z”.",
          " * This method does *not* consider characters with composed character equivalences as identical or similar; if this is a concern, make sure to normalize the source and `text` as appropriate for your purposes with [hs.text.utf16.unicodeDecomposition](#unicodeDecomposition) or [hs.text.utf16.unicodeComposition](#unicodeComposition) before utilizing this method."
        ],
        "signature" : "hs.text.utf16:compare(text, [options], [locale]) -> -1 | 0 | 1",
        "type" : "Method",
        "returns" : [
          " * -1 if `text` is ordered *after* the object (i.e. they are presented in ascending order)",
          " *  0 if `text` is ordered the same as the object (i.e. they are equal or equivalent, given the options)",
          " *  1 if `text` is ordered *before* the object (i.e. they are presented in descending order)",
          ""
        ],
        "def" : "hs.text.utf16:compare(text, [options], [locale]) -> -1 | 0 | 1",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create a copy of the utf16TextObject",
        "stripped_doc" : [
          "Create a copy of the utf16TextObject",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "copy",
        "doc" : "Create a copy of the utf16TextObject\n\nParamters:\n * None\n\nReturns:\n * a copy of the utf16TextObject as a new object",
        "notes" : [

        ],
        "signature" : "hs.text.utf16:copy() -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a copy of the utf16TextObject as a new object"
        ],
        "def" : "hs.text.utf16:copy() -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create a new utf16TextObject by applying the specified ICU transform",
        "stripped_doc" : [
          "Create a new utf16TextObject by applying the specified ICU transform",
          "",
          "Paramters:",
          " * `transform` - a string specifying the ICU transform(s) to apply",
          " * `inverse`   - an optional boolean, default `false`, specifying whether or not to apply the inverse (or reverse) of the specified transformation",
          ""
        ],
        "name" : "transform",
        "doc" : "Create a new utf16TextObject by applying the specified ICU transform\n\nParamters:\n * `transform` - a string specifying the ICU transform(s) to apply\n * `inverse`   - an optional boolean, default `false`, specifying whether or not to apply the inverse (or reverse) of the specified transformation\n\nReturns:\n * a new utf16TextObject containing the transformed data, or nil if the transform (or its inverse) could not be applied or was invalid\n\nNotes:\n * some built in transforms are identified in the constant table [hs.text.utf16.builtinTransforms](#builtInTransforms).\n * transform syntax is beyond the scope of this document; see http:\/\/userguide.icu-project.org\/transforms\/general for more information on creating your own transforms\n\n * Note that not all transforms have an inverse or are reversible.",
        "notes" : [
          " * some built in transforms are identified in the constant table [hs.text.utf16.builtinTransforms](#builtInTransforms).",
          " * transform syntax is beyond the scope of this document; see http:\/\/userguide.icu-project.org\/transforms\/general for more information on creating your own transforms",
          "",
          " * Note that not all transforms have an inverse or are reversible."
        ],
        "signature" : "hs.text.utf16:transform(transform, [inverse]) -> utf16TextObject | nil",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing the transformed data, or nil if the transform (or its inverse) could not be applied or was invalid",
          ""
        ],
        "def" : "hs.text.utf16:transform(transform, [inverse]) -> utf16TextObject | nil",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)D.",
        "stripped_doc" : [
          "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)D.",
          "",
          "Paramters:",
          " * `compatibilityMapping` - an optionabl boolean, default `false`, specifying whether compatibility mapping (true) should be used (Normalization Form KD) or canonical mapping (false) should be used (Normalization Form D) when normalizing the text.",
          ""
        ],
        "name" : "unicodeDecomposition",
        "doc" : "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)D.\n\nParamters:\n * `compatibilityMapping` - an optionabl boolean, default `false`, specifying whether compatibility mapping (true) should be used (Normalization Form KD) or canonical mapping (false) should be used (Normalization Form D) when normalizing the text.\n\nReturns:\n * a new utf16TextObject with the contents of the parent normalized using Unicode NormalizationForm (K)D.\n\nNotes:\n * At its most basic, normalization is useful when comparing strings which may have been composed differently (e.g. a single UTF16 character representing an accented `á` vs the visually equivalent composed character sequence of an `a` followed by U+0301) or use stylized versions of characters or numbers (e.g. `1` vs `①`), but need to be compared for their \"visual\" or \"intended\" equivalance.\n\n * see http:\/\/www.unicode.org\/reports\/tr15\/ for a more complete discussion of the various types of Unicode Normalization and the differences\/strengths\/weaknesses of each.\n\n * See also [hs.text.utf16:unicodeComposition](#unicodeComposition)",
        "notes" : [
          " * At its most basic, normalization is useful when comparing strings which may have been composed differently (e.g. a single UTF16 character representing an accented `á` vs the visually equivalent composed character sequence of an `a` followed by U+0301) or use stylized versions of characters or numbers (e.g. `1` vs `①`), but need to be compared for their \"visual\" or \"intended\" equivalance.",
          "",
          " * see http:\/\/www.unicode.org\/reports\/tr15\/ for a more complete discussion of the various types of Unicode Normalization and the differences\/strengths\/weaknesses of each.",
          "",
          " * See also [hs.text.utf16:unicodeComposition](#unicodeComposition)"
        ],
        "signature" : "hs.text.utf16:unicodeDecomposition([compatibilityMapping]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject with the contents of the parent normalized using Unicode NormalizationForm (K)D.",
          ""
        ],
        "def" : "hs.text.utf16:unicodeDecomposition([compatibilityMapping]) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)C.",
        "stripped_doc" : [
          "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)C.",
          "",
          "Paramters:",
          " * `compatibilityMapping` - an optionabl boolean, default `false`, specifying whether compatibility mapping (true) should be used (Normalization Form KC) or canonical mapping (false) should be used (Normalization Form C) when normalizing the text.",
          ""
        ],
        "name" : "unicodeComposition",
        "doc" : "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)C.\n\nParamters:\n * `compatibilityMapping` - an optionabl boolean, default `false`, specifying whether compatibility mapping (true) should be used (Normalization Form KC) or canonical mapping (false) should be used (Normalization Form C) when normalizing the text.\n\nReturns:\n * a new utf16TextObject with the contents of the parent normalized using Unicode NormalizationForm (K)C.\n\nNotes:\n * At its most basic, normalization is useful when comparing strings which may have been composed differently (e.g. a single UTF16 character representing an accented `á` vs the visually equivalent composed character sequence of an `a` followed by U+0301) or use stylized versions of characters or numbers (e.g. `1` vs `①`), but need to be compared for their \"visual\" or \"intended\" equivalance.\n\n * see http:\/\/www.unicode.org\/reports\/tr15\/ for a more complete discussion of the various types of Unicode Normalization and the differences\/strengths\/weaknesses of each.\n\n * See also [hs.text.utf16:unicodeDecomposition](#unicodeDecomposition)",
        "notes" : [
          " * At its most basic, normalization is useful when comparing strings which may have been composed differently (e.g. a single UTF16 character representing an accented `á` vs the visually equivalent composed character sequence of an `a` followed by U+0301) or use stylized versions of characters or numbers (e.g. `1` vs `①`), but need to be compared for their \"visual\" or \"intended\" equivalance.",
          "",
          " * see http:\/\/www.unicode.org\/reports\/tr15\/ for a more complete discussion of the various types of Unicode Normalization and the differences\/strengths\/weaknesses of each.",
          "",
          " * See also [hs.text.utf16:unicodeDecomposition](#unicodeDecomposition)"
        ],
        "signature" : "hs.text.utf16:unicodeComposition([compatibilityMapping]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject with the contents of the parent normalized using Unicode NormalizationForm (K)C.",
          ""
        ],
        "def" : "hs.text.utf16:unicodeComposition([compatibilityMapping]) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the UTF16 unit character codes for the range specified",
        "stripped_doc" : [
          "Returns the UTF16 unit character codes for the range specified",
          "",
          "Paramters:",
          " * `i` - an optional integer, default 1, specifying the starting indexof the UTF16 character to begin at; negative indicies are counted from the end of the string.",
          " * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.",
          ""
        ],
        "name" : "unitCharacter",
        "doc" : "Returns the UTF16 unit character codes for the range specified\n\nParamters:\n * `i` - an optional integer, default 1, specifying the starting indexof the UTF16 character to begin at; negative indicies are counted from the end of the string.\n * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.\n\nReturns:\n * zero or more integers representing the individual utf16 \"characters\" of the object within the range specified\n\nNotes:\n * this method returns the 16bit integer corresponding to the UTF16 \"character\" at the indicies specified. Surrogate pairs *are* treated as two separate \"characters\" by this method, so the initial or final character may be a broken surrogate -- see [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate).\n\n * this method follows the semantics of `utf8.codepoint` -- if a specified index is out of range, a lua error is generated.",
        "notes" : [
          " * this method returns the 16bit integer corresponding to the UTF16 \"character\" at the indicies specified. Surrogate pairs *are* treated as two separate \"characters\" by this method, so the initial or final character may be a broken surrogate -- see [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate).",
          "",
          " * this method follows the semantics of `utf8.codepoint` -- if a specified index is out of range, a lua error is generated."
        ],
        "signature" : "hs.text.utf16:unitCharacter([i], [j]) -> integer, ...",
        "type" : "Method",
        "returns" : [
          " * zero or more integers representing the individual utf16 \"characters\" of the object within the range specified",
          ""
        ],
        "def" : "hs.text.utf16:unitCharacter([i], [j]) -> integer, ...",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the starting and ending index of the specified range, adjusting for composed characters or surrogate pairs at the beginning and end of the range.",
        "stripped_doc" : [
          "Returns the starting and ending index of the specified range, adjusting for composed characters or surrogate pairs at the beginning and end of the range.",
          "",
          "Paramters:",
          " * `i` - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.",
          " * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.",
          ""
        ],
        "name" : "composedCharacterRange",
        "doc" : "Returns the starting and ending index of the specified range, adjusting for composed characters or surrogate pairs at the beginning and end of the range.\n\nParamters:\n * `i` - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.\n * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.\n\nReturns:\n * the `start` and `end` indicies for the range of characters specified by the initial range\n\nNotes:\n * if the unit character at index `i` specifies a low surrogate or is in the middle of a mulit-\"character\" composed character, `start` will be < `i`\n * likewise if `j` is in the middle of a multi-\"character\" composition or surrogate, `end` will be > `j`.\n\n * this method follows the semantics of `utf8.codepoint` -- if a specified index is out of range, a lua error is generated.",
        "notes" : [
          " * if the unit character at index `i` specifies a low surrogate or is in the middle of a mulit-\"character\" composed character, `start` will be < `i`",
          " * likewise if `j` is in the middle of a multi-\"character\" composition or surrogate, `end` will be > `j`.",
          "",
          " * this method follows the semantics of `utf8.codepoint` -- if a specified index is out of range, a lua error is generated."
        ],
        "signature" : "hs.text.utf16:composedCharacterRange([i], [j]) -> start, end",
        "type" : "Method",
        "returns" : [
          " * the `start` and `end` indicies for the range of characters specified by the initial range",
          ""
        ],
        "def" : "hs.text.utf16:composedCharacterRange([i], [j]) -> start, end",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns a copy of the utf16TextObject with all words capitalized.",
        "stripped_doc" : [
          "Returns a copy of the utf16TextObject with all words capitalized.",
          "",
          "Paramters:",
          " * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how to capitalize words.",
          "   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.",
          "   * if this parameter is the boolean `false` or `nil`, uses the system locale",
          "   * if this parameter is the boolean `true`, uses the users current locale",
          "   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)",
          ""
        ],
        "name" : "capitalize",
        "doc" : "Returns a copy of the utf16TextObject with all words capitalized.\n\nParamters:\n * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how to capitalize words.\n   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.\n   * if this parameter is the boolean `false` or `nil`, uses the system locale\n   * if this parameter is the boolean `true`, uses the users current locale\n   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)\n\nReturns:\n * a new utf16TextObject containing the capitalized version of the source\n\nNotes:\n * For the purposes of this methif, a capitalized string is a string with the first character in each word changed to its corresponding uppercase value, and all remaining characters set to their corresponding lowercase values. A word is any sequence of characters delimited by spaces, tabs, or line terminators. Some common word delimiting punctuation isn’t considered, so this property may not generally produce the desired results for multiword strings.",
        "notes" : [
          " * For the purposes of this methif, a capitalized string is a string with the first character in each word changed to its corresponding uppercase value, and all remaining characters set to their corresponding lowercase values. A word is any sequence of characters delimited by spaces, tabs, or line terminators. Some common word delimiting punctuation isn’t considered, so this property may not generally produce the desired results for multiword strings."
        ],
        "signature" : "hs.text.utf16:capitalize([locale]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing the capitalized version of the source",
          ""
        ],
        "def" : "hs.text.utf16:capitalize([locale]) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns a copy of the utf16TextObject with an uppercase representation of the source.",
        "stripped_doc" : [
          "Returns a copy of the utf16TextObject with an uppercase representation of the source.",
          "",
          "Paramters:",
          " * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how change case.",
          "   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.",
          "   * if this parameter is the boolean `false` or `nil`, uses the system locale",
          "   * if this parameter is the boolean `true`, uses the users current locale",
          "   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)",
          ""
        ],
        "name" : "upper",
        "doc" : "Returns a copy of the utf16TextObject with an uppercase representation of the source.\n\nParamters:\n * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how change case.\n   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.\n   * if this parameter is the boolean `false` or `nil`, uses the system locale\n   * if this parameter is the boolean `true`, uses the users current locale\n   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)\n\nReturns:\n * a new utf16TextObject containing an uppercase representation of the source.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.upper`\n * Case transformations aren’t guaranteed to be symmetrical or to produce strings of the same lengths as the originals.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.upper`",
          " * Case transformations aren’t guaranteed to be symmetrical or to produce strings of the same lengths as the originals."
        ],
        "signature" : "hs.text.utf16:upper([locale]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing an uppercase representation of the source.",
          ""
        ],
        "def" : "hs.text.utf16:upper([locale]) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns a copy of the utf16TextObject with an lowercase representation of the source.",
        "stripped_doc" : [
          "Returns a copy of the utf16TextObject with an lowercase representation of the source.",
          "",
          "Paramters:",
          " * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how change case.",
          "   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.",
          "   * if this parameter is the boolean `false` or `nil`, uses the system locale",
          "   * if this parameter is the boolean `true`, uses the users current locale",
          "   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)",
          ""
        ],
        "name" : "lower",
        "doc" : "Returns a copy of the utf16TextObject with an lowercase representation of the source.\n\nParamters:\n * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how change case.\n   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.\n   * if this parameter is the boolean `false` or `nil`, uses the system locale\n   * if this parameter is the boolean `true`, uses the users current locale\n   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)\n\nReturns:\n * a new utf16TextObject containing an lowercase representation of the source.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.lower`\n * Case transformations aren’t guaranteed to be symmetrical or to produce strings of the same lengths as the originals.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.lower`",
          " * Case transformations aren’t guaranteed to be symmetrical or to produce strings of the same lengths as the originals."
        ],
        "signature" : "hs.text.utf16:lower([locale]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing an lowercase representation of the source.",
          ""
        ],
        "def" : "hs.text.utf16:lower([locale]) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the length in UTF16 characters in the object",
        "stripped_doc" : [
          "Returns the length in UTF16 characters in the object",
          ""
        ],
        "name" : "len",
        "doc" : "Returns the length in UTF16 characters in the object\n\nParameters:\n * None\n\nReturns:\n * the number of UTF16 characterss in the object\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.len`\n * Composed character sequences and surrogate pairs are made up of multiple UTF16 \"characters\"; see also [hs.text.utf16:characterCount](#characterCount) wihch offers more options.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.len`",
          " * Composed character sequences and surrogate pairs are made up of multiple UTF16 \"characters\"; see also [hs.text.utf16:characterCount](#characterCount) wihch offers more options."
        ],
        "signature" : "hs.text.utf16:len() -> integer",
        "type" : "Method",
        "returns" : [
          " * the number of UTF16 characterss in the object",
          ""
        ],
        "def" : "hs.text.utf16:len() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a new utf16TextObject containing a substring of the source object",
        "stripped_doc" : [
          "Returns a new utf16TextObject containing a substring of the source object",
          ""
        ],
        "name" : "sub",
        "doc" : "Returns a new utf16TextObject containing a substring of the source object\n\nParameters:\n * `i` - an integer specifying the starting index of the substring; negative indicies are counted from the end of the string.\n * `j` - an optional integer, default -1, specifying the end of the substring; negative indicies are counted from the end of the string.\n\nReturns:\n * a new utf16TextObject containing a substring of the source object as delimited by the indicies `i` and `j`\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.sub`\n   * In particular, `hs.text.utf16:sub(1, j)` will return the prefix of the source with a length of `j`, and `hs.text.utf16:sub(-i)` returns the suffix of the source with a length of `i`.\n\n * This method uses the specific indicies provided, which could result in a broken surrogate or composed character sequence at the begining or end of the substring. If this is a concern, use [hs.text.utf16:composedCharacterRange](#composedCharacterRange) to adjust the range values before invoking this method.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.sub`",
          "   * In particular, `hs.text.utf16:sub(1, j)` will return the prefix of the source with a length of `j`, and `hs.text.utf16:sub(-i)` returns the suffix of the source with a length of `i`.",
          "",
          " * This method uses the specific indicies provided, which could result in a broken surrogate or composed character sequence at the begining or end of the substring. If this is a concern, use [hs.text.utf16:composedCharacterRange](#composedCharacterRange) to adjust the range values before invoking this method."
        ],
        "signature" : "hs.text.utf16:sub([i], [j]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing a substring of the source object as delimited by the indicies `i` and `j`",
          ""
        ],
        "def" : "hs.text.utf16:sub([i], [j]) -> utf16TextObject",
        "parameters" : [
          " * `i` - an integer specifying the starting index of the substring; negative indicies are counted from the end of the string.",
          " * `j` - an optional integer, default -1, specifying the end of the substring; negative indicies are counted from the end of the string.",
          ""
        ]
      },
      {
        "desc" : "Returns a new utf16TextObject with the characters reveresed.",
        "stripped_doc" : [
          "Returns a new utf16TextObject with the characters reveresed.",
          ""
        ],
        "name" : "reverse",
        "doc" : "Returns a new utf16TextObject with the characters reveresed.\n\nParameters:\n * None\n\nReturns:\n * a new utf16TextObject with the characters reveresed\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.reverse`\n * Surrogate pairs and composed character sequences are maintained, so the reversed object will be composed of valid UTF16 sequences (assuming, of course, that the original object was composed of valid UTF16 sequences)",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.reverse`",
          " * Surrogate pairs and composed character sequences are maintained, so the reversed object will be composed of valid UTF16 sequences (assuming, of course, that the original object was composed of valid UTF16 sequences)"
        ],
        "signature" : "hs.text.utf16:reverse() -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject with the characters reveresed",
          ""
        ],
        "def" : "hs.text.utf16:reverse() -> utf16TextObject",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Looks for the first match of a pattern within the utf16TextObject and returns it",
        "stripped_doc" : [
          "Looks for the first match of a pattern within the utf16TextObject and returns it",
          "",
          "Paramters:",
          " * `pattern` - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.",
          " * `i`       - an optional integer, default 1, specifying the index of the utf16TextObject where the search for the pattern should begin; negative indicies are counted from the end of the object.",
          ""
        ],
        "name" : "match",
        "doc" : "Looks for the first match of a pattern within the utf16TextObject and returns it\n\nParamters:\n * `pattern` - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.\n * `i`       - an optional integer, default 1, specifying the index of the utf16TextObject where the search for the pattern should begin; negative indicies are counted from the end of the object.\n\nReturns:\n * If a match is found and the pattern specifies captures, returns a new utf16TextObjects for each capture; if no captures are specified, returns the entire match as a new utf16TextObject. If no matche is found, returns nil.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.match` with one important caveat:\n   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.\n   * Again, ***Lua pattern matching syntax will not work with this method.***",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.match` with one important caveat:",
          "   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.",
          "   * Again, ***Lua pattern matching syntax will not work with this method.***"
        ],
        "signature" : "hs.text.utf16:match(pattern, [i]) -> match(es) | nil",
        "type" : "Method",
        "returns" : [
          " * If a match is found and the pattern specifies captures, returns a new utf16TextObjects for each capture; if no captures are specified, returns the entire match as a new utf16TextObject. If no matche is found, returns nil.",
          ""
        ],
        "def" : "hs.text.utf16:match(pattern, [i]) -> match(es) | nil",
        "parameters" : [

        ]
      },
      {
        "desc" : "Looks for the first match of a pattern within the utf16TextObject and returns the indicies of the match",
        "stripped_doc" : [
          "Looks for the first match of a pattern within the utf16TextObject and returns the indicies of the match",
          "",
          "Paramters:",
          " * `pattern` - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.",
          " * `i`       - an optional integer, default 1, specifying the index of the utf16TextObject where the search for the pattern should begin; negative indicies are counted from the end of the object.",
          " * `plain`   - an optional boolean, default `false`, specifying that the pattern should be matched *exactly* (true) instead of treated as a regular expression (false).",
          ""
        ],
        "name" : "find",
        "doc" : "Looks for the first match of a pattern within the utf16TextObject and returns the indicies of the match\n\nParamters:\n * `pattern` - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.\n * `i`       - an optional integer, default 1, specifying the index of the utf16TextObject where the search for the pattern should begin; negative indicies are counted from the end of the object.\n * `plain`   - an optional boolean, default `false`, specifying that the pattern should be matched *exactly* (true) instead of treated as a regular expression (false).\n\nReturns:\n * If a match is found, returns the starting and ending indicies of the match (as integers); if captures are specified in the pattern, also returns a new utf16TextObjects for each capture after the indicies. If no match is found, returns nil.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.find` with one important caveat:\n   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.\n   * Again, ***Lua pattern matching syntax will not work with this method.***",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.find` with one important caveat:",
          "   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.",
          "   * Again, ***Lua pattern matching syntax will not work with this method.***"
        ],
        "signature" : "hs.text.utf16:find(pattern, [i], [plain]) -> start, end, [captures...] | nil",
        "type" : "Method",
        "returns" : [
          " * If a match is found, returns the starting and ending indicies of the match (as integers); if captures are specified in the pattern, also returns a new utf16TextObjects for each capture after the indicies. If no match is found, returns nil.",
          ""
        ],
        "def" : "hs.text.utf16:find(pattern, [i], [plain]) -> start, end, [captures...] | nil",
        "parameters" : [

        ]
      },
      {
        "desc" : "Return a gopy of the object with occurances of the pattern replaced; global substitution.",
        "stripped_doc" : [
          "Return a gopy of the object with occurances of the pattern replaced; global substitution.",
          "",
          "Paramters:",
          " * `pattern`     - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.",
          " * `replacement` - a lua string, utf16TextObject, table, or function which specifies replacement(s) for pattern matches.",
          "   * if `replacement` is a string or utf16TextObject, then its value is used for replacement. Any sequence in the replacement of the form `$n` where `n` is an integer >= 0 will be replaced by the `n`th capture from the pattern (`$0` specifies the entire match). A `$` not followed by a number is treated as a literal `$`. To specify a literal `$` followed by a numeric digit, escape the dollar sign (e.g. `\\$1`)",
          "   * if `replacement` is a table, the table is queried for every match using the first capture (if captures are specified) or the entire match (if no captures are specified). Keys in the table must be lua strings or utf16TextObjects, and values must be lua strings, numbers, or utf16TextObjects. If no key matches the capture, no replacement of the match occurs.",
          "   * if `replacement` is a function, the function will be called with all of the captured substrings passed in as utf16TextObjects in order (or the entire match, if no captures are specified). The return value is used as the repacement of the match and must be `nil`, a lua string, a number, or a utf16TextObject. If the return value is `nil`, no replacement of the match occurs.",
          " * `n`           - an optional integer specifying the maximum number of replacements to perform. If this is not specified, all matches in the object will be replaced.",
          ""
        ],
        "name" : "gsub",
        "doc" : "Return a gopy of the object with occurances of the pattern replaced; global substitution.\n\nParamters:\n * `pattern`     - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.\n * `replacement` - a lua string, utf16TextObject, table, or function which specifies replacement(s) for pattern matches.\n   * if `replacement` is a string or utf16TextObject, then its value is used for replacement. Any sequence in the replacement of the form `$n` where `n` is an integer >= 0 will be replaced by the `n`th capture from the pattern (`$0` specifies the entire match). A `$` not followed by a number is treated as a literal `$`. To specify a literal `$` followed by a numeric digit, escape the dollar sign (e.g. `\\$1`)\n   * if `replacement` is a table, the table is queried for every match using the first capture (if captures are specified) or the entire match (if no captures are specified). Keys in the table must be lua strings or utf16TextObjects, and values must be lua strings, numbers, or utf16TextObjects. If no key matches the capture, no replacement of the match occurs.\n   * if `replacement` is a function, the function will be called with all of the captured substrings passed in as utf16TextObjects in order (or the entire match, if no captures are specified). The return value is used as the repacement of the match and must be `nil`, a lua string, a number, or a utf16TextObject. If the return value is `nil`, no replacement of the match occurs.\n * `n`           - an optional integer specifying the maximum number of replacements to perform. If this is not specified, all matches in the object will be replaced.\n\nReturns:\n * a new utf16TextObject with the substitutions specified, followed by an integer specifying the number of substitutions that occurred.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.gsub` with one important caveat:\n   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.\n   * Again, ***Lua pattern matching syntax will not work with this method.***\n\n * The following examples are from the Lua documentation for `string.gsub` modified with the proper syntax:\n\n     ~~~\n     x = hs.text.utf16.new(\"hello world\"):gsub(\"(\\\\w+)\", \"$1 $1\")\n     -- x will equal \"hello hello world world\"\n\n     -- note that if we use Lua's block quotes (e.g. `[[` and `]]`), then we don't have to escape the backslash:\n\n     x = hs.text.utf16.new(\"hello world\"):gsub([[\\w+]], \"$0 $0\", 1)\n     -- x will equal \"hello hello world\"\n\n     x = hs.text.utf16.new(\"hello world from Lua\"):gsub([[(\\w+)\\s*(\\w+)]], \"$2 $1\")\n     -- x will equal \"world hello Lua from\"\n\n     x = hs.text.utf16.new(\"home = $HOME, user = $USER\"):gsub([[\\$(\\w+)]], function(a) return os.getenv(tostring(a)) end)\n     -- x will equal \"home = \/home\/username, user = username\"\n\n     x = hs.text.utf16.new(\"4+5 = $return 4+5$\"):gsub([[\\$(.+)\\$]], function (s) return load(tostring(s))() end)\n     -- x will equal \"4+5 = 9\"\n\n     local t = {name=\"lua\", version=\"5.3\"}\n     x = hs.text.utf16.new(\"$name-$version.tar.gz\"):gsub([[\\$(\\w+)]], t)\n     -- x will equal \"lua-5.3.tar.gz\"\n     ~~~",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.gsub` with one important caveat:",
          "   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.",
          "   * Again, ***Lua pattern matching syntax will not work with this method.***",
          "",
          " * The following examples are from the Lua documentation for `string.gsub` modified with the proper syntax:",
          "",
          "     ~~~",
          "     x = hs.text.utf16.new(\"hello world\"):gsub(\"(\\\\w+)\", \"$1 $1\")",
          "     -- x will equal \"hello hello world world\"",
          "",
          "     -- note that if we use Lua's block quotes (e.g. `[[` and `]]`), then we don't have to escape the backslash:",
          "",
          "     x = hs.text.utf16.new(\"hello world\"):gsub([[\\w+]], \"$0 $0\", 1)",
          "     -- x will equal \"hello hello world\"",
          "",
          "     x = hs.text.utf16.new(\"hello world from Lua\"):gsub([[(\\w+)\\s*(\\w+)]], \"$2 $1\")",
          "     -- x will equal \"world hello Lua from\"",
          "",
          "     x = hs.text.utf16.new(\"home = $HOME, user = $USER\"):gsub([[\\$(\\w+)]], function(a) return os.getenv(tostring(a)) end)",
          "     -- x will equal \"home = \/home\/username, user = username\"",
          "",
          "     x = hs.text.utf16.new(\"4+5 = $return 4+5$\"):gsub([[\\$(.+)\\$]], function (s) return load(tostring(s))() end)",
          "     -- x will equal \"4+5 = 9\"",
          "",
          "     local t = {name=\"lua\", version=\"5.3\"}",
          "     x = hs.text.utf16.new(\"$name-$version.tar.gz\"):gsub([[\\$(\\w+)]], t)",
          "     -- x will equal \"lua-5.3.tar.gz\"",
          "     ~~~"
        ],
        "signature" : "hs.text.utf16:gsub(pattern, replacement, [n]) -> utf16TextObject, count",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject with the substitutions specified, followed by an integer specifying the number of substitutions that occurred.",
          ""
        ],
        "def" : "hs.text.utf16:gsub(pattern, replacement, [n]) -> utf16TextObject, count",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the Unicode Codepoints for all characters in the utf16TextObject between the specified indicies.",
        "stripped_doc" : [
          "Returns the Unicode Codepoints for all characters in the utf16TextObject between the specified indicies.",
          "",
          "Paramters:",
          " * `i` - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.",
          " * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.",
          ""
        ],
        "name" : "codpoint",
        "doc" : "Returns the Unicode Codepoints for all characters in the utf16TextObject between the specified indicies.\n\nParamters:\n * `i` - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.\n * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.\n\nReturns:\n * zero or more integers representing the Unicode Codepoints of the UTF16 \"character\" at the indicies specified.\n\nNotes:\n * This method is the utf16 equivalent of lua's `utf8.codepoint` and follows the same semantics -- if a specified index is out of range, a lua error is generated.\n * This method differs from [hs.text.uf16:unitCharacter](#unitCharacter) in that surrogate pairs will result in a single codepoint between U+010000 to U+10FFFF instead of two separate UTF16 characters.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `utf8.codepoint` and follows the same semantics -- if a specified index is out of range, a lua error is generated.",
          " * This method differs from [hs.text.uf16:unitCharacter](#unitCharacter) in that surrogate pairs will result in a single codepoint between U+010000 to U+10FFFF instead of two separate UTF16 characters."
        ],
        "signature" : "hs.text.utf16:codpoint([i], [j]) -> integer, ...",
        "type" : "Method",
        "returns" : [
          " * zero or more integers representing the Unicode Codepoints of the UTF16 \"character\" at the indicies specified.",
          ""
        ],
        "def" : "hs.text.utf16:codpoint([i], [j]) -> integer, ...",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the number of UTF16 characters in the utf16TextObject between the specified indicies.",
        "stripped_doc" : [
          "Returns the number of UTF16 characters in the utf16TextObject between the specified indicies.",
          "",
          "Paramters:",
          " * `composedCharacters` - an optional boolean, default `false`, specifying whether or not composed character sequences should be treated as a single character (true) or count for as many individual UTF16 \"characters\" as are actually used to specify the sequence (false).",
          " * `i`                  - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.",
          " * `j`                  - an optional integer, default -1, specifying the end of the range; negative indicies are counted from the end of the string.",
          ""
        ],
        "name" : "characterCount",
        "doc" : "Returns the number of UTF16 characters in the utf16TextObject between the specified indicies.\n\nParamters:\n * `composedCharacters` - an optional boolean, default `false`, specifying whether or not composed character sequences should be treated as a single character (true) or count for as many individual UTF16 \"characters\" as are actually used to specify the sequence (false).\n * `i`                  - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.\n * `j`                  - an optional integer, default -1, specifying the end of the range; negative indicies are counted from the end of the string.\n\nReturns:\n * if no invalid sequences are found (see next), returns the number of Unicode characters in the range specified.\n * if an invalid sequence is found (specifically an isolated low or high surrogate or compoased character sequence that starts or ends outside of the specified range when `composedCharacters` is `true`, returns `nil` and the index position of the first invalid UTF16 character.\n\nNotes:\n * This method is similar to lua's `utf8.len` and follows the same semantics -- if a specified index is out of range, a lua error is generated.\n * This method differs from [hs.text.uf16:len](#len) in that surrogate pairs count as one character and composed characters can optionally be considered a single character as well.",
        "notes" : [
          " * This method is similar to lua's `utf8.len` and follows the same semantics -- if a specified index is out of range, a lua error is generated.",
          " * This method differs from [hs.text.uf16:len](#len) in that surrogate pairs count as one character and composed characters can optionally be considered a single character as well."
        ],
        "signature" : "hs.text.utf16:characterCount([composedCharacters], [i], [j]) -> integer | nil, integer",
        "type" : "Method",
        "returns" : [
          " * if no invalid sequences are found (see next), returns the number of Unicode characters in the range specified.",
          " * if an invalid sequence is found (specifically an isolated low or high surrogate or compoased character sequence that starts or ends outside of the specified range when `composedCharacters` is `true`, returns `nil` and the index position of the first invalid UTF16 character.",
          ""
        ],
        "def" : "hs.text.utf16:characterCount([composedCharacters], [i], [j]) -> integer | nil, integer",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the position (in UTF16 characters) where the encoding of the `n`th character of the utf16TextObject begins.",
        "stripped_doc" : [
          "Returns the position (in UTF16 characters) where the encoding of the `n`th character of the utf16TextObject begins.",
          "",
          "Paramters:",
          " * `composedCharacters` - an optional boolean, default `false` specifying whether or not composed character sequences should be considered as a single UTF16 character (true) or as the individual characters that make up the sequence (false).",
          " * `n`                  - an integer specifying the UTF16 character number to get the offset for, starting from position `i`. If `n` is negative, gets specifies the number of characters before position `i`.",
          " * `i`                  - an optional integer, default 1 when `n` is non-negative or [hs.text.utf16:len](#len) + 1 when `n` is negative, specifiying the starting character from which to count `n`.",
          ""
        ],
        "name" : "offset",
        "doc" : "Returns the position (in UTF16 characters) where the encoding of the `n`th character of the utf16TextObject begins.\n\nParamters:\n * `composedCharacters` - an optional boolean, default `false` specifying whether or not composed character sequences should be considered as a single UTF16 character (true) or as the individual characters that make up the sequence (false).\n * `n`                  - an integer specifying the UTF16 character number to get the offset for, starting from position `i`. If `n` is negative, gets specifies the number of characters before position `i`.\n * `i`                  - an optional integer, default 1 when `n` is non-negative or [hs.text.utf16:len](#len) + 1 when `n` is negative, specifiying the starting character from which to count `n`.\n\nReturns:\n * the index of the utf16TextObject where the `n`th character begins or nil if no such character exists. As a special case when `n` is 0, returns the offset of the start of the character that contains the `i`th UTF16 character of the utf16Text obejct.\n\nNotes:\n * This method is the utf16 equivalent of lua's `utf8.offset`.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `utf8.offset`."
        ],
        "signature" : "hs.text.utf16:offset([composedCharacters], n, [i]) -> integer | nil",
        "type" : "Method",
        "returns" : [
          " * the index of the utf16TextObject where the `n`th character begins or nil if no such character exists. As a special case when `n` is 0, returns the offset of the start of the character that contains the `i`th UTF16 character of the utf16Text obejct.",
          ""
        ],
        "def" : "hs.text.utf16:offset([composedCharacters], n, [i]) -> integer | nil",
        "parameters" : [

        ]
      }
    ],
    "Command" : [

    ],
    "items" : [
      {
        "desc" : "Built in transormations which can be used with [hs.text.utf16:transform](#transform).",
        "stripped_doc" : [
          "Built in transormations which can be used with [hs.text.utf16:transform](#transform).",
          "",
          "This table contains key-value pairs identifying built in transforms provided by the macOS Objective-C runtime environment for use with [hs.text.utf16:transform](#transform). See http:\/\/userguide.icu-project.org\/transforms\/general for a more complete discussion on how to specify your own transformations.",
          "",
          "The built in transformations are:",
          " * `fullwidthToHalfwidth` - transform full-width CJK characters to their half-width forms. e.g. “マット” transforms to “ﾏｯﾄ”. This transformation is reversible.",
          " * `hiraganaToKatakana`   - transliterate the text from Hiragana script to Katakana script. e.g. “ひらがな” transliterates to “カタカナ”. This transformation is reversible.",
          " * `latinToArabic`        - transliterate the text from Latin script to Arabic script. e.g. “ạlʿarabīẗ‎” transliterates to “العَرَبِية”. This transformation is reversible.",
          " * `latinToCyrillic`      - transliterate the text from Latin script to Cyrillic script. e.g. “kirillica” transliterates to “кириллица”. This transformation is reversible.",
          " * `latinToGreek`         - transliterate the text from Latin script to Greek script. e.g. “Ellēnikó alphábēto‎” transliterates to “Ελληνικό αλφάβητο”. This transformation is reversible.",
          " * `latinToHangul`        - transliterate the text from Latin script to Hangul script. e.g. “hangul” transliterates to “한굴”. This transformation is reversible.",
          " * `latinToHebrew`        - transliterate the text from Latin script to Hebrew script. e.g. “ʻbryţ” transliterates to “עברית”. This transformation is reversible.",
          " * `latinToHiragana`      - transliterate the text from Latin script to Hiragana script. e.g. “hiragana” transliterates to “ひらがな”. This transformation is reversible.",
          " * `latinToKatakana`      - transliterate the text from Latin script to Katakana script. e.g. “katakana” transliterates to “カタカナ”. This transformation is reversible.",
          " * `latinToThai`          - transliterate the text from Latin script to Thai script. e.g. “p̣hās̄ʹā thịy” transliterates to “ภาษาไทย”. This transformation is reversible.",
          " * `mandarinToLatin`      - transliterate the text from Han script to Latin script. e.g. “hàn zì” transliterates to “汉字”.",
          " * `stripCombiningMarks`  - removes all combining marks (including diacritics and accents) from the text",
          " * `stripDiacritics`      - removes all diacritic marks from the text",
          " * `toLatin`              - transliterate all text possible to Latin script. Ideographs are transliterated as Mandarin Chinese.",
          " * `toUnicodeName`        - converts characters other than printable ASCII to their Unicode character name in braces. e.g. “🐶🐮” transforms to \"\\N{DOG FACE}\\N{COW FACE}\". This transformation is reversible.",
          " * `toXMLHex`             - transliterate characters other than printable ASCII to XML\/HTML numeric entities. e.g. “❦” transforms to “&#x2766;”. This transformation is reversible."
        ],
        "name" : "builtInTransforms",
        "doc" : "Built in transormations which can be used with [hs.text.utf16:transform](#transform).\n\nThis table contains key-value pairs identifying built in transforms provided by the macOS Objective-C runtime environment for use with [hs.text.utf16:transform](#transform). See http:\/\/userguide.icu-project.org\/transforms\/general for a more complete discussion on how to specify your own transformations.\n\nThe built in transformations are:\n * `fullwidthToHalfwidth` - transform full-width CJK characters to their half-width forms. e.g. “マット” transforms to “ﾏｯﾄ”. This transformation is reversible.\n * `hiraganaToKatakana`   - transliterate the text from Hiragana script to Katakana script. e.g. “ひらがな” transliterates to “カタカナ”. This transformation is reversible.\n * `latinToArabic`        - transliterate the text from Latin script to Arabic script. e.g. “ạlʿarabīẗ‎” transliterates to “العَرَبِية”. This transformation is reversible.\n * `latinToCyrillic`      - transliterate the text from Latin script to Cyrillic script. e.g. “kirillica” transliterates to “кириллица”. This transformation is reversible.\n * `latinToGreek`         - transliterate the text from Latin script to Greek script. e.g. “Ellēnikó alphábēto‎” transliterates to “Ελληνικό αλφάβητο”. This transformation is reversible.\n * `latinToHangul`        - transliterate the text from Latin script to Hangul script. e.g. “hangul” transliterates to “한굴”. This transformation is reversible.\n * `latinToHebrew`        - transliterate the text from Latin script to Hebrew script. e.g. “ʻbryţ” transliterates to “עברית”. This transformation is reversible.\n * `latinToHiragana`      - transliterate the text from Latin script to Hiragana script. e.g. “hiragana” transliterates to “ひらがな”. This transformation is reversible.\n * `latinToKatakana`      - transliterate the text from Latin script to Katakana script. e.g. “katakana” transliterates to “カタカナ”. This transformation is reversible.\n * `latinToThai`          - transliterate the text from Latin script to Thai script. e.g. “p̣hās̄ʹā thịy” transliterates to “ภาษาไทย”. This transformation is reversible.\n * `mandarinToLatin`      - transliterate the text from Han script to Latin script. e.g. “hàn zì” transliterates to “汉字”.\n * `stripCombiningMarks`  - removes all combining marks (including diacritics and accents) from the text\n * `stripDiacritics`      - removes all diacritic marks from the text\n * `toLatin`              - transliterate all text possible to Latin script. Ideographs are transliterated as Mandarin Chinese.\n * `toUnicodeName`        - converts characters other than printable ASCII to their Unicode character name in braces. e.g. “🐶🐮” transforms to \"\\N{DOG FACE}\\N{COW FACE}\". This transformation is reversible.\n * `toXMLHex`             - transliterate characters other than printable ASCII to XML\/HTML numeric entities. e.g. “❦” transforms to “&#x2766;”. This transformation is reversible.",
        "notes" : [

        ],
        "signature" : "hs.text.utf16.builtInTransforms",
        "type" : "Constant",
        "returns" : [

        ],
        "def" : "hs.text.utf16.builtInTransforms",
        "parameters" : [

        ]
      },
      {
        "desc" : "A table containing the modifier options for use with the [hs.text.utf16:compare](#compare) method.",
        "stripped_doc" : [
          "A table containing the modifier options for use with the [hs.text.utf16:compare](#compare) method.",
          "",
          "This table contains key-value pairs specifying the numeric values which should be logically OR'ed together (or listed individually in a table as either the integer or the key name) for use with the [hs.text.utf16:compare](#compare) method.",
          "",
          "Valid options are as follows:",
          " * `caseInsensitive`      - sort order is case-insensitive",
          " * `diacriticInsensitive` - ignores diacritic marks",
          " * `finderFileOrder`      - sort order matches what the Finder uses for the locale specified. This is a convienence combination which is equivalent to `{ \"caseInsensitive\", \"numeric\", \"widthInsensitive\", \"forcedOrdering\" }`.",
          " * `forcedOrdering`       - comparisons are forced to return either -1 or 1 if the strings are equivalent but not strictly equal. (e.g.  “aaa” is greater than \"AAA\" if `caseInsensitive` is also set.)",
          " * `literal`              - exact character-by-character equivalence.",
          " * `numeric`              - numbers within the string are compared numerically. This only applies to actual numeric characters, not characters that would have meaning in a numeric representation such as a negative sign, a comma, or a decimal point.",
          " * `widthInsensitive`     - ignores width differences in characters that have full-width and half-width forms, common in East Asian character sets."
        ],
        "name" : "compareOptions",
        "doc" : "A table containing the modifier options for use with the [hs.text.utf16:compare](#compare) method.\n\nThis table contains key-value pairs specifying the numeric values which should be logically OR'ed together (or listed individually in a table as either the integer or the key name) for use with the [hs.text.utf16:compare](#compare) method.\n\nValid options are as follows:\n * `caseInsensitive`      - sort order is case-insensitive\n * `diacriticInsensitive` - ignores diacritic marks\n * `finderFileOrder`      - sort order matches what the Finder uses for the locale specified. This is a convienence combination which is equivalent to `{ \"caseInsensitive\", \"numeric\", \"widthInsensitive\", \"forcedOrdering\" }`.\n * `forcedOrdering`       - comparisons are forced to return either -1 or 1 if the strings are equivalent but not strictly equal. (e.g.  “aaa” is greater than \"AAA\" if `caseInsensitive` is also set.)\n * `literal`              - exact character-by-character equivalence.\n * `numeric`              - numbers within the string are compared numerically. This only applies to actual numeric characters, not characters that would have meaning in a numeric representation such as a negative sign, a comma, or a decimal point.\n * `widthInsensitive`     - ignores width differences in characters that have full-width and half-width forms, common in East Asian character sets.",
        "notes" : [

        ],
        "signature" : "hs.text.utf16.compareOptions",
        "type" : "Constant",
        "returns" : [

        ],
        "def" : "hs.text.utf16.compareOptions",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the Unicode Codepoint number for the specified high and low surrogate pair",
        "stripped_doc" : [
          "Returns the Unicode Codepoint number for the specified high and low surrogate pair",
          ""
        ],
        "name" : "codepointForSurrogatePair",
        "doc" : "Returns the Unicode Codepoint number for the specified high and low surrogate pair\n\nParameters:\n * `high` - an integer specifying the UTF16 \"character\" specifying the High Surrogate\n * `low` - an integer specifying the UTF16 \"character\" specifying the Low Surrogate\n\nReturns:\n * if the `high` and `low` values specify a valid UTF16 surrogate pair, returns an integer specifying the codepoint for the pair; otherwise returns nil\n\nNotes:\n * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.\n\n* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate)",
        "notes" : [
          " * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.",
          "",
          "* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate)"
        ],
        "signature" : "hs.text.utf16.codepointForSurrogatePair(high, low) -> integer | nil",
        "type" : "Function",
        "returns" : [
          " * if the `high` and `low` values specify a valid UTF16 surrogate pair, returns an integer specifying the codepoint for the pair; otherwise returns nil",
          ""
        ],
        "def" : "hs.text.utf16.codepointForSurrogatePair(high, low) -> integer | nil",
        "parameters" : [
          " * `high` - an integer specifying the UTF16 \"character\" specifying the High Surrogate",
          " * `low` - an integer specifying the UTF16 \"character\" specifying the Low Surrogate",
          ""
        ]
      },
      {
        "desc" : "Returns whether or not the specified 16-bit UTF16 unit character is a High Surrogate",
        "stripped_doc" : [
          "Returns whether or not the specified 16-bit UTF16 unit character is a High Surrogate",
          ""
        ],
        "name" : "isHighSurrogate",
        "doc" : "Returns whether or not the specified 16-bit UTF16 unit character is a High Surrogate\n\nParameters:\n * `unitchar` - an integer specifying a single UTF16 character\n\nReturns:\n * a boolean specifying whether or not the single UTF16 character specified is a High Surrogate (true) or not (false).\n\nNotes:\n * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.\n   * A high surrogate is a single UTF16 \"character\" with an integer representation between 0xD800 and 0xDBFF inclusive\n   * A low surrogate is a single UTF16 \"character\" with an integer representation between 0xDC00 and 0xDFFF inclusive.\n   * It is an encoding error if a high surrogate is not immediately followed by a low surrogate or for either surrogate type to be found by itself or surrounded by UTF16 characters outside of the surrogate pair ranges. However, most implementations silently ignore this and simply treat unpaired surrogates as unprintable (control characters) or equivalent to the Unicode Replacement character (U+FFFD).\n\n* See also [hs.text.utf16.isLowSurrogate](#isLowSurrogate)",
        "notes" : [
          " * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.",
          "   * A high surrogate is a single UTF16 \"character\" with an integer representation between 0xD800 and 0xDBFF inclusive",
          "   * A low surrogate is a single UTF16 \"character\" with an integer representation between 0xDC00 and 0xDFFF inclusive.",
          "   * It is an encoding error if a high surrogate is not immediately followed by a low surrogate or for either surrogate type to be found by itself or surrounded by UTF16 characters outside of the surrogate pair ranges. However, most implementations silently ignore this and simply treat unpaired surrogates as unprintable (control characters) or equivalent to the Unicode Replacement character (U+FFFD).",
          "",
          "* See also [hs.text.utf16.isLowSurrogate](#isLowSurrogate)"
        ],
        "signature" : "hs.text.utf16.isHighSurrogate(unitchar) -> boolean",
        "type" : "Function",
        "returns" : [
          " * a boolean specifying whether or not the single UTF16 character specified is a High Surrogate (true) or not (false).",
          ""
        ],
        "def" : "hs.text.utf16.isHighSurrogate(unitchar) -> boolean",
        "parameters" : [
          " * `unitchar` - an integer specifying a single UTF16 character",
          ""
        ]
      },
      {
        "desc" : "Returns whether or not the specified 16-bit UTF16 unit character is a Low Surrogate",
        "stripped_doc" : [
          "Returns whether or not the specified 16-bit UTF16 unit character is a Low Surrogate",
          ""
        ],
        "name" : "isLowSurrogate",
        "doc" : "Returns whether or not the specified 16-bit UTF16 unit character is a Low Surrogate\n\nParameters:\n * `unitchar` - an integer specifying a single UTF16 character\n\nReturns:\n * a boolean specifying whether or not the single UTF16 character specified is a Low Surrogate (true) or not (false).\n\nNotes:\n * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.\n   * A high surrogate is a single UTF16 \"character\" with an integer representation between 0xD800 and 0xDBFF inclusive\n   * A low surrogate is a single UTF16 \"character\" with an integer representation between 0xDC00 and 0xDFFF inclusive.\n   * It is an encoding error if a high surrogate is not immediately followed by a low surrogate or for either surrogate type to be found by itself or surrounded by UTF16 characters outside of the surrogate pair ranges. However, most implementations silently ignore this and simply treat unpaired surrogates as unprintable (control characters) or equivalent to the Unicode Replacement character (U+FFFD).\n\n* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate)",
        "notes" : [
          " * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.",
          "   * A high surrogate is a single UTF16 \"character\" with an integer representation between 0xD800 and 0xDBFF inclusive",
          "   * A low surrogate is a single UTF16 \"character\" with an integer representation between 0xDC00 and 0xDFFF inclusive.",
          "   * It is an encoding error if a high surrogate is not immediately followed by a low surrogate or for either surrogate type to be found by itself or surrounded by UTF16 characters outside of the surrogate pair ranges. However, most implementations silently ignore this and simply treat unpaired surrogates as unprintable (control characters) or equivalent to the Unicode Replacement character (U+FFFD).",
          "",
          "* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate)"
        ],
        "signature" : "hs.text.utf16.isLowSurrogate(unitchar) -> boolean",
        "type" : "Function",
        "returns" : [
          " * a boolean specifying whether or not the single UTF16 character specified is a Low Surrogate (true) or not (false).",
          ""
        ],
        "def" : "hs.text.utf16.isLowSurrogate(unitchar) -> boolean",
        "parameters" : [
          " * `unitchar` - an integer specifying a single UTF16 character",
          ""
        ]
      },
      {
        "desc" : "Returns the surrogate pair for the specified Unicode Codepoint",
        "stripped_doc" : [
          "Returns the surrogate pair for the specified Unicode Codepoint",
          ""
        ],
        "name" : "surrogatePairForCodepoint",
        "doc" : "Returns the surrogate pair for the specified Unicode Codepoint\n\nParameters:\n * `codepoint` - an integer specifying the Unicode codepoint\n\nReturns:\n * if the codepoint is between U+010000 to U+10FFFF, returns the UTF16 surrogate pair for the character as 2 integers; otherwise returns nil\n\nNotes:\n * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.\n\n* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate)",
        "notes" : [
          " * UTF16 represents Unicode characters in the range of U+010000 to U+10FFFF as a pair of UTF16 characters known as a surrogate pair. A surrogate pair is made up of a High Surrogate and a Low Surrogate.",
          "",
          "* See also [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate)"
        ],
        "signature" : "hs.text.utf16.surrogatePairForCodepoint(codepoint) -> integer, integer | nil",
        "type" : "Function",
        "returns" : [
          " * if the codepoint is between U+010000 to U+10FFFF, returns the UTF16 surrogate pair for the character as 2 integers; otherwise returns nil",
          ""
        ],
        "def" : "hs.text.utf16.surrogatePairForCodepoint(codepoint) -> integer, integer | nil",
        "parameters" : [
          " * `codepoint` - an integer specifying the Unicode codepoint",
          ""
        ]
      },
      {
        "desc" : "Create a new utf16TextObject from the Unicode Codepoints specified.",
        "stripped_doc" : [
          "Create a new utf16TextObject from the Unicode Codepoints specified.",
          "",
          "Paramters:",
          " * zero or more Unicode Codepoints specified as integers",
          ""
        ],
        "name" : "char",
        "doc" : "Create a new utf16TextObject from the Unicode Codepoints specified.\n\nParamters:\n * zero or more Unicode Codepoints specified as integers\n\nReturns:\n * a new utf16TextObject\n\nNotes:\n * Unicode Codepoints are often written as `U+xxxx` where `xxxx` is between 4 and 6 hexadecimal digits. Lua can automatically convert hexadecimal numbers to integers, so replace the `U+` with `0x` when specifying codepoints in this format.",
        "notes" : [
          " * Unicode Codepoints are often written as `U+xxxx` where `xxxx` is between 4 and 6 hexadecimal digits. Lua can automatically convert hexadecimal numbers to integers, so replace the `U+` with `0x` when specifying codepoints in this format."
        ],
        "signature" : "hs.text.utf16.char(...) -> utf16TextObject",
        "type" : "Constructor",
        "returns" : [
          " * a new utf16TextObject",
          ""
        ],
        "def" : "hs.text.utf16.char(...) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create a new utf16TextObject from a lua string or `hs.text` object",
        "stripped_doc" : [
          "Create a new utf16TextObject from a lua string or `hs.text` object",
          ""
        ],
        "name" : "new",
        "doc" : "Create a new utf16TextObject from a lua string or `hs.text` object\n\nParameters:\n * `text`  - a lua string or `hs.text` object specifying the text for the new utf16TextObject\n * `lossy` - an optional boolean, default `false`, specifying whether or not characters can be removed or altered when converting the data to the UTF16 encoding.\n\nReturns:\n * a new utf16TextObject, or nil if the data could not be encoded as a utf16TextObject",
        "notes" : [

        ],
        "signature" : "hs.text.utf16.new(text, [lossy]) -> utf16TextObject",
        "type" : "Constructor",
        "returns" : [
          " * a new utf16TextObject, or nil if the data could not be encoded as a utf16TextObject"
        ],
        "def" : "hs.text.utf16.new(text, [lossy]) -> utf16TextObject",
        "parameters" : [
          " * `text`  - a lua string or `hs.text` object specifying the text for the new utf16TextObject",
          " * `lossy` - an optional boolean, default `false`, specifying whether or not characters can be removed or altered when converting the data to the UTF16 encoding.",
          ""
        ]
      },
      {
        "desc" : "Returns a copy of the utf16TextObject with all words capitalized.",
        "stripped_doc" : [
          "Returns a copy of the utf16TextObject with all words capitalized.",
          "",
          "Paramters:",
          " * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how to capitalize words.",
          "   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.",
          "   * if this parameter is the boolean `false` or `nil`, uses the system locale",
          "   * if this parameter is the boolean `true`, uses the users current locale",
          "   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)",
          ""
        ],
        "name" : "capitalize",
        "doc" : "Returns a copy of the utf16TextObject with all words capitalized.\n\nParamters:\n * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how to capitalize words.\n   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.\n   * if this parameter is the boolean `false` or `nil`, uses the system locale\n   * if this parameter is the boolean `true`, uses the users current locale\n   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)\n\nReturns:\n * a new utf16TextObject containing the capitalized version of the source\n\nNotes:\n * For the purposes of this methif, a capitalized string is a string with the first character in each word changed to its corresponding uppercase value, and all remaining characters set to their corresponding lowercase values. A word is any sequence of characters delimited by spaces, tabs, or line terminators. Some common word delimiting punctuation isn’t considered, so this property may not generally produce the desired results for multiword strings.",
        "notes" : [
          " * For the purposes of this methif, a capitalized string is a string with the first character in each word changed to its corresponding uppercase value, and all remaining characters set to their corresponding lowercase values. A word is any sequence of characters delimited by spaces, tabs, or line terminators. Some common word delimiting punctuation isn’t considered, so this property may not generally produce the desired results for multiword strings."
        ],
        "signature" : "hs.text.utf16:capitalize([locale]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing the capitalized version of the source",
          ""
        ],
        "def" : "hs.text.utf16:capitalize([locale]) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the number of UTF16 characters in the utf16TextObject between the specified indicies.",
        "stripped_doc" : [
          "Returns the number of UTF16 characters in the utf16TextObject between the specified indicies.",
          "",
          "Paramters:",
          " * `composedCharacters` - an optional boolean, default `false`, specifying whether or not composed character sequences should be treated as a single character (true) or count for as many individual UTF16 \"characters\" as are actually used to specify the sequence (false).",
          " * `i`                  - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.",
          " * `j`                  - an optional integer, default -1, specifying the end of the range; negative indicies are counted from the end of the string.",
          ""
        ],
        "name" : "characterCount",
        "doc" : "Returns the number of UTF16 characters in the utf16TextObject between the specified indicies.\n\nParamters:\n * `composedCharacters` - an optional boolean, default `false`, specifying whether or not composed character sequences should be treated as a single character (true) or count for as many individual UTF16 \"characters\" as are actually used to specify the sequence (false).\n * `i`                  - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.\n * `j`                  - an optional integer, default -1, specifying the end of the range; negative indicies are counted from the end of the string.\n\nReturns:\n * if no invalid sequences are found (see next), returns the number of Unicode characters in the range specified.\n * if an invalid sequence is found (specifically an isolated low or high surrogate or compoased character sequence that starts or ends outside of the specified range when `composedCharacters` is `true`, returns `nil` and the index position of the first invalid UTF16 character.\n\nNotes:\n * This method is similar to lua's `utf8.len` and follows the same semantics -- if a specified index is out of range, a lua error is generated.\n * This method differs from [hs.text.uf16:len](#len) in that surrogate pairs count as one character and composed characters can optionally be considered a single character as well.",
        "notes" : [
          " * This method is similar to lua's `utf8.len` and follows the same semantics -- if a specified index is out of range, a lua error is generated.",
          " * This method differs from [hs.text.uf16:len](#len) in that surrogate pairs count as one character and composed characters can optionally be considered a single character as well."
        ],
        "signature" : "hs.text.utf16:characterCount([composedCharacters], [i], [j]) -> integer | nil, integer",
        "type" : "Method",
        "returns" : [
          " * if no invalid sequences are found (see next), returns the number of Unicode characters in the range specified.",
          " * if an invalid sequence is found (specifically an isolated low or high surrogate or compoased character sequence that starts or ends outside of the specified range when `composedCharacters` is `true`, returns `nil` and the index position of the first invalid UTF16 character.",
          ""
        ],
        "def" : "hs.text.utf16:characterCount([composedCharacters], [i], [j]) -> integer | nil, integer",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns an iterator function that returns the index position (in UTF16 characters) and codepoint of each character in the utf16TextObject.",
        "stripped_doc" : [
          "Returns an iterator function that returns the index position (in UTF16 characters) and codepoint of each character in the utf16TextObject.",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "codes",
        "doc" : "Returns an iterator function that returns the index position (in UTF16 characters) and codepoint of each character in the utf16TextObject.\n\nParamters:\n * None\n\nReturns:\n * an iterator function which can be used with the lua `for` command as an iterator.\n\nNotes:\n * This method is the utf16 equivalent of lua's `utf8.codes`.\n * Example usage:\n\n     ~~~\n     s = hs.text.utf16.new(\"Test 🙂 123\")\n     for p,c in s:codes() do print(p, string.format(\"U+%04x\", c)) end\n     ~~~",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `utf8.codes`.",
          " * Example usage:",
          "",
          "     ~~~",
          "     s = hs.text.utf16.new(\"Test 🙂 123\")",
          "     for p,c in s:codes() do print(p, string.format(\"U+%04x\", c)) end",
          "     ~~~"
        ],
        "signature" : "hs.text.utf16:codes() -> iteratorFunction",
        "type" : "Method",
        "returns" : [
          " * an iterator function which can be used with the lua `for` command as an iterator.",
          ""
        ],
        "def" : "hs.text.utf16:codes() -> iteratorFunction",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the Unicode Codepoints for all characters in the utf16TextObject between the specified indicies.",
        "stripped_doc" : [
          "Returns the Unicode Codepoints for all characters in the utf16TextObject between the specified indicies.",
          "",
          "Paramters:",
          " * `i` - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.",
          " * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.",
          ""
        ],
        "name" : "codpoint",
        "doc" : "Returns the Unicode Codepoints for all characters in the utf16TextObject between the specified indicies.\n\nParamters:\n * `i` - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.\n * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.\n\nReturns:\n * zero or more integers representing the Unicode Codepoints of the UTF16 \"character\" at the indicies specified.\n\nNotes:\n * This method is the utf16 equivalent of lua's `utf8.codepoint` and follows the same semantics -- if a specified index is out of range, a lua error is generated.\n * This method differs from [hs.text.uf16:unitCharacter](#unitCharacter) in that surrogate pairs will result in a single codepoint between U+010000 to U+10FFFF instead of two separate UTF16 characters.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `utf8.codepoint` and follows the same semantics -- if a specified index is out of range, a lua error is generated.",
          " * This method differs from [hs.text.uf16:unitCharacter](#unitCharacter) in that surrogate pairs will result in a single codepoint between U+010000 to U+10FFFF instead of two separate UTF16 characters."
        ],
        "signature" : "hs.text.utf16:codpoint([i], [j]) -> integer, ...",
        "type" : "Method",
        "returns" : [
          " * zero or more integers representing the Unicode Codepoints of the UTF16 \"character\" at the indicies specified.",
          ""
        ],
        "def" : "hs.text.utf16:codpoint([i], [j]) -> integer, ...",
        "parameters" : [

        ]
      },
      {
        "desc" : "Compare the utf16TextObject to a string or another utf16TextObject and return the order",
        "stripped_doc" : [
          "Compare the utf16TextObject to a string or another utf16TextObject and return the order",
          "",
          "Paramters:",
          " * `text`    - a lua string or another utf16TextObject specifying the value to compare this object to",
          " * `options` - an optional integer or table of integers and strings corresponding to values in the [hs.text.utf16.compareOptions](#compareOptions) constant.",
          "   * if `options` is an integer, it should a combination of 1 or more of the numeric values in the [hs.text.utf16.compareOptions](#compareOptions) constant logically OR'ed together (e.g. `hs.text.utf16.compareOptions.caseInsensitive | hs.text.utf16.compareOptions.numeric`)",
          "   * if `options` is a table, each element of the array table should be a number value from the [hs.text.utf16.compareOptions](#compareOptions) constant or a string matching one of the constant's keys. This method will logically OR the appropriate values together for you (e.g. `{\"caseInsensitive\", \"numeric\"}`)",
          " * `locale`  - an optional string, booleam, or nil value specifying the locale to use when comparing.",
          "   * if this parameter is ommitted, is an explicit `nil` or is the boolean value `false`, the system locale is used",
          "   * if this parameter is a boolean value of `true`, the users current locale is used",
          "   * if this paramter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)",
          ""
        ],
        "name" : "compare",
        "doc" : "Compare the utf16TextObject to a string or another utf16TextObject and return the order\n\nParamters:\n * `text`    - a lua string or another utf16TextObject specifying the value to compare this object to\n * `options` - an optional integer or table of integers and strings corresponding to values in the [hs.text.utf16.compareOptions](#compareOptions) constant.\n   * if `options` is an integer, it should a combination of 1 or more of the numeric values in the [hs.text.utf16.compareOptions](#compareOptions) constant logically OR'ed together (e.g. `hs.text.utf16.compareOptions.caseInsensitive | hs.text.utf16.compareOptions.numeric`)\n   * if `options` is a table, each element of the array table should be a number value from the [hs.text.utf16.compareOptions](#compareOptions) constant or a string matching one of the constant's keys. This method will logically OR the appropriate values together for you (e.g. `{\"caseInsensitive\", \"numeric\"}`)\n * `locale`  - an optional string, booleam, or nil value specifying the locale to use when comparing.\n   * if this parameter is ommitted, is an explicit `nil` or is the boolean value `false`, the system locale is used\n   * if this parameter is a boolean value of `true`, the users current locale is used\n   * if this paramter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)\n\nReturns:\n * -1 if `text` is ordered *after* the object (i.e. they are presented in ascending order)\n *  0 if `text` is ordered the same as the object (i.e. they are equal or equivalent, given the options)\n *  1 if `text` is ordered *before* the object (i.e. they are presented in descending order)\n\nNotes:\n * The locale argument affects both equality and ordering algorithms. For example, in some locales, accented characters are ordered immediately after the base; other locales order them after “z”.\n * This method does *not* consider characters with composed character equivalences as identical or similar; if this is a concern, make sure to normalize the source and `text` as appropriate for your purposes with [hs.text.utf16.unicodeDecomposition](#unicodeDecomposition) or [hs.text.utf16.unicodeComposition](#unicodeComposition) before utilizing this method.",
        "notes" : [
          " * The locale argument affects both equality and ordering algorithms. For example, in some locales, accented characters are ordered immediately after the base; other locales order them after “z”.",
          " * This method does *not* consider characters with composed character equivalences as identical or similar; if this is a concern, make sure to normalize the source and `text` as appropriate for your purposes with [hs.text.utf16.unicodeDecomposition](#unicodeDecomposition) or [hs.text.utf16.unicodeComposition](#unicodeComposition) before utilizing this method."
        ],
        "signature" : "hs.text.utf16:compare(text, [options], [locale]) -> -1 | 0 | 1",
        "type" : "Method",
        "returns" : [
          " * -1 if `text` is ordered *after* the object (i.e. they are presented in ascending order)",
          " *  0 if `text` is ordered the same as the object (i.e. they are equal or equivalent, given the options)",
          " *  1 if `text` is ordered *before* the object (i.e. they are presented in descending order)",
          ""
        ],
        "def" : "hs.text.utf16:compare(text, [options], [locale]) -> -1 | 0 | 1",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the starting and ending index of the specified range, adjusting for composed characters or surrogate pairs at the beginning and end of the range.",
        "stripped_doc" : [
          "Returns the starting and ending index of the specified range, adjusting for composed characters or surrogate pairs at the beginning and end of the range.",
          "",
          "Paramters:",
          " * `i` - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.",
          " * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.",
          ""
        ],
        "name" : "composedCharacterRange",
        "doc" : "Returns the starting and ending index of the specified range, adjusting for composed characters or surrogate pairs at the beginning and end of the range.\n\nParamters:\n * `i` - an optional integer, default 1, specifying the starting index of the UTF16 character to begin at; negative indicies are counted from the end of the string.\n * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.\n\nReturns:\n * the `start` and `end` indicies for the range of characters specified by the initial range\n\nNotes:\n * if the unit character at index `i` specifies a low surrogate or is in the middle of a mulit-\"character\" composed character, `start` will be < `i`\n * likewise if `j` is in the middle of a multi-\"character\" composition or surrogate, `end` will be > `j`.\n\n * this method follows the semantics of `utf8.codepoint` -- if a specified index is out of range, a lua error is generated.",
        "notes" : [
          " * if the unit character at index `i` specifies a low surrogate or is in the middle of a mulit-\"character\" composed character, `start` will be < `i`",
          " * likewise if `j` is in the middle of a multi-\"character\" composition or surrogate, `end` will be > `j`.",
          "",
          " * this method follows the semantics of `utf8.codepoint` -- if a specified index is out of range, a lua error is generated."
        ],
        "signature" : "hs.text.utf16:composedCharacterRange([i], [j]) -> start, end",
        "type" : "Method",
        "returns" : [
          " * the `start` and `end` indicies for the range of characters specified by the initial range",
          ""
        ],
        "def" : "hs.text.utf16:composedCharacterRange([i], [j]) -> start, end",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns an iterator function that returns the indicies of each character in the utf16TextObject, treating surrogate pairs and composed character sequences as single characters.",
        "stripped_doc" : [
          "Returns an iterator function that returns the indicies of each character in the utf16TextObject, treating surrogate pairs and composed character sequences as single characters.",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "composedCharacters",
        "doc" : "Returns an iterator function that returns the indicies of each character in the utf16TextObject, treating surrogate pairs and composed character sequences as single characters.\n\nParamters:\n * None\n\nReturns:\n * an iterator function which can be used with the lua `for` command as an iterator.\n\nNotes:\n * Example usage:\n\n     ~~~\n     s = hs.text.utf16.new(\"abc🙂123\") .. hs.text.utf16.char(0x073, 0x0323, 0x0307) .. \"xyz\"\n     for i,j in s:composedCharacters() do print(i, j, s:sub(i,j)) end\n     ~~~",
        "notes" : [
          " * Example usage:",
          "",
          "     ~~~",
          "     s = hs.text.utf16.new(\"abc🙂123\") .. hs.text.utf16.char(0x073, 0x0323, 0x0307) .. \"xyz\"",
          "     for i,j in s:composedCharacters() do print(i, j, s:sub(i,j)) end",
          "     ~~~"
        ],
        "signature" : "hs.text.utf16:composedCharacters() -> iteratorFunction",
        "type" : "Method",
        "returns" : [
          " * an iterator function which can be used with the lua `for` command as an iterator.",
          ""
        ],
        "def" : "hs.text.utf16:composedCharacters() -> iteratorFunction",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create a copy of the utf16TextObject",
        "stripped_doc" : [
          "Create a copy of the utf16TextObject",
          "",
          "Paramters:",
          " * None",
          ""
        ],
        "name" : "copy",
        "doc" : "Create a copy of the utf16TextObject\n\nParamters:\n * None\n\nReturns:\n * a copy of the utf16TextObject as a new object",
        "notes" : [

        ],
        "signature" : "hs.text.utf16:copy() -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a copy of the utf16TextObject as a new object"
        ],
        "def" : "hs.text.utf16:copy() -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Looks for the first match of a pattern within the utf16TextObject and returns the indicies of the match",
        "stripped_doc" : [
          "Looks for the first match of a pattern within the utf16TextObject and returns the indicies of the match",
          "",
          "Paramters:",
          " * `pattern` - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.",
          " * `i`       - an optional integer, default 1, specifying the index of the utf16TextObject where the search for the pattern should begin; negative indicies are counted from the end of the object.",
          " * `plain`   - an optional boolean, default `false`, specifying that the pattern should be matched *exactly* (true) instead of treated as a regular expression (false).",
          ""
        ],
        "name" : "find",
        "doc" : "Looks for the first match of a pattern within the utf16TextObject and returns the indicies of the match\n\nParamters:\n * `pattern` - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.\n * `i`       - an optional integer, default 1, specifying the index of the utf16TextObject where the search for the pattern should begin; negative indicies are counted from the end of the object.\n * `plain`   - an optional boolean, default `false`, specifying that the pattern should be matched *exactly* (true) instead of treated as a regular expression (false).\n\nReturns:\n * If a match is found, returns the starting and ending indicies of the match (as integers); if captures are specified in the pattern, also returns a new utf16TextObjects for each capture after the indicies. If no match is found, returns nil.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.find` with one important caveat:\n   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.\n   * Again, ***Lua pattern matching syntax will not work with this method.***",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.find` with one important caveat:",
          "   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.",
          "   * Again, ***Lua pattern matching syntax will not work with this method.***"
        ],
        "signature" : "hs.text.utf16:find(pattern, [i], [plain]) -> start, end, [captures...] | nil",
        "type" : "Method",
        "returns" : [
          " * If a match is found, returns the starting and ending indicies of the match (as integers); if captures are specified in the pattern, also returns a new utf16TextObjects for each capture after the indicies. If no match is found, returns nil.",
          ""
        ],
        "def" : "hs.text.utf16:find(pattern, [i], [plain]) -> start, end, [captures...] | nil",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns an iterator function that iteratively returns the captures (if specified) or the entire match (if no captures are specified) of the pattern over the utf16TextObject.",
        "stripped_doc" : [
          "Returns an iterator function that iteratively returns the captures (if specified) or the entire match (if no captures are specified) of the pattern over the utf16TextObject.",
          "",
          "Paramters:",
          " * `pattern` - a lua string or utf16TextObject specifying the pattern to iteratively match over the utf16TextObject.",
          ""
        ],
        "name" : "gmatch",
        "doc" : "Returns an iterator function that iteratively returns the captures (if specified) or the entire match (if no captures are specified) of the pattern over the utf16TextObject.\n\nParamters:\n * `pattern` - a lua string or utf16TextObject specifying the pattern to iteratively match over the utf16TextObject.\n\nReturns:\n * an iterator function which can be used with the lua `for` command as an iterator.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.gmatch`.\n * This method uses the [hs.text.utf16:find](#find) method on a copy of the original string, so it is safe to modify the original object within the loop. See the documentation for [find](#find) for information on the format of `pattern`.\n\n * The following examples are from the Lua documentation for `string.gmatch` modified with the proper syntax:\n\n     ~~~\n     -- print each word on a separate line\n     s = hs.text.utf16.new(\"hello world from Lua\")\n     for w in s:gmatch([[\\p{Alphabetic}+]]) do\n       print(w)\n     end\n\n     -- collect all pairs key=value from the given string into a table:\n     t = {}\n     s = hs.text.utf16.new(\"from=world, to=Lua\")\n     for k, v in s:gmatch([[(\\w+)=(\\w+)]]) do\n       t[tostring(k)] = tostring(v)\n     end\n     ~~~",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.gmatch`.",
          " * This method uses the [hs.text.utf16:find](#find) method on a copy of the original string, so it is safe to modify the original object within the loop. See the documentation for [find](#find) for information on the format of `pattern`.",
          "",
          " * The following examples are from the Lua documentation for `string.gmatch` modified with the proper syntax:",
          "",
          "     ~~~",
          "     -- print each word on a separate line",
          "     s = hs.text.utf16.new(\"hello world from Lua\")",
          "     for w in s:gmatch([[\\p{Alphabetic}+]]) do",
          "       print(w)",
          "     end",
          "",
          "     -- collect all pairs key=value from the given string into a table:",
          "     t = {}",
          "     s = hs.text.utf16.new(\"from=world, to=Lua\")",
          "     for k, v in s:gmatch([[(\\w+)=(\\w+)]]) do",
          "       t[tostring(k)] = tostring(v)",
          "     end",
          "     ~~~"
        ],
        "signature" : "hs.text.utf16:gmatch(pattern) -> iteratorFunction",
        "type" : "Method",
        "returns" : [
          " * an iterator function which can be used with the lua `for` command as an iterator.",
          ""
        ],
        "def" : "hs.text.utf16:gmatch(pattern) -> iteratorFunction",
        "parameters" : [

        ]
      },
      {
        "desc" : "Return a gopy of the object with occurances of the pattern replaced; global substitution.",
        "stripped_doc" : [
          "Return a gopy of the object with occurances of the pattern replaced; global substitution.",
          "",
          "Paramters:",
          " * `pattern`     - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.",
          " * `replacement` - a lua string, utf16TextObject, table, or function which specifies replacement(s) for pattern matches.",
          "   * if `replacement` is a string or utf16TextObject, then its value is used for replacement. Any sequence in the replacement of the form `$n` where `n` is an integer >= 0 will be replaced by the `n`th capture from the pattern (`$0` specifies the entire match). A `$` not followed by a number is treated as a literal `$`. To specify a literal `$` followed by a numeric digit, escape the dollar sign (e.g. `\\$1`)",
          "   * if `replacement` is a table, the table is queried for every match using the first capture (if captures are specified) or the entire match (if no captures are specified). Keys in the table must be lua strings or utf16TextObjects, and values must be lua strings, numbers, or utf16TextObjects. If no key matches the capture, no replacement of the match occurs.",
          "   * if `replacement` is a function, the function will be called with all of the captured substrings passed in as utf16TextObjects in order (or the entire match, if no captures are specified). The return value is used as the repacement of the match and must be `nil`, a lua string, a number, or a utf16TextObject. If the return value is `nil`, no replacement of the match occurs.",
          " * `n`           - an optional integer specifying the maximum number of replacements to perform. If this is not specified, all matches in the object will be replaced.",
          ""
        ],
        "name" : "gsub",
        "doc" : "Return a gopy of the object with occurances of the pattern replaced; global substitution.\n\nParamters:\n * `pattern`     - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.\n * `replacement` - a lua string, utf16TextObject, table, or function which specifies replacement(s) for pattern matches.\n   * if `replacement` is a string or utf16TextObject, then its value is used for replacement. Any sequence in the replacement of the form `$n` where `n` is an integer >= 0 will be replaced by the `n`th capture from the pattern (`$0` specifies the entire match). A `$` not followed by a number is treated as a literal `$`. To specify a literal `$` followed by a numeric digit, escape the dollar sign (e.g. `\\$1`)\n   * if `replacement` is a table, the table is queried for every match using the first capture (if captures are specified) or the entire match (if no captures are specified). Keys in the table must be lua strings or utf16TextObjects, and values must be lua strings, numbers, or utf16TextObjects. If no key matches the capture, no replacement of the match occurs.\n   * if `replacement` is a function, the function will be called with all of the captured substrings passed in as utf16TextObjects in order (or the entire match, if no captures are specified). The return value is used as the repacement of the match and must be `nil`, a lua string, a number, or a utf16TextObject. If the return value is `nil`, no replacement of the match occurs.\n * `n`           - an optional integer specifying the maximum number of replacements to perform. If this is not specified, all matches in the object will be replaced.\n\nReturns:\n * a new utf16TextObject with the substitutions specified, followed by an integer specifying the number of substitutions that occurred.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.gsub` with one important caveat:\n   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.\n   * Again, ***Lua pattern matching syntax will not work with this method.***\n\n * The following examples are from the Lua documentation for `string.gsub` modified with the proper syntax:\n\n     ~~~\n     x = hs.text.utf16.new(\"hello world\"):gsub(\"(\\\\w+)\", \"$1 $1\")\n     -- x will equal \"hello hello world world\"\n\n     -- note that if we use Lua's block quotes (e.g. `[[` and `]]`), then we don't have to escape the backslash:\n\n     x = hs.text.utf16.new(\"hello world\"):gsub([[\\w+]], \"$0 $0\", 1)\n     -- x will equal \"hello hello world\"\n\n     x = hs.text.utf16.new(\"hello world from Lua\"):gsub([[(\\w+)\\s*(\\w+)]], \"$2 $1\")\n     -- x will equal \"world hello Lua from\"\n\n     x = hs.text.utf16.new(\"home = $HOME, user = $USER\"):gsub([[\\$(\\w+)]], function(a) return os.getenv(tostring(a)) end)\n     -- x will equal \"home = \/home\/username, user = username\"\n\n     x = hs.text.utf16.new(\"4+5 = $return 4+5$\"):gsub([[\\$(.+)\\$]], function (s) return load(tostring(s))() end)\n     -- x will equal \"4+5 = 9\"\n\n     local t = {name=\"lua\", version=\"5.3\"}\n     x = hs.text.utf16.new(\"$name-$version.tar.gz\"):gsub([[\\$(\\w+)]], t)\n     -- x will equal \"lua-5.3.tar.gz\"\n     ~~~",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.gsub` with one important caveat:",
          "   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.",
          "   * Again, ***Lua pattern matching syntax will not work with this method.***",
          "",
          " * The following examples are from the Lua documentation for `string.gsub` modified with the proper syntax:",
          "",
          "     ~~~",
          "     x = hs.text.utf16.new(\"hello world\"):gsub(\"(\\\\w+)\", \"$1 $1\")",
          "     -- x will equal \"hello hello world world\"",
          "",
          "     -- note that if we use Lua's block quotes (e.g. `[[` and `]]`), then we don't have to escape the backslash:",
          "",
          "     x = hs.text.utf16.new(\"hello world\"):gsub([[\\w+]], \"$0 $0\", 1)",
          "     -- x will equal \"hello hello world\"",
          "",
          "     x = hs.text.utf16.new(\"hello world from Lua\"):gsub([[(\\w+)\\s*(\\w+)]], \"$2 $1\")",
          "     -- x will equal \"world hello Lua from\"",
          "",
          "     x = hs.text.utf16.new(\"home = $HOME, user = $USER\"):gsub([[\\$(\\w+)]], function(a) return os.getenv(tostring(a)) end)",
          "     -- x will equal \"home = \/home\/username, user = username\"",
          "",
          "     x = hs.text.utf16.new(\"4+5 = $return 4+5$\"):gsub([[\\$(.+)\\$]], function (s) return load(tostring(s))() end)",
          "     -- x will equal \"4+5 = 9\"",
          "",
          "     local t = {name=\"lua\", version=\"5.3\"}",
          "     x = hs.text.utf16.new(\"$name-$version.tar.gz\"):gsub([[\\$(\\w+)]], t)",
          "     -- x will equal \"lua-5.3.tar.gz\"",
          "     ~~~"
        ],
        "signature" : "hs.text.utf16:gsub(pattern, replacement, [n]) -> utf16TextObject, count",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject with the substitutions specified, followed by an integer specifying the number of substitutions that occurred.",
          ""
        ],
        "def" : "hs.text.utf16:gsub(pattern, replacement, [n]) -> utf16TextObject, count",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the length in UTF16 characters in the object",
        "stripped_doc" : [
          "Returns the length in UTF16 characters in the object",
          ""
        ],
        "name" : "len",
        "doc" : "Returns the length in UTF16 characters in the object\n\nParameters:\n * None\n\nReturns:\n * the number of UTF16 characterss in the object\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.len`\n * Composed character sequences and surrogate pairs are made up of multiple UTF16 \"characters\"; see also [hs.text.utf16:characterCount](#characterCount) wihch offers more options.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.len`",
          " * Composed character sequences and surrogate pairs are made up of multiple UTF16 \"characters\"; see also [hs.text.utf16:characterCount](#characterCount) wihch offers more options."
        ],
        "signature" : "hs.text.utf16:len() -> integer",
        "type" : "Method",
        "returns" : [
          " * the number of UTF16 characterss in the object",
          ""
        ],
        "def" : "hs.text.utf16:len() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a copy of the utf16TextObject with an lowercase representation of the source.",
        "stripped_doc" : [
          "Returns a copy of the utf16TextObject with an lowercase representation of the source.",
          "",
          "Paramters:",
          " * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how change case.",
          "   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.",
          "   * if this parameter is the boolean `false` or `nil`, uses the system locale",
          "   * if this parameter is the boolean `true`, uses the users current locale",
          "   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)",
          ""
        ],
        "name" : "lower",
        "doc" : "Returns a copy of the utf16TextObject with an lowercase representation of the source.\n\nParamters:\n * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how change case.\n   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.\n   * if this parameter is the boolean `false` or `nil`, uses the system locale\n   * if this parameter is the boolean `true`, uses the users current locale\n   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)\n\nReturns:\n * a new utf16TextObject containing an lowercase representation of the source.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.lower`\n * Case transformations aren’t guaranteed to be symmetrical or to produce strings of the same lengths as the originals.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.lower`",
          " * Case transformations aren’t guaranteed to be symmetrical or to produce strings of the same lengths as the originals."
        ],
        "signature" : "hs.text.utf16:lower([locale]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing an lowercase representation of the source.",
          ""
        ],
        "def" : "hs.text.utf16:lower([locale]) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Looks for the first match of a pattern within the utf16TextObject and returns it",
        "stripped_doc" : [
          "Looks for the first match of a pattern within the utf16TextObject and returns it",
          "",
          "Paramters:",
          " * `pattern` - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.",
          " * `i`       - an optional integer, default 1, specifying the index of the utf16TextObject where the search for the pattern should begin; negative indicies are counted from the end of the object.",
          ""
        ],
        "name" : "match",
        "doc" : "Looks for the first match of a pattern within the utf16TextObject and returns it\n\nParamters:\n * `pattern` - a lua string or utf16TextObject specifying the pattern for the match. See *Notes*.\n * `i`       - an optional integer, default 1, specifying the index of the utf16TextObject where the search for the pattern should begin; negative indicies are counted from the end of the object.\n\nReturns:\n * If a match is found and the pattern specifies captures, returns a new utf16TextObjects for each capture; if no captures are specified, returns the entire match as a new utf16TextObject. If no matche is found, returns nil.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.match` with one important caveat:\n   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.\n   * Again, ***Lua pattern matching syntax will not work with this method.***",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.match` with one important caveat:",
          "   * This method utilizes regular expressions as described at http:\/\/userguide.icu-project.org\/strings\/regexp, not the Lua pattern matching syntax.",
          "   * Again, ***Lua pattern matching syntax will not work with this method.***"
        ],
        "signature" : "hs.text.utf16:match(pattern, [i]) -> match(es) | nil",
        "type" : "Method",
        "returns" : [
          " * If a match is found and the pattern specifies captures, returns a new utf16TextObjects for each capture; if no captures are specified, returns the entire match as a new utf16TextObject. If no matche is found, returns nil.",
          ""
        ],
        "def" : "hs.text.utf16:match(pattern, [i]) -> match(es) | nil",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the position (in UTF16 characters) where the encoding of the `n`th character of the utf16TextObject begins.",
        "stripped_doc" : [
          "Returns the position (in UTF16 characters) where the encoding of the `n`th character of the utf16TextObject begins.",
          "",
          "Paramters:",
          " * `composedCharacters` - an optional boolean, default `false` specifying whether or not composed character sequences should be considered as a single UTF16 character (true) or as the individual characters that make up the sequence (false).",
          " * `n`                  - an integer specifying the UTF16 character number to get the offset for, starting from position `i`. If `n` is negative, gets specifies the number of characters before position `i`.",
          " * `i`                  - an optional integer, default 1 when `n` is non-negative or [hs.text.utf16:len](#len) + 1 when `n` is negative, specifiying the starting character from which to count `n`.",
          ""
        ],
        "name" : "offset",
        "doc" : "Returns the position (in UTF16 characters) where the encoding of the `n`th character of the utf16TextObject begins.\n\nParamters:\n * `composedCharacters` - an optional boolean, default `false` specifying whether or not composed character sequences should be considered as a single UTF16 character (true) or as the individual characters that make up the sequence (false).\n * `n`                  - an integer specifying the UTF16 character number to get the offset for, starting from position `i`. If `n` is negative, gets specifies the number of characters before position `i`.\n * `i`                  - an optional integer, default 1 when `n` is non-negative or [hs.text.utf16:len](#len) + 1 when `n` is negative, specifiying the starting character from which to count `n`.\n\nReturns:\n * the index of the utf16TextObject where the `n`th character begins or nil if no such character exists. As a special case when `n` is 0, returns the offset of the start of the character that contains the `i`th UTF16 character of the utf16Text obejct.\n\nNotes:\n * This method is the utf16 equivalent of lua's `utf8.offset`.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `utf8.offset`."
        ],
        "signature" : "hs.text.utf16:offset([composedCharacters], n, [i]) -> integer | nil",
        "type" : "Method",
        "returns" : [
          " * the index of the utf16TextObject where the `n`th character begins or nil if no such character exists. As a special case when `n` is 0, returns the offset of the start of the character that contains the `i`th UTF16 character of the utf16Text obejct.",
          ""
        ],
        "def" : "hs.text.utf16:offset([composedCharacters], n, [i]) -> integer | nil",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns a new utf16TextObject with the characters reveresed.",
        "stripped_doc" : [
          "Returns a new utf16TextObject with the characters reveresed.",
          ""
        ],
        "name" : "reverse",
        "doc" : "Returns a new utf16TextObject with the characters reveresed.\n\nParameters:\n * None\n\nReturns:\n * a new utf16TextObject with the characters reveresed\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.reverse`\n * Surrogate pairs and composed character sequences are maintained, so the reversed object will be composed of valid UTF16 sequences (assuming, of course, that the original object was composed of valid UTF16 sequences)",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.reverse`",
          " * Surrogate pairs and composed character sequences are maintained, so the reversed object will be composed of valid UTF16 sequences (assuming, of course, that the original object was composed of valid UTF16 sequences)"
        ],
        "signature" : "hs.text.utf16:reverse() -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject with the characters reveresed",
          ""
        ],
        "def" : "hs.text.utf16:reverse() -> utf16TextObject",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a new utf16TextObject containing a substring of the source object",
        "stripped_doc" : [
          "Returns a new utf16TextObject containing a substring of the source object",
          ""
        ],
        "name" : "sub",
        "doc" : "Returns a new utf16TextObject containing a substring of the source object\n\nParameters:\n * `i` - an integer specifying the starting index of the substring; negative indicies are counted from the end of the string.\n * `j` - an optional integer, default -1, specifying the end of the substring; negative indicies are counted from the end of the string.\n\nReturns:\n * a new utf16TextObject containing a substring of the source object as delimited by the indicies `i` and `j`\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.sub`\n   * In particular, `hs.text.utf16:sub(1, j)` will return the prefix of the source with a length of `j`, and `hs.text.utf16:sub(-i)` returns the suffix of the source with a length of `i`.\n\n * This method uses the specific indicies provided, which could result in a broken surrogate or composed character sequence at the begining or end of the substring. If this is a concern, use [hs.text.utf16:composedCharacterRange](#composedCharacterRange) to adjust the range values before invoking this method.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.sub`",
          "   * In particular, `hs.text.utf16:sub(1, j)` will return the prefix of the source with a length of `j`, and `hs.text.utf16:sub(-i)` returns the suffix of the source with a length of `i`.",
          "",
          " * This method uses the specific indicies provided, which could result in a broken surrogate or composed character sequence at the begining or end of the substring. If this is a concern, use [hs.text.utf16:composedCharacterRange](#composedCharacterRange) to adjust the range values before invoking this method."
        ],
        "signature" : "hs.text.utf16:sub([i], [j]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing a substring of the source object as delimited by the indicies `i` and `j`",
          ""
        ],
        "def" : "hs.text.utf16:sub([i], [j]) -> utf16TextObject",
        "parameters" : [
          " * `i` - an integer specifying the starting index of the substring; negative indicies are counted from the end of the string.",
          " * `j` - an optional integer, default -1, specifying the end of the substring; negative indicies are counted from the end of the string.",
          ""
        ]
      },
      {
        "desc" : "Create a new utf16TextObject by applying the specified ICU transform",
        "stripped_doc" : [
          "Create a new utf16TextObject by applying the specified ICU transform",
          "",
          "Paramters:",
          " * `transform` - a string specifying the ICU transform(s) to apply",
          " * `inverse`   - an optional boolean, default `false`, specifying whether or not to apply the inverse (or reverse) of the specified transformation",
          ""
        ],
        "name" : "transform",
        "doc" : "Create a new utf16TextObject by applying the specified ICU transform\n\nParamters:\n * `transform` - a string specifying the ICU transform(s) to apply\n * `inverse`   - an optional boolean, default `false`, specifying whether or not to apply the inverse (or reverse) of the specified transformation\n\nReturns:\n * a new utf16TextObject containing the transformed data, or nil if the transform (or its inverse) could not be applied or was invalid\n\nNotes:\n * some built in transforms are identified in the constant table [hs.text.utf16.builtinTransforms](#builtInTransforms).\n * transform syntax is beyond the scope of this document; see http:\/\/userguide.icu-project.org\/transforms\/general for more information on creating your own transforms\n\n * Note that not all transforms have an inverse or are reversible.",
        "notes" : [
          " * some built in transforms are identified in the constant table [hs.text.utf16.builtinTransforms](#builtInTransforms).",
          " * transform syntax is beyond the scope of this document; see http:\/\/userguide.icu-project.org\/transforms\/general for more information on creating your own transforms",
          "",
          " * Note that not all transforms have an inverse or are reversible."
        ],
        "signature" : "hs.text.utf16:transform(transform, [inverse]) -> utf16TextObject | nil",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing the transformed data, or nil if the transform (or its inverse) could not be applied or was invalid",
          ""
        ],
        "def" : "hs.text.utf16:transform(transform, [inverse]) -> utf16TextObject | nil",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)C.",
        "stripped_doc" : [
          "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)C.",
          "",
          "Paramters:",
          " * `compatibilityMapping` - an optionabl boolean, default `false`, specifying whether compatibility mapping (true) should be used (Normalization Form KC) or canonical mapping (false) should be used (Normalization Form C) when normalizing the text.",
          ""
        ],
        "name" : "unicodeComposition",
        "doc" : "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)C.\n\nParamters:\n * `compatibilityMapping` - an optionabl boolean, default `false`, specifying whether compatibility mapping (true) should be used (Normalization Form KC) or canonical mapping (false) should be used (Normalization Form C) when normalizing the text.\n\nReturns:\n * a new utf16TextObject with the contents of the parent normalized using Unicode NormalizationForm (K)C.\n\nNotes:\n * At its most basic, normalization is useful when comparing strings which may have been composed differently (e.g. a single UTF16 character representing an accented `á` vs the visually equivalent composed character sequence of an `a` followed by U+0301) or use stylized versions of characters or numbers (e.g. `1` vs `①`), but need to be compared for their \"visual\" or \"intended\" equivalance.\n\n * see http:\/\/www.unicode.org\/reports\/tr15\/ for a more complete discussion of the various types of Unicode Normalization and the differences\/strengths\/weaknesses of each.\n\n * See also [hs.text.utf16:unicodeDecomposition](#unicodeDecomposition)",
        "notes" : [
          " * At its most basic, normalization is useful when comparing strings which may have been composed differently (e.g. a single UTF16 character representing an accented `á` vs the visually equivalent composed character sequence of an `a` followed by U+0301) or use stylized versions of characters or numbers (e.g. `1` vs `①`), but need to be compared for their \"visual\" or \"intended\" equivalance.",
          "",
          " * see http:\/\/www.unicode.org\/reports\/tr15\/ for a more complete discussion of the various types of Unicode Normalization and the differences\/strengths\/weaknesses of each.",
          "",
          " * See also [hs.text.utf16:unicodeDecomposition](#unicodeDecomposition)"
        ],
        "signature" : "hs.text.utf16:unicodeComposition([compatibilityMapping]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject with the contents of the parent normalized using Unicode NormalizationForm (K)C.",
          ""
        ],
        "def" : "hs.text.utf16:unicodeComposition([compatibilityMapping]) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)D.",
        "stripped_doc" : [
          "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)D.",
          "",
          "Paramters:",
          " * `compatibilityMapping` - an optionabl boolean, default `false`, specifying whether compatibility mapping (true) should be used (Normalization Form KD) or canonical mapping (false) should be used (Normalization Form D) when normalizing the text.",
          ""
        ],
        "name" : "unicodeDecomposition",
        "doc" : "Create a new utf16TextObject with the contents of the parent normalized using Unicode Normalization Form (K)D.\n\nParamters:\n * `compatibilityMapping` - an optionabl boolean, default `false`, specifying whether compatibility mapping (true) should be used (Normalization Form KD) or canonical mapping (false) should be used (Normalization Form D) when normalizing the text.\n\nReturns:\n * a new utf16TextObject with the contents of the parent normalized using Unicode NormalizationForm (K)D.\n\nNotes:\n * At its most basic, normalization is useful when comparing strings which may have been composed differently (e.g. a single UTF16 character representing an accented `á` vs the visually equivalent composed character sequence of an `a` followed by U+0301) or use stylized versions of characters or numbers (e.g. `1` vs `①`), but need to be compared for their \"visual\" or \"intended\" equivalance.\n\n * see http:\/\/www.unicode.org\/reports\/tr15\/ for a more complete discussion of the various types of Unicode Normalization and the differences\/strengths\/weaknesses of each.\n\n * See also [hs.text.utf16:unicodeComposition](#unicodeComposition)",
        "notes" : [
          " * At its most basic, normalization is useful when comparing strings which may have been composed differently (e.g. a single UTF16 character representing an accented `á` vs the visually equivalent composed character sequence of an `a` followed by U+0301) or use stylized versions of characters or numbers (e.g. `1` vs `①`), but need to be compared for their \"visual\" or \"intended\" equivalance.",
          "",
          " * see http:\/\/www.unicode.org\/reports\/tr15\/ for a more complete discussion of the various types of Unicode Normalization and the differences\/strengths\/weaknesses of each.",
          "",
          " * See also [hs.text.utf16:unicodeComposition](#unicodeComposition)"
        ],
        "signature" : "hs.text.utf16:unicodeDecomposition([compatibilityMapping]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject with the contents of the parent normalized using Unicode NormalizationForm (K)D.",
          ""
        ],
        "def" : "hs.text.utf16:unicodeDecomposition([compatibilityMapping]) -> utf16TextObject",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns the UTF16 unit character codes for the range specified",
        "stripped_doc" : [
          "Returns the UTF16 unit character codes for the range specified",
          "",
          "Paramters:",
          " * `i` - an optional integer, default 1, specifying the starting indexof the UTF16 character to begin at; negative indicies are counted from the end of the string.",
          " * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.",
          ""
        ],
        "name" : "unitCharacter",
        "doc" : "Returns the UTF16 unit character codes for the range specified\n\nParamters:\n * `i` - an optional integer, default 1, specifying the starting indexof the UTF16 character to begin at; negative indicies are counted from the end of the string.\n * `j` - an optional integer, default the value of `i`, specifying the end of the range; negative indicies are counted from the end of the string.\n\nReturns:\n * zero or more integers representing the individual utf16 \"characters\" of the object within the range specified\n\nNotes:\n * this method returns the 16bit integer corresponding to the UTF16 \"character\" at the indicies specified. Surrogate pairs *are* treated as two separate \"characters\" by this method, so the initial or final character may be a broken surrogate -- see [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate).\n\n * this method follows the semantics of `utf8.codepoint` -- if a specified index is out of range, a lua error is generated.",
        "notes" : [
          " * this method returns the 16bit integer corresponding to the UTF16 \"character\" at the indicies specified. Surrogate pairs *are* treated as two separate \"characters\" by this method, so the initial or final character may be a broken surrogate -- see [hs.text.utf16.isHighSurrogate](#isHighSurrogate) and [hs.text.utf16.isLowSurrogate](#isLowSurrogate).",
          "",
          " * this method follows the semantics of `utf8.codepoint` -- if a specified index is out of range, a lua error is generated."
        ],
        "signature" : "hs.text.utf16:unitCharacter([i], [j]) -> integer, ...",
        "type" : "Method",
        "returns" : [
          " * zero or more integers representing the individual utf16 \"characters\" of the object within the range specified",
          ""
        ],
        "def" : "hs.text.utf16:unitCharacter([i], [j]) -> integer, ...",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns a copy of the utf16TextObject with an uppercase representation of the source.",
        "stripped_doc" : [
          "Returns a copy of the utf16TextObject with an uppercase representation of the source.",
          "",
          "Paramters:",
          " * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how change case.",
          "   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.",
          "   * if this parameter is the boolean `false` or `nil`, uses the system locale",
          "   * if this parameter is the boolean `true`, uses the users current locale",
          "   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)",
          ""
        ],
        "name" : "upper",
        "doc" : "Returns a copy of the utf16TextObject with an uppercase representation of the source.\n\nParamters:\n * `locale` - an optional string or boolean (default ommitted) specifying whether to consider localization when determining how change case.\n   * if this parameter is ommitted, uses canonical (non-localized) mapping suitable for programming operations that require stable results not depending on the current locale.\n   * if this parameter is the boolean `false` or `nil`, uses the system locale\n   * if this parameter is the boolean `true`, uses the users current locale\n   * if this parameter is a string, the locale specified by the string is used. (See `hs.host.locale.availableLocales()` for valid locale identifiers)\n\nReturns:\n * a new utf16TextObject containing an uppercase representation of the source.\n\nNotes:\n * This method is the utf16 equivalent of lua's `string.upper`\n * Case transformations aren’t guaranteed to be symmetrical or to produce strings of the same lengths as the originals.",
        "notes" : [
          " * This method is the utf16 equivalent of lua's `string.upper`",
          " * Case transformations aren’t guaranteed to be symmetrical or to produce strings of the same lengths as the originals."
        ],
        "signature" : "hs.text.utf16:upper([locale]) -> utf16TextObject",
        "type" : "Method",
        "returns" : [
          " * a new utf16TextObject containing an uppercase representation of the source.",
          ""
        ],
        "def" : "hs.text.utf16:upper([locale]) -> utf16TextObject",
        "parameters" : [

        ]
      }
    ],
    "doc" : "Perform text manipulation on UTF16 objects created by the `hs.text` module.\n\nThis sumodule replicates many of the functions found in the lua `string` and `utf8` libraries but modified for use with UTF16 text objects.\n\nMetamethods to make the objects work more like Lua strings:\n\n * unlike most userdata objects used by Hammerspoon modules, `hs.text.utf16` objects have their `__tostring` metamethod defined to return the UTF8 equivalent of the object. This allows the object to be printed to the Hammerspoon console directly with the lua `print` command (e.g. `print(object)`). You can also save the object as a lua string with `tostring(object)`.\n * (in)equality -- the metamethods for equality and inequality use [hs.text.utf16:compare({\"literal\"})](#compate) when you use `==`, `~=`, `<`, `<=`, `>`, or `>=` to compare a `hs.text.utf16` to another or to a lua string.\n * concatenation -- you can create a new `hs.utf16.text` objext by combining two objects (or one and a lua string) with `..`\n\nAdditional Notes\n\nInternally, the macOS provides a wide range of functions for manipulating and managing UTF16 strings in the Objective-C runtime. While a wide variety of encodings can be used for importing and exporting data (see the main body of the `hs.text` module), string manipulation is provided by macOS only for the UTf16 representation of the encoded data. When working with data encoded in other formats, use the `hs.text:toUTF16()` method which will create an object his submodule can manipulate. When finished, you can convert the data back to the necessary encoding with the `hs.text.new()` function and then export the data back (e.g. writing to a file or posting to a URL).\n\nIn addition to the lua `string` and `utf8` functions, additional functions provided by the macOS are included. This includes, but is not limited to, Unicode normalization and ICU transforms.",
    "name" : "hs.text.utf16"
  }
]
