[
  {
    "Constant" : [

    ],
    "submodules" : [
      "forcetouch",
      "watcher"
    ],
    "Function" : [
      {
        "desc" : "Returns a number specifying the time in seconds since the last system reboot.",
        "stripped_doc" : [
          "Returns a number specifying the time in seconds since the last system reboot.",
          ""
        ],
        "name" : "absoluteTime",
        "doc" : "Returns a number specifying the time in seconds since the last system reboot.\n\nParameters:\n * None\n\nReturns:\n * a number specifying the time in seconds since the last system reboot",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.absoluteTime() -> number",
        "type" : "Function",
        "returns" : [
          " * a number specifying the time in seconds since the last system reboot"
        ],
        "def" : "hs._asm.undocumented.touchdevice.absoluteTime() -> number",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns whether or not a multi-touch device is currently attached to the system.",
        "stripped_doc" : [
          "Returns whether or not a multi-touch device is currently attached to the system.",
          ""
        ],
        "name" : "available",
        "doc" : "Returns whether or not a multi-touch device is currently attached to the system.\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not a multi-touch device is currently attached to the system\n\nNotes:\n * multi-touch devices include the built-in trackpad found on any modern Mac laptop, the Magic Mouse, and the Magic Trackpad.",
        "notes" : [
          " * multi-touch devices include the built-in trackpad found on any modern Mac laptop, the Magic Mouse, and the Magic Trackpad."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.available() -> boolean",
        "type" : "Function",
        "returns" : [
          " * a boolean value indicating whether or not a multi-touch device is currently attached to the system",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.available() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a list of the device id's for all currently available multi-touch devices",
        "stripped_doc" : [
          "Returns a list of the device id's for all currently available multi-touch devices",
          ""
        ],
        "name" : "devices",
        "doc" : "Returns a list of the device id's for all currently available multi-touch devices\n\nParameters:\n * None\n\nReturns:\n * a table as an array containing the device id's of all currently attached\/available multi-touch devices",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.devices() -> table",
        "type" : "Function",
        "returns" : [
          " * a table as an array containing the device id's of all currently attached\/available multi-touch devices"
        ],
        "def" : "hs._asm.undocumented.touchdevice.devices() -> table",
        "parameters" : [
          " * None",
          ""
        ]
      }
    ],
    "Variable" : [

    ],
    "stripped_doc" : [

    ],
    "desc" : "This module provides functionality for detecting and using touch information from Multi-Touch devices attached to your Mac.",
    "Deprecated" : [

    ],
    "type" : "Module",
    "Constructor" : [
      {
        "desc" : "Returns the touchdevice object for the default multi-touch device attached to the system",
        "stripped_doc" : [
          "Returns the touchdevice object for the default multi-touch device attached to the system",
          ""
        ],
        "name" : "default",
        "doc" : "Returns the touchdevice object for the default multi-touch device attached to the system\n\nParameters:\n * None\n\nReturns:\n * a touchdeviceObject or nil if no multi-touch devices are currently available\n\nNotes:\n * on a laptop, the default multi-touch device will be the built in trackpad; on a desktop, the default device will be the first multi-touch device detected",
        "notes" : [
          " * on a laptop, the default multi-touch device will be the built in trackpad; on a desktop, the default device will be the first multi-touch device detected"
        ],
        "signature" : "hs._asm.undocumented.touchdevice.default() -> touchdeviceObject",
        "type" : "Constructor",
        "returns" : [
          " * a touchdeviceObject or nil if no multi-touch devices are currently available",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.default() -> touchdeviceObject",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the touchdevice object for the specified device id",
        "stripped_doc" : [
          "Returns the touchdevice object for the specified device id",
          ""
        ],
        "name" : "forDeviceID",
        "doc" : "Returns the touchdevice object for the specified device id\n\nParameters:\n * `idNumber` - an integer specifying the id number of the multi-touch device to create the touchdeviceObject for\n\nReturns:\n * a touchdeviceObject or nil if no multi-touch devices with the specified id is available\n\nNotes:\n * You can get a list of currently available device ids with [hs._asm.undocumented.touchdevice.devices](#devices) or get the device id for an existing object with [hs._asm.undocumented.touchdevice:deviceID](#deviceID).",
        "notes" : [
          " * You can get a list of currently available device ids with [hs._asm.undocumented.touchdevice.devices](#devices) or get the device id for an existing object with [hs._asm.undocumented.touchdevice:deviceID](#deviceID)."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.forDeviceID(idNumber) -> touchdeviceObject",
        "type" : "Constructor",
        "returns" : [
          " * a touchdeviceObject or nil if no multi-touch devices with the specified id is available",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.forDeviceID(idNumber) -> touchdeviceObject",
        "parameters" : [
          " * `idNumber` - an integer specifying the id number of the multi-touch device to create the touchdeviceObject for",
          ""
        ]
      }
    ],
    "Field" : [
      {
        "desc" : "The table representing a touch as returned by the callback functions.  Because this module relies on an undocumented framework, these descriptions are based on the collection of observations made by a variety of people and shared on the internet -- nothing in here is guaranteed.  If you have corrected information or observe something in variance with what is documented here, please submit an issue with as much detail as possible.",
        "stripped_doc" : [
          "The table representing a touch as returned by the callback functions.  Because this module relies on an undocumented framework, these descriptions are based on the collection of observations made by a variety of people and shared on the internet -- nothing in here is guaranteed.  If you have corrected information or observe something in variance with what is documented here, please submit an issue with as much detail as possible.",
          "",
          "The table will contain the following key-value pairs:",
          "  * `frame`            - an integer specifying the observation frame this touch belongs to",
          "  * `timestamp`        - a number representing the timestamp for the touch data in seconds; the epoch (0.0 point) is uncertain, but for a given device, the number will always be increasing throughout the detection of touches for the device.",
          "  * `pathIndex`        - an integer representing the path through the various stages for a touch; as long as a specific touch has not been broken (i.e. reached the \"notTracking\" stage), it's path ID will remain constant even though it's relative position in the table of touches returned in a frame callback may differ.",
          "  * `stage`            - a string representing the stage of the touch.  May be one of the following values:",
          "    * `notTracking`   - The touch has completed and no further path updates with this pathIndex will occur",
          "    * `startInRange`  - This is a newly detected touch",
          "    * `hoverInRange`  - The touch is hovering slightly above the touch device; not always observed in a full touch path.",
          "    * `makeTouch`     - The touch has actually made full contact with the touch device; not always observed in a full touch path.",
          "    * `touching`      - The touch is established. The touch will be in this stage for the majority of its lifetime.",
          "    * `breakTouch`    - The touch has been lifted from the touch device.",
          "    * `lingerInRange` - The touch has been lifted but is still within the range of hover detection.",
          "    * `outOfRange`    - The touch has moved out of range; This may occur because the touch has ended and will be followed by a `notTracking` message or it can occur if the touch moves out of the touch sensitive area of the device; if the touch returns to the touch sensitive area quickly enough, the touch may continue with `touching` messages.  Otherwise a new touch with a new `pathIndex` and `fingerID` will be generated if the touch returns.",
          "  * `fingerID`         - an integer which appears to be related to the location of the touch device where the touch was first detected; however this is not known for certain.  Like pathIndex, this number will remain constant through the lifetime of a specific touch.",
          "  * `handID`           - an integer, usually 1, of uncertain purpose; it appears to have to do with finger grouping, but has not been observed consistently enough with a differing value to determine conclusively",
          "  * `normalizedVector` - a table representing the current postion and velocity of the touch normalized so that all values are numbers between 0.0 and 1.0",
          "    * `position` - a table representing the position of the touch",
          "      * `x` - a number from 0.0 (the left) to 1.0 (the right) indicating the horizontal position of the touch relative to the touch sensitive surface area of the touch device.",
          "      * `y` - a number from 0.0 (the bottom) to 1.0 (the top) indicating the vertical position of the touch relative to the touch sensitive surface area of the touch device.",
          "    * `velocity` - a table representing the current velocity of the changes to the touch",
          "      * `x` - a number from -1.0 to 1.0 representing the rate and direction of change to the horizontal position of the touch",
          "      * `y` - a number from -1.0 to 1.0 representing the rate and direction of change to the vertical position of the touch",
          "  * `zTotal`           - a number between 0.0 and 1.0 representing a general measure of the surface area covered by the touch; this can be used as an approximation of pressure as more of the finger will be touching as pressure increases.",
          "  * `zPressure`        - on force touch devices, this number appears to represent the relative pressure being applied with the touch; on non-force touch devices this number is 0.0.",
          "  * `angle`            - a number representing the angle of the touch ellipse",
          "  * `majorAxis`        - a number representing the major axis of the touch ellipse",
          "  * `minorAxis`        - a number representing the minor axis of the touch ellipse",
          "  * `absoluteVector`   - a table representing the current position and velocity of the touch.  Note that the possible range for the values available in this table appears to be device dependent and does not appear to be related in an obvious way to the devices surface dimensions as returned by [hs._asm.undocumented.touchdevice:surfaceDimensions](#surfaceDimensions).",
          "    * `position` - a table representing the position of the touch",
          "      * `x` - a number indicating the horizontal position of the touch. This number will be negative if the touch is in the left half of the touch sensitive surface area and positive if it is in the right half.",
          "      * `y` - a number indicating the vertical position of the touch.  This number starts at 0 at the bottom of the device and increases positively as the touch approaches the top.",
          "    * `velocity` - a table representing the current velocity of the changes to the touch",
          "      * `x` - a number representing the rate and direction of change to the horizontal position of the touch",
          "      * `y` - a number representing the rate and direction of change to the vertical position of the touch",
          "  * `zDensity`         - a number representing the density of the touch; in my observations this will fluctuate greatly for fingers but be more constant for a stylus, so it may be useful for gauging what the source of the touch is from.",
          "",
          "  * `_field14`         - an integer; currently the purpose of this field in the touch structure is unknown; at present only a value of 0 has been observed.",
          "  * `_field15`         - an integer; currently the purpose of this field in the touch structure is unknown; at present only a value of 0 has been observed."
        ],
        "name" : "touchData",
        "doc" : "The table representing a touch as returned by the callback functions.  Because this module relies on an undocumented framework, these descriptions are based on the collection of observations made by a variety of people and shared on the internet -- nothing in here is guaranteed.  If you have corrected information or observe something in variance with what is documented here, please submit an issue with as much detail as possible.\n\nThe table will contain the following key-value pairs:\n  * `frame`            - an integer specifying the observation frame this touch belongs to\n  * `timestamp`        - a number representing the timestamp for the touch data in seconds; the epoch (0.0 point) is uncertain, but for a given device, the number will always be increasing throughout the detection of touches for the device.\n  * `pathIndex`        - an integer representing the path through the various stages for a touch; as long as a specific touch has not been broken (i.e. reached the \"notTracking\" stage), it's path ID will remain constant even though it's relative position in the table of touches returned in a frame callback may differ.\n  * `stage`            - a string representing the stage of the touch.  May be one of the following values:\n    * `notTracking`   - The touch has completed and no further path updates with this pathIndex will occur\n    * `startInRange`  - This is a newly detected touch\n    * `hoverInRange`  - The touch is hovering slightly above the touch device; not always observed in a full touch path.\n    * `makeTouch`     - The touch has actually made full contact with the touch device; not always observed in a full touch path.\n    * `touching`      - The touch is established. The touch will be in this stage for the majority of its lifetime.\n    * `breakTouch`    - The touch has been lifted from the touch device.\n    * `lingerInRange` - The touch has been lifted but is still within the range of hover detection.\n    * `outOfRange`    - The touch has moved out of range; This may occur because the touch has ended and will be followed by a `notTracking` message or it can occur if the touch moves out of the touch sensitive area of the device; if the touch returns to the touch sensitive area quickly enough, the touch may continue with `touching` messages.  Otherwise a new touch with a new `pathIndex` and `fingerID` will be generated if the touch returns.\n  * `fingerID`         - an integer which appears to be related to the location of the touch device where the touch was first detected; however this is not known for certain.  Like pathIndex, this number will remain constant through the lifetime of a specific touch.\n  * `handID`           - an integer, usually 1, of uncertain purpose; it appears to have to do with finger grouping, but has not been observed consistently enough with a differing value to determine conclusively\n  * `normalizedVector` - a table representing the current postion and velocity of the touch normalized so that all values are numbers between 0.0 and 1.0\n    * `position` - a table representing the position of the touch\n      * `x` - a number from 0.0 (the left) to 1.0 (the right) indicating the horizontal position of the touch relative to the touch sensitive surface area of the touch device.\n      * `y` - a number from 0.0 (the bottom) to 1.0 (the top) indicating the vertical position of the touch relative to the touch sensitive surface area of the touch device.\n    * `velocity` - a table representing the current velocity of the changes to the touch\n      * `x` - a number from -1.0 to 1.0 representing the rate and direction of change to the horizontal position of the touch\n      * `y` - a number from -1.0 to 1.0 representing the rate and direction of change to the vertical position of the touch\n  * `zTotal`           - a number between 0.0 and 1.0 representing a general measure of the surface area covered by the touch; this can be used as an approximation of pressure as more of the finger will be touching as pressure increases.\n  * `zPressure`        - on force touch devices, this number appears to represent the relative pressure being applied with the touch; on non-force touch devices this number is 0.0.\n  * `angle`            - a number representing the angle of the touch ellipse\n  * `majorAxis`        - a number representing the major axis of the touch ellipse\n  * `minorAxis`        - a number representing the minor axis of the touch ellipse\n  * `absoluteVector`   - a table representing the current position and velocity of the touch.  Note that the possible range for the values available in this table appears to be device dependent and does not appear to be related in an obvious way to the devices surface dimensions as returned by [hs._asm.undocumented.touchdevice:surfaceDimensions](#surfaceDimensions).\n    * `position` - a table representing the position of the touch\n      * `x` - a number indicating the horizontal position of the touch. This number will be negative if the touch is in the left half of the touch sensitive surface area and positive if it is in the right half.\n      * `y` - a number indicating the vertical position of the touch.  This number starts at 0 at the bottom of the device and increases positively as the touch approaches the top.\n    * `velocity` - a table representing the current velocity of the changes to the touch\n      * `x` - a number representing the rate and direction of change to the horizontal position of the touch\n      * `y` - a number representing the rate and direction of change to the vertical position of the touch\n  * `zDensity`         - a number representing the density of the touch; in my observations this will fluctuate greatly for fingers but be more constant for a stylus, so it may be useful for gauging what the source of the touch is from.\n\n  * `_field14`         - an integer; currently the purpose of this field in the touch structure is unknown; at present only a value of 0 has been observed.\n  * `_field15`         - an integer; currently the purpose of this field in the touch structure is unknown; at present only a value of 0 has been observed.",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.touchData",
        "type" : "Field",
        "returns" : [

        ],
        "def" : "hs._asm.undocumented.touchdevice.touchData",
        "parameters" : [

        ]
      }
    ],
    "Method" : [
      {
        "desc" : "Returns a table containing a summary of the information provided by the informational methods of this module for the the multi-touch device",
        "stripped_doc" : [
          "Returns a table containing a summary of the information provided by the informational methods of this module for the the multi-touch device",
          ""
        ],
        "name" : "details",
        "doc" : "Returns a table containing a summary of the information provided by the informational methods of this module for the the multi-touch device\n\nParameters:\n * None\n\nReturns:\n * a table containing key-value pairs corresponding to most of the informational methods provided by this module for the multi-touch device represented by the touchdeviceObject.\n\nNotes:\n * The returned table uses the `hs.inspect` module as a `__tostring` metamethod allowing you to display it easily in the Hammerspoon console.\n * This method is provided as a convenience -- because it invokes a method for each key in the table, when speed is a concern, you should invoke the individual methods for the specific information that you require.",
        "notes" : [
          " * The returned table uses the `hs.inspect` module as a `__tostring` metamethod allowing you to display it easily in the Hammerspoon console.",
          " * This method is provided as a convenience -- because it invokes a method for each key in the table, when speed is a concern, you should invoke the individual methods for the specific information that you require."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:details() -> table",
        "type" : "Method",
        "returns" : [
          " * a table containing key-value pairs corresponding to most of the informational methods provided by this module for the multi-touch device represented by the touchdeviceObject.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:details() -> table",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the device ID for the multi-touch device",
        "stripped_doc" : [
          "Returns the device ID for the multi-touch device",
          ""
        ],
        "name" : "deviceID",
        "doc" : "Returns the device ID for the multi-touch device\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the device id for the multi-touch device represented by the touchdeviceObject",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice:deviceID() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the device id for the multi-touch device represented by the touchdeviceObject"
        ],
        "def" : "hs._asm.undocumented.touchdevice:deviceID() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a table containing the service details for the multitouch device as reported by the macOS IOKit freamework.",
        "stripped_doc" : [
          "Returns a table containing the service details for the multitouch device as reported by the macOS IOKit freamework.",
          ""
        ],
        "name" : "ioserviceDetails",
        "doc" : "Returns a table containing the service details for the multitouch device as reported by the macOS IOKit freamework.\n\nParameters:\n * None\n\nReturns:\n * a table containing key-value pairs containing information about the multitouch device as reported by the macOS IOKit framework..\n\nNotes:\n * This method is provided for infomration purposes only; while this method will return more information than [hs._asm.undocumented.touchdevice:details](#details) it is uncertain if the additional information will actually be useful outside the context of IOKit.",
        "notes" : [
          " * This method is provided for infomration purposes only; while this method will return more information than [hs._asm.undocumented.touchdevice:details](#details) it is uncertain if the additional information will actually be useful outside the context of IOKit."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:ioserviceDetails() -> table",
        "type" : "Method",
        "returns" : [
          " * a table containing key-value pairs containing information about the multitouch device as reported by the macOS IOKit framework..",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:ioserviceDetails() -> table",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the serial number for the multi-touch device",
        "stripped_doc" : [
          "Returns the serial number for the multi-touch device",
          ""
        ],
        "name" : "serialNumber",
        "doc" : "Returns the serial number for the multi-touch device\n\nParameters:\n * None\n\nReturns:\n * a string specifying the serial number of the multi-touch device represented by the touchdeviceObject\n\nNotes:\n * not all devices have a serial number so this value may be \"None\" or an empty string",
        "notes" : [
          " * not all devices have a serial number so this value may be \"None\" or an empty string"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:serialNumber() -> string",
        "type" : "Method",
        "returns" : [
          " * a string specifying the serial number of the multi-touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:serialNumber() -> string",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is built in",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is built in",
          ""
        ],
        "name" : "builtin",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is built in\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a built in device\n\nNotes:\n * This will be true for the trackpad built in to Mac laptops and false for any external device",
        "notes" : [
          " * This will be true for the trackpad built in to Mac laptops and false for any external device"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:builtin() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a built in device",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:builtin() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is a force touch device.",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is a force touch device.",
          ""
        ],
        "name" : "supportsForce",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is a force touch device.\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a force touch device\n\nNotes:\n * Force touch devices provide haptic feedback indicating mouse clicks rather than use an actual mechanical switch to detect mouse clicks.",
        "notes" : [
          " * Force touch devices provide haptic feedback indicating mouse clicks rather than use an actual mechanical switch to detect mouse clicks."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:supportsForce() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a force touch device",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:supportsForce() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device contains an actuator",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device contains an actuator",
          ""
        ],
        "name" : "supportsActuation",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device contains an actuator\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject contains an actuator\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.\n\n * The MultitouchSupport framework does provide undocumented functions for accessing the actuator directly, but so far I've found no examples to start experimenting with.  Further investigation is being considered but is not currently underway.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
          "",
          " * The MultitouchSupport framework does provide undocumented functions for accessing the actuator directly, but so far I've found no examples to start experimenting with.  Further investigation is being considered but is not currently underway."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:supportsActuation() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject contains an actuator",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:supportsActuation() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is an opaque surface",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is an opaque surface",
          ""
        ],
        "name" : "opaqueSurface",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is an opaque surface\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is an opaque surface\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.\n\n * This value appears to always be false unless the device is being watched for touch callbacks.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
          "",
          " * This value appears to always be false unless the device is being watched for touch callbacks."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:opaqueSurface() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is an opaque surface",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:opaqueSurface() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is being monitored and generates callbacks for touch activity",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is being monitored and generates callbacks for touch activity",
          ""
        ],
        "name" : "running",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is being monitored and generates callbacks for touch activity\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is being monitored and generates callbacks for touch activity\n\nNotes:\n * See [hs._asm.undocumented.touchdevice:start](#start) and [hs._asm.undocumented.touchdevice:stop](#stop)",
        "notes" : [
          " * See [hs._asm.undocumented.touchdevice:start](#start) and [hs._asm.undocumented.touchdevice:stop](#stop)"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:running() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is being monitored and generates callbacks for touch activity",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:running() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is alive",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is alive",
          ""
        ],
        "name" : "alive",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is alive\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is alive\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.\n * I have only observed this as returning false; please submit details if you observe a different value.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
          " * I have only observed this as returning false; please submit details if you observe a different value."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:alive() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is alive",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:alive() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is a HID device",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is a HID device",
          ""
        ],
        "name" : "MTHIDDevice",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is a HID device\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a HID device\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:MTHIDDevice() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a HID device",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:MTHIDDevice() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device driver is ready",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device driver is ready",
          ""
        ],
        "name" : "driverReady",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device driver is ready\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the driver for the multi-touch device represented by the touchdeviceObject is ready\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:driverReady() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the driver for the multi-touch device represented by the touchdeviceObject is ready",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:driverReady() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device supports power control",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device supports power control",
          ""
        ],
        "name" : "supportsPowerControl",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device supports power control\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject supports power control\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.\n * I have only observed this as returning false; please submit details if you observe a different value.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
          " * I have only observed this as returning false; please submit details if you observe a different value."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:supportsPowerControl() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject supports power control",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:supportsPowerControl() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the product name for the touch device as it is registered with the IOKit HID subsystem",
        "stripped_doc" : [
          "Returns the product name for the touch device as it is registered with the IOKit HID subsystem",
          ""
        ],
        "name" : "productName",
        "doc" : "Returns the product name for the touch device as it is registered with the IOKit HID subsystem\n\nParameters:\n * None\n\nReturns:\n * a string specifying the product name for the touch device represented by the touchdeviceObject as registered with the IOKit HID subsystem.\n\nNotes:\n * this information is purely informational and may be useful in differentiating multiple devices attached to the same machine\n * some devices return a name corresponding to the marketting name for the device while others return a name created by the macOS generated when the device is first paired with the machine, usually the user's login name followed by \"Mouse\" or \"Trackpad\".  At this time, it is unknown if there is an independant way to determine which pattern a given device's product name will follow or if there is a way to return the marketting name for an otherwise named device; if someone more familiar with IOKit, especially with regards to HID devices has any thoughts on the matter, please submit an issue for consideration.",
        "notes" : [
          " * this information is purely informational and may be useful in differentiating multiple devices attached to the same machine",
          " * some devices return a name corresponding to the marketting name for the device while others return a name created by the macOS generated when the device is first paired with the machine, usually the user's login name followed by \"Mouse\" or \"Trackpad\".  At this time, it is unknown if there is an independant way to determine which pattern a given device's product name will follow or if there is a way to return the marketting name for an otherwise named device; if someone more familiar with IOKit, especially with regards to HID devices has any thoughts on the matter, please submit an issue for consideration."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:productName() -> string",
        "type" : "Method",
        "returns" : [
          " * a string specifying the product name for the touch device represented by the touchdeviceObject as registered with the IOKit HID subsystem.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:productName() -> string",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the dimensions of the space on the touch device that can detect a touch",
        "stripped_doc" : [
          "Returns the dimensions of the space on the touch device that can detect a touch",
          ""
        ],
        "name" : "sensorDimensions",
        "doc" : "Returns the dimensions of the space on the touch device that can detect a touch\n\nParameters:\n * `inHmm` - a boolean, default true, specifying whether the dimensions should be returned in hundredths of a millimeter (true) or as rows and columns (false)\n\nReturns:\n * a size table containing the sensor area dimensions where the height is the value assigned to the `h` key and the width is assigned to the `w` key.\n\nNotes:\n * At present, the usefulness of the row\/column dimension values is currently unknown and it is being provided for information purposes only\n   * The row\/column values seem to correspond to a grid used by the MultitouchSupport framework to differentiate between nearby touches and the exact size of each \"cell\" appears to be device dependent as the ratios between rows and columns versus the height and width as returned in hundredths of a millimeter is not consistent across devices.",
        "notes" : [
          " * At present, the usefulness of the row\/column dimension values is currently unknown and it is being provided for information purposes only",
          "   * The row\/column values seem to correspond to a grid used by the MultitouchSupport framework to differentiate between nearby touches and the exact size of each \"cell\" appears to be device dependent as the ratios between rows and columns versus the height and width as returned in hundredths of a millimeter is not consistent across devices."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:sensorDimensions([inHmm]) -> sizeTable",
        "type" : "Method",
        "returns" : [
          " * a size table containing the sensor area dimensions where the height is the value assigned to the `h` key and the width is assigned to the `w` key.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:sensorDimensions([inHmm]) -> sizeTable",
        "parameters" : [
          " * `inHmm` - a boolean, default true, specifying whether the dimensions should be returned in hundredths of a millimeter (true) or as rows and columns (false)",
          ""
        ]
      },
      {
        "desc" : "Returns an integer specifying the device family id for the touch device represented by the touchdeviceObject",
        "stripped_doc" : [
          "Returns an integer specifying the device family id for the touch device represented by the touchdeviceObject",
          ""
        ],
        "name" : "familyID",
        "doc" : "Returns an integer specifying the device family id for the touch device represented by the touchdeviceObject\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the device family id for the touch device represented by the touchdeviceObject\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:familyID() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the device family id for the touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:familyID() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject",
        "stripped_doc" : [
          "Returns an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject",
          ""
        ],
        "name" : "version",
        "doc" : "Returns an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:version() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:version() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns an integer specifying the driver type for the touch device represented by the touchdeviceObject",
        "stripped_doc" : [
          "Returns an integer specifying the driver type for the touch device represented by the touchdeviceObject",
          ""
        ],
        "name" : "driverType",
        "doc" : "Returns an integer specifying the driver type for the touch device represented by the touchdeviceObject\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the driver type for the touch device represented by the touchdeviceObject\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:driverType() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the driver type for the touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:driverType() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click",
        "stripped_doc" : [
          "Returns a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click",
          ""
        ],
        "name" : "supportsSilentClick",
        "doc" : "Returns a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click\n\nParameters:\n * None\n\nReturns:\n * a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click\n\nNotes:\n * This method will return true for non force-touch devices -- they do not have a simulated click sound associated with mouse clicks so they are considered \"silent\" by the MultitouchSupport framework already.\n * Some force touch devices do not support disabling this simulated sound and will return false with this method; this seems to mostly apply to newer Mac Pro laptops, though an exhaustive list is beyond the scope of this documentation.  If you are uncertain about your force touch device, check Trackpad in System Preferences -- if you see an option for \"Silent clicking\" then this method should return true for your force touch device.",
        "notes" : [
          " * This method will return true for non force-touch devices -- they do not have a simulated click sound associated with mouse clicks so they are considered \"silent\" by the MultitouchSupport framework already.",
          " * Some force touch devices do not support disabling this simulated sound and will return false with this method; this seems to mostly apply to newer Mac Pro laptops, though an exhaustive list is beyond the scope of this documentation.  If you are uncertain about your force touch device, check Trackpad in System Preferences -- if you see an option for \"Silent clicking\" then this method should return true for your force touch device."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:supportsSilentClick() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:supportsSilentClick() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a string specifying the GUID for the touch device represented by the touchdeviceObject",
        "stripped_doc" : [
          "Returns a string specifying the GUID for the touch device represented by the touchdeviceObject",
          ""
        ],
        "name" : "GUID",
        "doc" : "Returns a string specifying the GUID for the touch device represented by the touchdeviceObject\n\nParameters:\n * None\n\nReturns:\n * a string specifying the GUID for the touch device represented by the touchdeviceObject\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:GUID() -> string",
        "type" : "Method",
        "returns" : [
          " * a string specifying the GUID for the touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:GUID() -> string",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Get or set whether applying pressure to a force touch capable device will generate a mouse click or force touch",
        "stripped_doc" : [
          "Get or set whether applying pressure to a force touch capable device will generate a mouse click or force touch",
          ""
        ],
        "name" : "forceResponseEnabled",
        "doc" : "Get or set whether applying pressure to a force touch capable device will generate a mouse click or force touch\n\nParameters:\n * `state` - an optional boolean specifying whether the force touch capable touch device will generate mouse clicks and force touches (true) or not (false).\n\nReturns:\n * if an argument is provided, returns the touchdeviceObject, otherwise returns the current value\n\nNotes:\n * When used with a non force touch device, the results of using this method are undefined - some will apparently change their value in response to this method while others will not; however the mouse click ability of the touch device will not be affected.\n\n * When used with a force touch capable device, setting this value to false will prevent the device from being able to generate mouse clicks; multi touch gestures and mouse movement is unaffected however.\n * This can be used to make such a device act more like a drawing tablet where the pressure can be used as a Z-axis without fear that a mouse click will change application focus or have other effects.\n * ***WARNING*** - if you disable mouse clicks for a device with this method, it is re-enabled upon garbage collection of the userdata representing the touch device. This means:\n   * You must retain the userdata in a global variable (or local variable with an upvalue reference within a global function or table) for at least as long as you wish for mouse clicks to be suppressed.\n   * If you have multiple userdata objects for the *same* touch device created independently (with separate [hs._asm.undocumented.touchdevice.default](#default) or [hs._asm.undocumented.touchdevice.forDeviceID](#forDeviceID) function invocations), when any of them go out of scope and is garbage collected, mouse clicks will be re-enabled for the device.\n   * If Hammerspoon crashes or exits unexpectedly, it is likely that garbage collection will not occur.  In this case, you will have to restart Hammerspoon and use this method to re-enable mouse clicks or disconnect and reconnect your device (if it is external) or restart your machine (if it is not) to return the device to normal functionality.\n * For these reasons, it is recommended that you only disable force response for as short a period as you require and the re-enable them so that everything remains in a predictable state.\n\n * If you wish to suspend mouse gestures as well, you can use `hs.execute(\"killall -STOP Dock\")`.  Note however that this disables gestures for *ALL* touch devices and also disables application switching from the keyboard as well (you can still click on an another applications windows with another mouse device though). You can resume normal operation of the gestures and keyboard shortcuts with `hs.execute(\"killall -CONT Dock\")`. It is unknown what other processes suspending the Dock in this way may cause, so do so at your own risk.",
        "notes" : [
          " * When used with a non force touch device, the results of using this method are undefined - some will apparently change their value in response to this method while others will not; however the mouse click ability of the touch device will not be affected.",
          "",
          " * When used with a force touch capable device, setting this value to false will prevent the device from being able to generate mouse clicks; multi touch gestures and mouse movement is unaffected however.",
          " * This can be used to make such a device act more like a drawing tablet where the pressure can be used as a Z-axis without fear that a mouse click will change application focus or have other effects.",
          " * ***WARNING*** - if you disable mouse clicks for a device with this method, it is re-enabled upon garbage collection of the userdata representing the touch device. This means:",
          "   * You must retain the userdata in a global variable (or local variable with an upvalue reference within a global function or table) for at least as long as you wish for mouse clicks to be suppressed.",
          "   * If you have multiple userdata objects for the *same* touch device created independently (with separate [hs._asm.undocumented.touchdevice.default](#default) or [hs._asm.undocumented.touchdevice.forDeviceID](#forDeviceID) function invocations), when any of them go out of scope and is garbage collected, mouse clicks will be re-enabled for the device.",
          "   * If Hammerspoon crashes or exits unexpectedly, it is likely that garbage collection will not occur.  In this case, you will have to restart Hammerspoon and use this method to re-enable mouse clicks or disconnect and reconnect your device (if it is external) or restart your machine (if it is not) to return the device to normal functionality.",
          " * For these reasons, it is recommended that you only disable force response for as short a period as you require and the re-enable them so that everything remains in a predictable state.",
          "",
          " * If you wish to suspend mouse gestures as well, you can use `hs.execute(\"killall -STOP Dock\")`.  Note however that this disables gestures for *ALL* touch devices and also disables application switching from the keyboard as well (you can still click on an another applications windows with another mouse device though). You can resume normal operation of the gestures and keyboard shortcuts with `hs.execute(\"killall -CONT Dock\")`. It is unknown what other processes suspending the Dock in this way may cause, so do so at your own risk."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:forceResponseEnabled([state]) -> touchdeviceObject | boolean",
        "type" : "Method",
        "returns" : [
          " * if an argument is provided, returns the touchdeviceObject, otherwise returns the current value",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:forceResponseEnabled([state]) -> touchdeviceObject | boolean",
        "parameters" : [
          " * `state` - an optional boolean specifying whether the force touch capable touch device will generate mouse clicks and force touches (true) or not (false).",
          ""
        ]
      },
      {
        "desc" : "Get or set the frame callback function for the touch device represented by the touchdevice object",
        "stripped_doc" : [
          "Get or set the frame callback function for the touch device represented by the touchdevice object",
          ""
        ],
        "name" : "frameCallback",
        "doc" : "Get or set the frame callback function for the touch device represented by the touchdevice object\n\nParameters:\n * `fn` - an optional function or nil to set (or remove) the frame callback function for the touch device.\n\nReturns:\n * if an argument is provided, returns the touchdeviceObject; otherwise returns the current value which may be a function or nil if no frame callback is currently assigned.\n\nNotes:\n * The frame callback appears to represent a point in time and contains touch data for all touches currently active for the device\n\n * the callback function should expect 4 arguments and return none.  The arguments will be as follows:\n   * `self`      - the touch device object for which the callback is being invoked for\n   * `touch`     - a table containing an array of touch tables as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) for each of the current touches detected by the touch device.\n   * `timestamp` - a number specifying the timestamp for the frame.\n   * `frame`     - an integer specifying the frame ID",
        "notes" : [
          " * The frame callback appears to represent a point in time and contains touch data for all touches currently active for the device",
          "",
          " * the callback function should expect 4 arguments and return none.  The arguments will be as follows:",
          "   * `self`      - the touch device object for which the callback is being invoked for",
          "   * `touch`     - a table containing an array of touch tables as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) for each of the current touches detected by the touch device.",
          "   * `timestamp` - a number specifying the timestamp for the frame.",
          "   * `frame`     - an integer specifying the frame ID"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:frameCallback([fn]) -> touchdeviceObject | fn",
        "type" : "Method",
        "returns" : [
          " * if an argument is provided, returns the touchdeviceObject; otherwise returns the current value which may be a function or nil if no frame callback is currently assigned.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:frameCallback([fn]) -> touchdeviceObject | fn",
        "parameters" : [
          " * `fn` - an optional function or nil to set (or remove) the frame callback function for the touch device.",
          ""
        ]
      },
      {
        "desc" : "Get or set the path callback function for the touch device represented by the touchdevice object",
        "stripped_doc" : [
          "Get or set the path callback function for the touch device represented by the touchdevice object",
          ""
        ],
        "name" : "pathCallback",
        "doc" : "Get or set the path callback function for the touch device represented by the touchdevice object\n\nParameters:\n * `fn` - an optional function or nil to set (or remove) the path callback function for the touch device.\n\nReturns:\n * if an argument is provided, returns the touchdeviceObject; otherwise returns the current value which may be a function or nil if no path callback is currently assigned.\n\nNotes:\n * The path callback appears to represent the changing data for a specific touch.  Use the `pathIndex` and `stage` as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) to link callbacks when tracking a specific touch.\n\n * the callback function should expect 4 arguments and return none.  The arguments will be as follows:\n   * `self`      - the touch device object for which the callback is being invoked for\n   * `pathIndex` - an integer specifying the pathIndex for the touch.\n   * `stage`     - a string representing the current stage of the touch. Will be one of \"notTracking\", \"startInRange\", \"hoverInRange\", \"makeTouch\", \"touching\", \"breakTouch\", \"lingerInRange\", or \"outOfRange\".\n   * `touch`     - a touch tables as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) for the specific touch",
        "notes" : [
          " * The path callback appears to represent the changing data for a specific touch.  Use the `pathIndex` and `stage` as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) to link callbacks when tracking a specific touch.",
          "",
          " * the callback function should expect 4 arguments and return none.  The arguments will be as follows:",
          "   * `self`      - the touch device object for which the callback is being invoked for",
          "   * `pathIndex` - an integer specifying the pathIndex for the touch.",
          "   * `stage`     - a string representing the current stage of the touch. Will be one of \"notTracking\", \"startInRange\", \"hoverInRange\", \"makeTouch\", \"touching\", \"breakTouch\", \"lingerInRange\", or \"outOfRange\".",
          "   * `touch`     - a touch tables as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) for the specific touch"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:pathCallback([fn]) -> touchdeviceObject | fn",
        "type" : "Method",
        "returns" : [
          " * if an argument is provided, returns the touchdeviceObject; otherwise returns the current value which may be a function or nil if no path callback is currently assigned.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:pathCallback([fn]) -> touchdeviceObject | fn",
        "parameters" : [
          " * `fn` - an optional function or nil to set (or remove) the path callback function for the touch device.",
          ""
        ]
      },
      {
        "desc" : "Begin tracking touch data from the touch device.",
        "stripped_doc" : [
          "Begin tracking touch data from the touch device.",
          ""
        ],
        "name" : "start",
        "doc" : "Begin tracking touch data from the touch device.\n\nParameters:\n * None\n\nReturns:\n * the touchdeviceObject",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice:start() -> touchdeviceObject",
        "type" : "Method",
        "returns" : [
          " * the touchdeviceObject"
        ],
        "def" : "hs._asm.undocumented.touchdevice:start() -> touchdeviceObject",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Stop tracking touch data from the touch device.",
        "stripped_doc" : [
          "Stop tracking touch data from the touch device.",
          ""
        ],
        "name" : "stop",
        "doc" : "Stop tracking touch data from the touch device.\n\nParameters:\n * None\n\nReturns:\n * the touchdeviceObject",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice:stop() -> touchdeviceObject",
        "type" : "Method",
        "returns" : [
          " * the touchdeviceObject"
        ],
        "def" : "hs._asm.undocumented.touchdevice:stop() -> touchdeviceObject",
        "parameters" : [
          " * None",
          ""
        ]
      }
    ],
    "Command" : [

    ],
    "items" : [
      {
        "desc" : "Returns a number specifying the time in seconds since the last system reboot.",
        "stripped_doc" : [
          "Returns a number specifying the time in seconds since the last system reboot.",
          ""
        ],
        "name" : "absoluteTime",
        "doc" : "Returns a number specifying the time in seconds since the last system reboot.\n\nParameters:\n * None\n\nReturns:\n * a number specifying the time in seconds since the last system reboot",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.absoluteTime() -> number",
        "type" : "Function",
        "returns" : [
          " * a number specifying the time in seconds since the last system reboot"
        ],
        "def" : "hs._asm.undocumented.touchdevice.absoluteTime() -> number",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns whether or not a multi-touch device is currently attached to the system.",
        "stripped_doc" : [
          "Returns whether or not a multi-touch device is currently attached to the system.",
          ""
        ],
        "name" : "available",
        "doc" : "Returns whether or not a multi-touch device is currently attached to the system.\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not a multi-touch device is currently attached to the system\n\nNotes:\n * multi-touch devices include the built-in trackpad found on any modern Mac laptop, the Magic Mouse, and the Magic Trackpad.",
        "notes" : [
          " * multi-touch devices include the built-in trackpad found on any modern Mac laptop, the Magic Mouse, and the Magic Trackpad."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.available() -> boolean",
        "type" : "Function",
        "returns" : [
          " * a boolean value indicating whether or not a multi-touch device is currently attached to the system",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.available() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a list of the device id's for all currently available multi-touch devices",
        "stripped_doc" : [
          "Returns a list of the device id's for all currently available multi-touch devices",
          ""
        ],
        "name" : "devices",
        "doc" : "Returns a list of the device id's for all currently available multi-touch devices\n\nParameters:\n * None\n\nReturns:\n * a table as an array containing the device id's of all currently attached\/available multi-touch devices",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.devices() -> table",
        "type" : "Function",
        "returns" : [
          " * a table as an array containing the device id's of all currently attached\/available multi-touch devices"
        ],
        "def" : "hs._asm.undocumented.touchdevice.devices() -> table",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the touchdevice object for the default multi-touch device attached to the system",
        "stripped_doc" : [
          "Returns the touchdevice object for the default multi-touch device attached to the system",
          ""
        ],
        "name" : "default",
        "doc" : "Returns the touchdevice object for the default multi-touch device attached to the system\n\nParameters:\n * None\n\nReturns:\n * a touchdeviceObject or nil if no multi-touch devices are currently available\n\nNotes:\n * on a laptop, the default multi-touch device will be the built in trackpad; on a desktop, the default device will be the first multi-touch device detected",
        "notes" : [
          " * on a laptop, the default multi-touch device will be the built in trackpad; on a desktop, the default device will be the first multi-touch device detected"
        ],
        "signature" : "hs._asm.undocumented.touchdevice.default() -> touchdeviceObject",
        "type" : "Constructor",
        "returns" : [
          " * a touchdeviceObject or nil if no multi-touch devices are currently available",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.default() -> touchdeviceObject",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the touchdevice object for the specified device id",
        "stripped_doc" : [
          "Returns the touchdevice object for the specified device id",
          ""
        ],
        "name" : "forDeviceID",
        "doc" : "Returns the touchdevice object for the specified device id\n\nParameters:\n * `idNumber` - an integer specifying the id number of the multi-touch device to create the touchdeviceObject for\n\nReturns:\n * a touchdeviceObject or nil if no multi-touch devices with the specified id is available\n\nNotes:\n * You can get a list of currently available device ids with [hs._asm.undocumented.touchdevice.devices](#devices) or get the device id for an existing object with [hs._asm.undocumented.touchdevice:deviceID](#deviceID).",
        "notes" : [
          " * You can get a list of currently available device ids with [hs._asm.undocumented.touchdevice.devices](#devices) or get the device id for an existing object with [hs._asm.undocumented.touchdevice:deviceID](#deviceID)."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.forDeviceID(idNumber) -> touchdeviceObject",
        "type" : "Constructor",
        "returns" : [
          " * a touchdeviceObject or nil if no multi-touch devices with the specified id is available",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.forDeviceID(idNumber) -> touchdeviceObject",
        "parameters" : [
          " * `idNumber` - an integer specifying the id number of the multi-touch device to create the touchdeviceObject for",
          ""
        ]
      },
      {
        "desc" : "The table representing a touch as returned by the callback functions.  Because this module relies on an undocumented framework, these descriptions are based on the collection of observations made by a variety of people and shared on the internet -- nothing in here is guaranteed.  If you have corrected information or observe something in variance with what is documented here, please submit an issue with as much detail as possible.",
        "stripped_doc" : [
          "The table representing a touch as returned by the callback functions.  Because this module relies on an undocumented framework, these descriptions are based on the collection of observations made by a variety of people and shared on the internet -- nothing in here is guaranteed.  If you have corrected information or observe something in variance with what is documented here, please submit an issue with as much detail as possible.",
          "",
          "The table will contain the following key-value pairs:",
          "  * `frame`            - an integer specifying the observation frame this touch belongs to",
          "  * `timestamp`        - a number representing the timestamp for the touch data in seconds; the epoch (0.0 point) is uncertain, but for a given device, the number will always be increasing throughout the detection of touches for the device.",
          "  * `pathIndex`        - an integer representing the path through the various stages for a touch; as long as a specific touch has not been broken (i.e. reached the \"notTracking\" stage), it's path ID will remain constant even though it's relative position in the table of touches returned in a frame callback may differ.",
          "  * `stage`            - a string representing the stage of the touch.  May be one of the following values:",
          "    * `notTracking`   - The touch has completed and no further path updates with this pathIndex will occur",
          "    * `startInRange`  - This is a newly detected touch",
          "    * `hoverInRange`  - The touch is hovering slightly above the touch device; not always observed in a full touch path.",
          "    * `makeTouch`     - The touch has actually made full contact with the touch device; not always observed in a full touch path.",
          "    * `touching`      - The touch is established. The touch will be in this stage for the majority of its lifetime.",
          "    * `breakTouch`    - The touch has been lifted from the touch device.",
          "    * `lingerInRange` - The touch has been lifted but is still within the range of hover detection.",
          "    * `outOfRange`    - The touch has moved out of range; This may occur because the touch has ended and will be followed by a `notTracking` message or it can occur if the touch moves out of the touch sensitive area of the device; if the touch returns to the touch sensitive area quickly enough, the touch may continue with `touching` messages.  Otherwise a new touch with a new `pathIndex` and `fingerID` will be generated if the touch returns.",
          "  * `fingerID`         - an integer which appears to be related to the location of the touch device where the touch was first detected; however this is not known for certain.  Like pathIndex, this number will remain constant through the lifetime of a specific touch.",
          "  * `handID`           - an integer, usually 1, of uncertain purpose; it appears to have to do with finger grouping, but has not been observed consistently enough with a differing value to determine conclusively",
          "  * `normalizedVector` - a table representing the current postion and velocity of the touch normalized so that all values are numbers between 0.0 and 1.0",
          "    * `position` - a table representing the position of the touch",
          "      * `x` - a number from 0.0 (the left) to 1.0 (the right) indicating the horizontal position of the touch relative to the touch sensitive surface area of the touch device.",
          "      * `y` - a number from 0.0 (the bottom) to 1.0 (the top) indicating the vertical position of the touch relative to the touch sensitive surface area of the touch device.",
          "    * `velocity` - a table representing the current velocity of the changes to the touch",
          "      * `x` - a number from -1.0 to 1.0 representing the rate and direction of change to the horizontal position of the touch",
          "      * `y` - a number from -1.0 to 1.0 representing the rate and direction of change to the vertical position of the touch",
          "  * `zTotal`           - a number between 0.0 and 1.0 representing a general measure of the surface area covered by the touch; this can be used as an approximation of pressure as more of the finger will be touching as pressure increases.",
          "  * `zPressure`        - on force touch devices, this number appears to represent the relative pressure being applied with the touch; on non-force touch devices this number is 0.0.",
          "  * `angle`            - a number representing the angle of the touch ellipse",
          "  * `majorAxis`        - a number representing the major axis of the touch ellipse",
          "  * `minorAxis`        - a number representing the minor axis of the touch ellipse",
          "  * `absoluteVector`   - a table representing the current position and velocity of the touch.  Note that the possible range for the values available in this table appears to be device dependent and does not appear to be related in an obvious way to the devices surface dimensions as returned by [hs._asm.undocumented.touchdevice:surfaceDimensions](#surfaceDimensions).",
          "    * `position` - a table representing the position of the touch",
          "      * `x` - a number indicating the horizontal position of the touch. This number will be negative if the touch is in the left half of the touch sensitive surface area and positive if it is in the right half.",
          "      * `y` - a number indicating the vertical position of the touch.  This number starts at 0 at the bottom of the device and increases positively as the touch approaches the top.",
          "    * `velocity` - a table representing the current velocity of the changes to the touch",
          "      * `x` - a number representing the rate and direction of change to the horizontal position of the touch",
          "      * `y` - a number representing the rate and direction of change to the vertical position of the touch",
          "  * `zDensity`         - a number representing the density of the touch; in my observations this will fluctuate greatly for fingers but be more constant for a stylus, so it may be useful for gauging what the source of the touch is from.",
          "",
          "  * `_field14`         - an integer; currently the purpose of this field in the touch structure is unknown; at present only a value of 0 has been observed.",
          "  * `_field15`         - an integer; currently the purpose of this field in the touch structure is unknown; at present only a value of 0 has been observed."
        ],
        "name" : "touchData",
        "doc" : "The table representing a touch as returned by the callback functions.  Because this module relies on an undocumented framework, these descriptions are based on the collection of observations made by a variety of people and shared on the internet -- nothing in here is guaranteed.  If you have corrected information or observe something in variance with what is documented here, please submit an issue with as much detail as possible.\n\nThe table will contain the following key-value pairs:\n  * `frame`            - an integer specifying the observation frame this touch belongs to\n  * `timestamp`        - a number representing the timestamp for the touch data in seconds; the epoch (0.0 point) is uncertain, but for a given device, the number will always be increasing throughout the detection of touches for the device.\n  * `pathIndex`        - an integer representing the path through the various stages for a touch; as long as a specific touch has not been broken (i.e. reached the \"notTracking\" stage), it's path ID will remain constant even though it's relative position in the table of touches returned in a frame callback may differ.\n  * `stage`            - a string representing the stage of the touch.  May be one of the following values:\n    * `notTracking`   - The touch has completed and no further path updates with this pathIndex will occur\n    * `startInRange`  - This is a newly detected touch\n    * `hoverInRange`  - The touch is hovering slightly above the touch device; not always observed in a full touch path.\n    * `makeTouch`     - The touch has actually made full contact with the touch device; not always observed in a full touch path.\n    * `touching`      - The touch is established. The touch will be in this stage for the majority of its lifetime.\n    * `breakTouch`    - The touch has been lifted from the touch device.\n    * `lingerInRange` - The touch has been lifted but is still within the range of hover detection.\n    * `outOfRange`    - The touch has moved out of range; This may occur because the touch has ended and will be followed by a `notTracking` message or it can occur if the touch moves out of the touch sensitive area of the device; if the touch returns to the touch sensitive area quickly enough, the touch may continue with `touching` messages.  Otherwise a new touch with a new `pathIndex` and `fingerID` will be generated if the touch returns.\n  * `fingerID`         - an integer which appears to be related to the location of the touch device where the touch was first detected; however this is not known for certain.  Like pathIndex, this number will remain constant through the lifetime of a specific touch.\n  * `handID`           - an integer, usually 1, of uncertain purpose; it appears to have to do with finger grouping, but has not been observed consistently enough with a differing value to determine conclusively\n  * `normalizedVector` - a table representing the current postion and velocity of the touch normalized so that all values are numbers between 0.0 and 1.0\n    * `position` - a table representing the position of the touch\n      * `x` - a number from 0.0 (the left) to 1.0 (the right) indicating the horizontal position of the touch relative to the touch sensitive surface area of the touch device.\n      * `y` - a number from 0.0 (the bottom) to 1.0 (the top) indicating the vertical position of the touch relative to the touch sensitive surface area of the touch device.\n    * `velocity` - a table representing the current velocity of the changes to the touch\n      * `x` - a number from -1.0 to 1.0 representing the rate and direction of change to the horizontal position of the touch\n      * `y` - a number from -1.0 to 1.0 representing the rate and direction of change to the vertical position of the touch\n  * `zTotal`           - a number between 0.0 and 1.0 representing a general measure of the surface area covered by the touch; this can be used as an approximation of pressure as more of the finger will be touching as pressure increases.\n  * `zPressure`        - on force touch devices, this number appears to represent the relative pressure being applied with the touch; on non-force touch devices this number is 0.0.\n  * `angle`            - a number representing the angle of the touch ellipse\n  * `majorAxis`        - a number representing the major axis of the touch ellipse\n  * `minorAxis`        - a number representing the minor axis of the touch ellipse\n  * `absoluteVector`   - a table representing the current position and velocity of the touch.  Note that the possible range for the values available in this table appears to be device dependent and does not appear to be related in an obvious way to the devices surface dimensions as returned by [hs._asm.undocumented.touchdevice:surfaceDimensions](#surfaceDimensions).\n    * `position` - a table representing the position of the touch\n      * `x` - a number indicating the horizontal position of the touch. This number will be negative if the touch is in the left half of the touch sensitive surface area and positive if it is in the right half.\n      * `y` - a number indicating the vertical position of the touch.  This number starts at 0 at the bottom of the device and increases positively as the touch approaches the top.\n    * `velocity` - a table representing the current velocity of the changes to the touch\n      * `x` - a number representing the rate and direction of change to the horizontal position of the touch\n      * `y` - a number representing the rate and direction of change to the vertical position of the touch\n  * `zDensity`         - a number representing the density of the touch; in my observations this will fluctuate greatly for fingers but be more constant for a stylus, so it may be useful for gauging what the source of the touch is from.\n\n  * `_field14`         - an integer; currently the purpose of this field in the touch structure is unknown; at present only a value of 0 has been observed.\n  * `_field15`         - an integer; currently the purpose of this field in the touch structure is unknown; at present only a value of 0 has been observed.",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.touchData",
        "type" : "Field",
        "returns" : [

        ],
        "def" : "hs._asm.undocumented.touchdevice.touchData",
        "parameters" : [

        ]
      },
      {
        "desc" : "Returns a string specifying the GUID for the touch device represented by the touchdeviceObject",
        "stripped_doc" : [
          "Returns a string specifying the GUID for the touch device represented by the touchdeviceObject",
          ""
        ],
        "name" : "GUID",
        "doc" : "Returns a string specifying the GUID for the touch device represented by the touchdeviceObject\n\nParameters:\n * None\n\nReturns:\n * a string specifying the GUID for the touch device represented by the touchdeviceObject\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:GUID() -> string",
        "type" : "Method",
        "returns" : [
          " * a string specifying the GUID for the touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:GUID() -> string",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is a HID device",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is a HID device",
          ""
        ],
        "name" : "MTHIDDevice",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is a HID device\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a HID device\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:MTHIDDevice() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a HID device",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:MTHIDDevice() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is alive",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is alive",
          ""
        ],
        "name" : "alive",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is alive\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is alive\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.\n * I have only observed this as returning false; please submit details if you observe a different value.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
          " * I have only observed this as returning false; please submit details if you observe a different value."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:alive() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is alive",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:alive() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is built in",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is built in",
          ""
        ],
        "name" : "builtin",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is built in\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a built in device\n\nNotes:\n * This will be true for the trackpad built in to Mac laptops and false for any external device",
        "notes" : [
          " * This will be true for the trackpad built in to Mac laptops and false for any external device"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:builtin() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a built in device",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:builtin() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a table containing a summary of the information provided by the informational methods of this module for the the multi-touch device",
        "stripped_doc" : [
          "Returns a table containing a summary of the information provided by the informational methods of this module for the the multi-touch device",
          ""
        ],
        "name" : "details",
        "doc" : "Returns a table containing a summary of the information provided by the informational methods of this module for the the multi-touch device\n\nParameters:\n * None\n\nReturns:\n * a table containing key-value pairs corresponding to most of the informational methods provided by this module for the multi-touch device represented by the touchdeviceObject.\n\nNotes:\n * The returned table uses the `hs.inspect` module as a `__tostring` metamethod allowing you to display it easily in the Hammerspoon console.\n * This method is provided as a convenience -- because it invokes a method for each key in the table, when speed is a concern, you should invoke the individual methods for the specific information that you require.",
        "notes" : [
          " * The returned table uses the `hs.inspect` module as a `__tostring` metamethod allowing you to display it easily in the Hammerspoon console.",
          " * This method is provided as a convenience -- because it invokes a method for each key in the table, when speed is a concern, you should invoke the individual methods for the specific information that you require."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:details() -> table",
        "type" : "Method",
        "returns" : [
          " * a table containing key-value pairs corresponding to most of the informational methods provided by this module for the multi-touch device represented by the touchdeviceObject.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:details() -> table",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the device ID for the multi-touch device",
        "stripped_doc" : [
          "Returns the device ID for the multi-touch device",
          ""
        ],
        "name" : "deviceID",
        "doc" : "Returns the device ID for the multi-touch device\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the device id for the multi-touch device represented by the touchdeviceObject",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice:deviceID() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the device id for the multi-touch device represented by the touchdeviceObject"
        ],
        "def" : "hs._asm.undocumented.touchdevice:deviceID() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device driver is ready",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device driver is ready",
          ""
        ],
        "name" : "driverReady",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device driver is ready\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the driver for the multi-touch device represented by the touchdeviceObject is ready\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:driverReady() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the driver for the multi-touch device represented by the touchdeviceObject is ready",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:driverReady() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns an integer specifying the driver type for the touch device represented by the touchdeviceObject",
        "stripped_doc" : [
          "Returns an integer specifying the driver type for the touch device represented by the touchdeviceObject",
          ""
        ],
        "name" : "driverType",
        "doc" : "Returns an integer specifying the driver type for the touch device represented by the touchdeviceObject\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the driver type for the touch device represented by the touchdeviceObject\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:driverType() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the driver type for the touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:driverType() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns an integer specifying the device family id for the touch device represented by the touchdeviceObject",
        "stripped_doc" : [
          "Returns an integer specifying the device family id for the touch device represented by the touchdeviceObject",
          ""
        ],
        "name" : "familyID",
        "doc" : "Returns an integer specifying the device family id for the touch device represented by the touchdeviceObject\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the device family id for the touch device represented by the touchdeviceObject\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:familyID() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the device family id for the touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:familyID() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Get or set whether applying pressure to a force touch capable device will generate a mouse click or force touch",
        "stripped_doc" : [
          "Get or set whether applying pressure to a force touch capable device will generate a mouse click or force touch",
          ""
        ],
        "name" : "forceResponseEnabled",
        "doc" : "Get or set whether applying pressure to a force touch capable device will generate a mouse click or force touch\n\nParameters:\n * `state` - an optional boolean specifying whether the force touch capable touch device will generate mouse clicks and force touches (true) or not (false).\n\nReturns:\n * if an argument is provided, returns the touchdeviceObject, otherwise returns the current value\n\nNotes:\n * When used with a non force touch device, the results of using this method are undefined - some will apparently change their value in response to this method while others will not; however the mouse click ability of the touch device will not be affected.\n\n * When used with a force touch capable device, setting this value to false will prevent the device from being able to generate mouse clicks; multi touch gestures and mouse movement is unaffected however.\n * This can be used to make such a device act more like a drawing tablet where the pressure can be used as a Z-axis without fear that a mouse click will change application focus or have other effects.\n * ***WARNING*** - if you disable mouse clicks for a device with this method, it is re-enabled upon garbage collection of the userdata representing the touch device. This means:\n   * You must retain the userdata in a global variable (or local variable with an upvalue reference within a global function or table) for at least as long as you wish for mouse clicks to be suppressed.\n   * If you have multiple userdata objects for the *same* touch device created independently (with separate [hs._asm.undocumented.touchdevice.default](#default) or [hs._asm.undocumented.touchdevice.forDeviceID](#forDeviceID) function invocations), when any of them go out of scope and is garbage collected, mouse clicks will be re-enabled for the device.\n   * If Hammerspoon crashes or exits unexpectedly, it is likely that garbage collection will not occur.  In this case, you will have to restart Hammerspoon and use this method to re-enable mouse clicks or disconnect and reconnect your device (if it is external) or restart your machine (if it is not) to return the device to normal functionality.\n * For these reasons, it is recommended that you only disable force response for as short a period as you require and the re-enable them so that everything remains in a predictable state.\n\n * If you wish to suspend mouse gestures as well, you can use `hs.execute(\"killall -STOP Dock\")`.  Note however that this disables gestures for *ALL* touch devices and also disables application switching from the keyboard as well (you can still click on an another applications windows with another mouse device though). You can resume normal operation of the gestures and keyboard shortcuts with `hs.execute(\"killall -CONT Dock\")`. It is unknown what other processes suspending the Dock in this way may cause, so do so at your own risk.",
        "notes" : [
          " * When used with a non force touch device, the results of using this method are undefined - some will apparently change their value in response to this method while others will not; however the mouse click ability of the touch device will not be affected.",
          "",
          " * When used with a force touch capable device, setting this value to false will prevent the device from being able to generate mouse clicks; multi touch gestures and mouse movement is unaffected however.",
          " * This can be used to make such a device act more like a drawing tablet where the pressure can be used as a Z-axis without fear that a mouse click will change application focus or have other effects.",
          " * ***WARNING*** - if you disable mouse clicks for a device with this method, it is re-enabled upon garbage collection of the userdata representing the touch device. This means:",
          "   * You must retain the userdata in a global variable (or local variable with an upvalue reference within a global function or table) for at least as long as you wish for mouse clicks to be suppressed.",
          "   * If you have multiple userdata objects for the *same* touch device created independently (with separate [hs._asm.undocumented.touchdevice.default](#default) or [hs._asm.undocumented.touchdevice.forDeviceID](#forDeviceID) function invocations), when any of them go out of scope and is garbage collected, mouse clicks will be re-enabled for the device.",
          "   * If Hammerspoon crashes or exits unexpectedly, it is likely that garbage collection will not occur.  In this case, you will have to restart Hammerspoon and use this method to re-enable mouse clicks or disconnect and reconnect your device (if it is external) or restart your machine (if it is not) to return the device to normal functionality.",
          " * For these reasons, it is recommended that you only disable force response for as short a period as you require and the re-enable them so that everything remains in a predictable state.",
          "",
          " * If you wish to suspend mouse gestures as well, you can use `hs.execute(\"killall -STOP Dock\")`.  Note however that this disables gestures for *ALL* touch devices and also disables application switching from the keyboard as well (you can still click on an another applications windows with another mouse device though). You can resume normal operation of the gestures and keyboard shortcuts with `hs.execute(\"killall -CONT Dock\")`. It is unknown what other processes suspending the Dock in this way may cause, so do so at your own risk."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:forceResponseEnabled([state]) -> touchdeviceObject | boolean",
        "type" : "Method",
        "returns" : [
          " * if an argument is provided, returns the touchdeviceObject, otherwise returns the current value",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:forceResponseEnabled([state]) -> touchdeviceObject | boolean",
        "parameters" : [
          " * `state` - an optional boolean specifying whether the force touch capable touch device will generate mouse clicks and force touches (true) or not (false).",
          ""
        ]
      },
      {
        "desc" : "Get or set the frame callback function for the touch device represented by the touchdevice object",
        "stripped_doc" : [
          "Get or set the frame callback function for the touch device represented by the touchdevice object",
          ""
        ],
        "name" : "frameCallback",
        "doc" : "Get or set the frame callback function for the touch device represented by the touchdevice object\n\nParameters:\n * `fn` - an optional function or nil to set (or remove) the frame callback function for the touch device.\n\nReturns:\n * if an argument is provided, returns the touchdeviceObject; otherwise returns the current value which may be a function or nil if no frame callback is currently assigned.\n\nNotes:\n * The frame callback appears to represent a point in time and contains touch data for all touches currently active for the device\n\n * the callback function should expect 4 arguments and return none.  The arguments will be as follows:\n   * `self`      - the touch device object for which the callback is being invoked for\n   * `touch`     - a table containing an array of touch tables as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) for each of the current touches detected by the touch device.\n   * `timestamp` - a number specifying the timestamp for the frame.\n   * `frame`     - an integer specifying the frame ID",
        "notes" : [
          " * The frame callback appears to represent a point in time and contains touch data for all touches currently active for the device",
          "",
          " * the callback function should expect 4 arguments and return none.  The arguments will be as follows:",
          "   * `self`      - the touch device object for which the callback is being invoked for",
          "   * `touch`     - a table containing an array of touch tables as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) for each of the current touches detected by the touch device.",
          "   * `timestamp` - a number specifying the timestamp for the frame.",
          "   * `frame`     - an integer specifying the frame ID"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:frameCallback([fn]) -> touchdeviceObject | fn",
        "type" : "Method",
        "returns" : [
          " * if an argument is provided, returns the touchdeviceObject; otherwise returns the current value which may be a function or nil if no frame callback is currently assigned.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:frameCallback([fn]) -> touchdeviceObject | fn",
        "parameters" : [
          " * `fn` - an optional function or nil to set (or remove) the frame callback function for the touch device.",
          ""
        ]
      },
      {
        "desc" : "Returns a table containing the service details for the multitouch device as reported by the macOS IOKit freamework.",
        "stripped_doc" : [
          "Returns a table containing the service details for the multitouch device as reported by the macOS IOKit freamework.",
          ""
        ],
        "name" : "ioserviceDetails",
        "doc" : "Returns a table containing the service details for the multitouch device as reported by the macOS IOKit freamework.\n\nParameters:\n * None\n\nReturns:\n * a table containing key-value pairs containing information about the multitouch device as reported by the macOS IOKit framework..\n\nNotes:\n * This method is provided for infomration purposes only; while this method will return more information than [hs._asm.undocumented.touchdevice:details](#details) it is uncertain if the additional information will actually be useful outside the context of IOKit.",
        "notes" : [
          " * This method is provided for infomration purposes only; while this method will return more information than [hs._asm.undocumented.touchdevice:details](#details) it is uncertain if the additional information will actually be useful outside the context of IOKit."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:ioserviceDetails() -> table",
        "type" : "Method",
        "returns" : [
          " * a table containing key-value pairs containing information about the multitouch device as reported by the macOS IOKit framework..",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:ioserviceDetails() -> table",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is an opaque surface",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is an opaque surface",
          ""
        ],
        "name" : "opaqueSurface",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is an opaque surface\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is an opaque surface\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.\n\n * This value appears to always be false unless the device is being watched for touch callbacks.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
          "",
          " * This value appears to always be false unless the device is being watched for touch callbacks."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:opaqueSurface() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is an opaque surface",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:opaqueSurface() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Get or set the path callback function for the touch device represented by the touchdevice object",
        "stripped_doc" : [
          "Get or set the path callback function for the touch device represented by the touchdevice object",
          ""
        ],
        "name" : "pathCallback",
        "doc" : "Get or set the path callback function for the touch device represented by the touchdevice object\n\nParameters:\n * `fn` - an optional function or nil to set (or remove) the path callback function for the touch device.\n\nReturns:\n * if an argument is provided, returns the touchdeviceObject; otherwise returns the current value which may be a function or nil if no path callback is currently assigned.\n\nNotes:\n * The path callback appears to represent the changing data for a specific touch.  Use the `pathIndex` and `stage` as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) to link callbacks when tracking a specific touch.\n\n * the callback function should expect 4 arguments and return none.  The arguments will be as follows:\n   * `self`      - the touch device object for which the callback is being invoked for\n   * `pathIndex` - an integer specifying the pathIndex for the touch.\n   * `stage`     - a string representing the current stage of the touch. Will be one of \"notTracking\", \"startInRange\", \"hoverInRange\", \"makeTouch\", \"touching\", \"breakTouch\", \"lingerInRange\", or \"outOfRange\".\n   * `touch`     - a touch tables as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) for the specific touch",
        "notes" : [
          " * The path callback appears to represent the changing data for a specific touch.  Use the `pathIndex` and `stage` as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) to link callbacks when tracking a specific touch.",
          "",
          " * the callback function should expect 4 arguments and return none.  The arguments will be as follows:",
          "   * `self`      - the touch device object for which the callback is being invoked for",
          "   * `pathIndex` - an integer specifying the pathIndex for the touch.",
          "   * `stage`     - a string representing the current stage of the touch. Will be one of \"notTracking\", \"startInRange\", \"hoverInRange\", \"makeTouch\", \"touching\", \"breakTouch\", \"lingerInRange\", or \"outOfRange\".",
          "   * `touch`     - a touch tables as described in [hs._asm.undocumented.touchdevice.touchData](#touchData) for the specific touch"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:pathCallback([fn]) -> touchdeviceObject | fn",
        "type" : "Method",
        "returns" : [
          " * if an argument is provided, returns the touchdeviceObject; otherwise returns the current value which may be a function or nil if no path callback is currently assigned.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:pathCallback([fn]) -> touchdeviceObject | fn",
        "parameters" : [
          " * `fn` - an optional function or nil to set (or remove) the path callback function for the touch device.",
          ""
        ]
      },
      {
        "desc" : "Returns the product name for the touch device as it is registered with the IOKit HID subsystem",
        "stripped_doc" : [
          "Returns the product name for the touch device as it is registered with the IOKit HID subsystem",
          ""
        ],
        "name" : "productName",
        "doc" : "Returns the product name for the touch device as it is registered with the IOKit HID subsystem\n\nParameters:\n * None\n\nReturns:\n * a string specifying the product name for the touch device represented by the touchdeviceObject as registered with the IOKit HID subsystem.\n\nNotes:\n * this information is purely informational and may be useful in differentiating multiple devices attached to the same machine\n * some devices return a name corresponding to the marketting name for the device while others return a name created by the macOS generated when the device is first paired with the machine, usually the user's login name followed by \"Mouse\" or \"Trackpad\".  At this time, it is unknown if there is an independant way to determine which pattern a given device's product name will follow or if there is a way to return the marketting name for an otherwise named device; if someone more familiar with IOKit, especially with regards to HID devices has any thoughts on the matter, please submit an issue for consideration.",
        "notes" : [
          " * this information is purely informational and may be useful in differentiating multiple devices attached to the same machine",
          " * some devices return a name corresponding to the marketting name for the device while others return a name created by the macOS generated when the device is first paired with the machine, usually the user's login name followed by \"Mouse\" or \"Trackpad\".  At this time, it is unknown if there is an independant way to determine which pattern a given device's product name will follow or if there is a way to return the marketting name for an otherwise named device; if someone more familiar with IOKit, especially with regards to HID devices has any thoughts on the matter, please submit an issue for consideration."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:productName() -> string",
        "type" : "Method",
        "returns" : [
          " * a string specifying the product name for the touch device represented by the touchdeviceObject as registered with the IOKit HID subsystem.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:productName() -> string",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is being monitored and generates callbacks for touch activity",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is being monitored and generates callbacks for touch activity",
          ""
        ],
        "name" : "running",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is being monitored and generates callbacks for touch activity\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is being monitored and generates callbacks for touch activity\n\nNotes:\n * See [hs._asm.undocumented.touchdevice:start](#start) and [hs._asm.undocumented.touchdevice:stop](#stop)",
        "notes" : [
          " * See [hs._asm.undocumented.touchdevice:start](#start) and [hs._asm.undocumented.touchdevice:stop](#stop)"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:running() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is being monitored and generates callbacks for touch activity",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:running() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns the dimensions of the space on the touch device that can detect a touch",
        "stripped_doc" : [
          "Returns the dimensions of the space on the touch device that can detect a touch",
          ""
        ],
        "name" : "sensorDimensions",
        "doc" : "Returns the dimensions of the space on the touch device that can detect a touch\n\nParameters:\n * `inHmm` - a boolean, default true, specifying whether the dimensions should be returned in hundredths of a millimeter (true) or as rows and columns (false)\n\nReturns:\n * a size table containing the sensor area dimensions where the height is the value assigned to the `h` key and the width is assigned to the `w` key.\n\nNotes:\n * At present, the usefulness of the row\/column dimension values is currently unknown and it is being provided for information purposes only\n   * The row\/column values seem to correspond to a grid used by the MultitouchSupport framework to differentiate between nearby touches and the exact size of each \"cell\" appears to be device dependent as the ratios between rows and columns versus the height and width as returned in hundredths of a millimeter is not consistent across devices.",
        "notes" : [
          " * At present, the usefulness of the row\/column dimension values is currently unknown and it is being provided for information purposes only",
          "   * The row\/column values seem to correspond to a grid used by the MultitouchSupport framework to differentiate between nearby touches and the exact size of each \"cell\" appears to be device dependent as the ratios between rows and columns versus the height and width as returned in hundredths of a millimeter is not consistent across devices."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:sensorDimensions([inHmm]) -> sizeTable",
        "type" : "Method",
        "returns" : [
          " * a size table containing the sensor area dimensions where the height is the value assigned to the `h` key and the width is assigned to the `w` key.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:sensorDimensions([inHmm]) -> sizeTable",
        "parameters" : [
          " * `inHmm` - a boolean, default true, specifying whether the dimensions should be returned in hundredths of a millimeter (true) or as rows and columns (false)",
          ""
        ]
      },
      {
        "desc" : "Returns the serial number for the multi-touch device",
        "stripped_doc" : [
          "Returns the serial number for the multi-touch device",
          ""
        ],
        "name" : "serialNumber",
        "doc" : "Returns the serial number for the multi-touch device\n\nParameters:\n * None\n\nReturns:\n * a string specifying the serial number of the multi-touch device represented by the touchdeviceObject\n\nNotes:\n * not all devices have a serial number so this value may be \"None\" or an empty string",
        "notes" : [
          " * not all devices have a serial number so this value may be \"None\" or an empty string"
        ],
        "signature" : "hs._asm.undocumented.touchdevice:serialNumber() -> string",
        "type" : "Method",
        "returns" : [
          " * a string specifying the serial number of the multi-touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:serialNumber() -> string",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Begin tracking touch data from the touch device.",
        "stripped_doc" : [
          "Begin tracking touch data from the touch device.",
          ""
        ],
        "name" : "start",
        "doc" : "Begin tracking touch data from the touch device.\n\nParameters:\n * None\n\nReturns:\n * the touchdeviceObject",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice:start() -> touchdeviceObject",
        "type" : "Method",
        "returns" : [
          " * the touchdeviceObject"
        ],
        "def" : "hs._asm.undocumented.touchdevice:start() -> touchdeviceObject",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Stop tracking touch data from the touch device.",
        "stripped_doc" : [
          "Stop tracking touch data from the touch device.",
          ""
        ],
        "name" : "stop",
        "doc" : "Stop tracking touch data from the touch device.\n\nParameters:\n * None\n\nReturns:\n * the touchdeviceObject",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice:stop() -> touchdeviceObject",
        "type" : "Method",
        "returns" : [
          " * the touchdeviceObject"
        ],
        "def" : "hs._asm.undocumented.touchdevice:stop() -> touchdeviceObject",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device contains an actuator",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device contains an actuator",
          ""
        ],
        "name" : "supportsActuation",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device contains an actuator\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject contains an actuator\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.\n\n * The MultitouchSupport framework does provide undocumented functions for accessing the actuator directly, but so far I've found no examples to start experimenting with.  Further investigation is being considered but is not currently underway.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
          "",
          " * The MultitouchSupport framework does provide undocumented functions for accessing the actuator directly, but so far I've found no examples to start experimenting with.  Further investigation is being considered but is not currently underway."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:supportsActuation() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject contains an actuator",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:supportsActuation() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device is a force touch device.",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device is a force touch device.",
          ""
        ],
        "name" : "supportsForce",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device is a force touch device.\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a force touch device\n\nNotes:\n * Force touch devices provide haptic feedback indicating mouse clicks rather than use an actual mechanical switch to detect mouse clicks.",
        "notes" : [
          " * Force touch devices provide haptic feedback indicating mouse clicks rather than use an actual mechanical switch to detect mouse clicks."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:supportsForce() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject is a force touch device",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:supportsForce() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not the multi-touch device supports power control",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not the multi-touch device supports power control",
          ""
        ],
        "name" : "supportsPowerControl",
        "doc" : "Returns a boolean indicating whether or not the multi-touch device supports power control\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject supports power control\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.\n * I have only observed this as returning false; please submit details if you observe a different value.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
          " * I have only observed this as returning false; please submit details if you observe a different value."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:supportsPowerControl() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean indicating whether or not the multi-touch device represented by the touchdeviceObject supports power control",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:supportsPowerControl() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click",
        "stripped_doc" : [
          "Returns a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click",
          ""
        ],
        "name" : "supportsSilentClick",
        "doc" : "Returns a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click\n\nParameters:\n * None\n\nReturns:\n * a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click\n\nNotes:\n * This method will return true for non force-touch devices -- they do not have a simulated click sound associated with mouse clicks so they are considered \"silent\" by the MultitouchSupport framework already.\n * Some force touch devices do not support disabling this simulated sound and will return false with this method; this seems to mostly apply to newer Mac Pro laptops, though an exhaustive list is beyond the scope of this documentation.  If you are uncertain about your force touch device, check Trackpad in System Preferences -- if you see an option for \"Silent clicking\" then this method should return true for your force touch device.",
        "notes" : [
          " * This method will return true for non force-touch devices -- they do not have a simulated click sound associated with mouse clicks so they are considered \"silent\" by the MultitouchSupport framework already.",
          " * Some force touch devices do not support disabling this simulated sound and will return false with this method; this seems to mostly apply to newer Mac Pro laptops, though an exhaustive list is beyond the scope of this documentation.  If you are uncertain about your force touch device, check Trackpad in System Preferences -- if you see an option for \"Silent clicking\" then this method should return true for your force touch device."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:supportsSilentClick() -> boolean",
        "type" : "Method",
        "returns" : [
          " * a boolean specifying whether or not the touch device represented by the touchdeviceObject supports silent click",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:supportsSilentClick() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject",
        "stripped_doc" : [
          "Returns an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject",
          ""
        ],
        "name" : "version",
        "doc" : "Returns an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject\n\nNotes:\n * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only.",
        "notes" : [
          " * At present, the usefulness of this information is currently unknown and it is being provided for information purposes only."
        ],
        "signature" : "hs._asm.undocumented.touchdevice:version() -> integer",
        "type" : "Method",
        "returns" : [
          " * an integer specifying the bcdVersion for the touch device represented by the touchdeviceObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice:version() -> integer",
        "parameters" : [
          " * None",
          ""
        ]
      }
    ],
    "doc" : "This module provides functionality for detecting and using touch information from Multi-Touch devices attached to your Mac.\n\nMost of the functions and methods provided here rely on undocumented or private functionality provided by the MultitouchSupport framework.  As such thi module is considered experimental and may break at any time should Apple make changes to the framework.\n\nPortions of this module have been influenced or inspired by code found at the following addresses:\n * https:\/\/github.com\/INRIA\/libpointing\/blob\/master\/pointing\/input\/osx\/osxPrivateMultitouchSupport.h\n * https:\/\/github.com\/calftrail\/Touch\n * https:\/\/github.com\/jnordberg\/FingerMgmt\n * https:\/\/github.com\/artginzburg\/MiddleClick-Catalina\n * ...and I'm sure others that have slipped my mind.\n\nIf you feel that I have missed a particular site that should be referenced, or know of a site with additional information that can clarify or expand this module or any of its functions -- many of the informational methods are not fully understood and clarification would be greatly appreciated -- please do not hesitate to submit an issue or pull request at https:\/\/github.com\/asmagill\/hammerspoon_asm.undocumented for consideration.\n\nBecause this module relies on an undocumented framework, this documentation is based on the collection of observations made by a variety of people and shared on the internet and is a best guess -- nothing in here is guaranteed.  If you have more accurate information or observe something in variance with what is documented here, please submit an issue with as much detail as possible.",
    "name" : "hs._asm.undocumented.touchdevice"
  },
  {
    "Constant" : [

    ],
    "submodules" : [

    ],
    "Function" : [
      {
        "desc" : "Generate haptic feedback on the currently active force touch device.",
        "stripped_doc" : [
          "Generate haptic feedback on the currently active force touch device.",
          ""
        ],
        "name" : "feedback",
        "doc" : "Generate haptic feedback on the currently active force touch device.\n\nParameters:\n * type - a string which must be one of the following values:\n   * \"generic\"   - A general haptic feedback pattern. Use this when no other feedback patterns apply.\n   * \"alignment\" - A haptic feedback pattern to be used in response to the alignment of an object the user is dragging around. For example, this pattern of feedback could be used in a drawing app when the user drags a shape into alignment with with another shape. Other scenarios where this type of feedback could be used might include scaling an object to fit within specific dimensions, positioning an object at a preferred location, or reaching the beginning\/minimum or end\/maximum of something, such as a track view in an audio\/video app.\n   * \"level\"     - A haptic feedback pattern to be used as the user moves between discrete levels of pressure. This pattern of feedback is used by multilevel accelerator buttons.\n * immediate - an optional boolean, default false, indicating whether the feedback should occur immediately (true) or when the screen has finished updating (false)\n\nReturns:\n * true if a feedback performer object exists within the current system, or false if it does not.\n\nNotes:\n * The existence of a feedback performer object is dependent upon the OS X version and not necessarily on the hardware available -- laptops with a trackpad which predates force touch will return true, even though this function does nothing on such systems.\n * Even on systems with a force touch device, this function will only generate feedback when the device is active or being touched -- from the Apple docs: \"In some cases, the system may override a call to this method. For example, a Force Touch trackpad won’t provide haptic feedback if the user isn’t touching the trackpad.\"",
        "notes" : [
          " * The existence of a feedback performer object is dependent upon the OS X version and not necessarily on the hardware available -- laptops with a trackpad which predates force touch will return true, even though this function does nothing on such systems.",
          " * Even on systems with a force touch device, this function will only generate feedback when the device is active or being touched -- from the Apple docs: \"In some cases, the system may override a call to this method. For example, a Force Touch trackpad won’t provide haptic feedback if the user isn’t touching the trackpad.\""
        ],
        "signature" : "hs._asm.undocumented.touchdevice.forcetouch.feedback(type, [immediate]) -> boolean",
        "type" : "Function",
        "returns" : [
          " * true if a feedback performer object exists within the current system, or false if it does not.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.forcetouch.feedback(type, [immediate]) -> boolean",
        "parameters" : [
          " * type - a string which must be one of the following values:",
          "   * \"generic\"   - A general haptic feedback pattern. Use this when no other feedback patterns apply.",
          "   * \"alignment\" - A haptic feedback pattern to be used in response to the alignment of an object the user is dragging around. For example, this pattern of feedback could be used in a drawing app when the user drags a shape into alignment with with another shape. Other scenarios where this type of feedback could be used might include scaling an object to fit within specific dimensions, positioning an object at a preferred location, or reaching the beginning\/minimum or end\/maximum of something, such as a track view in an audio\/video app.",
          "   * \"level\"     - A haptic feedback pattern to be used as the user moves between discrete levels of pressure. This pattern of feedback is used by multilevel accelerator buttons.",
          " * immediate - an optional boolean, default false, indicating whether the feedback should occur immediately (true) or when the screen has finished updating (false)",
          ""
        ]
      },
      {
        "desc" : "Returns a boolean indicating whether or not a force touch capable device is currently attached to the system.",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not a force touch capable device is currently attached to the system.",
          ""
        ],
        "name" : "deviceAttached",
        "doc" : "Returns a boolean indicating whether or not a force touch capable device is currently attached to the system.\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not a force touch capable device is currently attached to the system.\n\nNotes:\n * Based in part on code from https:\/\/eternalstorms.wordpress.com\/2015\/11\/16\/how-to-detect-force-touch-capable-devices-on-the-mac\/",
        "notes" : [
          " * Based in part on code from https:\/\/eternalstorms.wordpress.com\/2015\/11\/16\/how-to-detect-force-touch-capable-devices-on-the-mac\/"
        ],
        "signature" : "hs._asm.undocumented.touchdevice.forcetouch.deviceAttached() -> boolean",
        "type" : "Function",
        "returns" : [
          " * a boolean value indicating whether or not a force touch capable device is currently attached to the system.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.forcetouch.deviceAttached() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      }
    ],
    "Variable" : [

    ],
    "stripped_doc" : [

    ],
    "desc" : "Some experimentation with force touch devices. Currently this submodule doesn't utilize undocumented methods, but is included here because of the related nature of its function.  It is also hoped that a deeper investigation of the MultitouchSupport framework may lead to more interesting uses for haptic feedback.",
    "Deprecated" : [

    ],
    "type" : "Module",
    "Constructor" : [

    ],
    "Field" : [

    ],
    "Method" : [

    ],
    "Command" : [

    ],
    "items" : [
      {
        "desc" : "Returns a boolean indicating whether or not a force touch capable device is currently attached to the system.",
        "stripped_doc" : [
          "Returns a boolean indicating whether or not a force touch capable device is currently attached to the system.",
          ""
        ],
        "name" : "deviceAttached",
        "doc" : "Returns a boolean indicating whether or not a force touch capable device is currently attached to the system.\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not a force touch capable device is currently attached to the system.\n\nNotes:\n * Based in part on code from https:\/\/eternalstorms.wordpress.com\/2015\/11\/16\/how-to-detect-force-touch-capable-devices-on-the-mac\/",
        "notes" : [
          " * Based in part on code from https:\/\/eternalstorms.wordpress.com\/2015\/11\/16\/how-to-detect-force-touch-capable-devices-on-the-mac\/"
        ],
        "signature" : "hs._asm.undocumented.touchdevice.forcetouch.deviceAttached() -> boolean",
        "type" : "Function",
        "returns" : [
          " * a boolean value indicating whether or not a force touch capable device is currently attached to the system.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.forcetouch.deviceAttached() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Generate haptic feedback on the currently active force touch device.",
        "stripped_doc" : [
          "Generate haptic feedback on the currently active force touch device.",
          ""
        ],
        "name" : "feedback",
        "doc" : "Generate haptic feedback on the currently active force touch device.\n\nParameters:\n * type - a string which must be one of the following values:\n   * \"generic\"   - A general haptic feedback pattern. Use this when no other feedback patterns apply.\n   * \"alignment\" - A haptic feedback pattern to be used in response to the alignment of an object the user is dragging around. For example, this pattern of feedback could be used in a drawing app when the user drags a shape into alignment with with another shape. Other scenarios where this type of feedback could be used might include scaling an object to fit within specific dimensions, positioning an object at a preferred location, or reaching the beginning\/minimum or end\/maximum of something, such as a track view in an audio\/video app.\n   * \"level\"     - A haptic feedback pattern to be used as the user moves between discrete levels of pressure. This pattern of feedback is used by multilevel accelerator buttons.\n * immediate - an optional boolean, default false, indicating whether the feedback should occur immediately (true) or when the screen has finished updating (false)\n\nReturns:\n * true if a feedback performer object exists within the current system, or false if it does not.\n\nNotes:\n * The existence of a feedback performer object is dependent upon the OS X version and not necessarily on the hardware available -- laptops with a trackpad which predates force touch will return true, even though this function does nothing on such systems.\n * Even on systems with a force touch device, this function will only generate feedback when the device is active or being touched -- from the Apple docs: \"In some cases, the system may override a call to this method. For example, a Force Touch trackpad won’t provide haptic feedback if the user isn’t touching the trackpad.\"",
        "notes" : [
          " * The existence of a feedback performer object is dependent upon the OS X version and not necessarily on the hardware available -- laptops with a trackpad which predates force touch will return true, even though this function does nothing on such systems.",
          " * Even on systems with a force touch device, this function will only generate feedback when the device is active or being touched -- from the Apple docs: \"In some cases, the system may override a call to this method. For example, a Force Touch trackpad won’t provide haptic feedback if the user isn’t touching the trackpad.\""
        ],
        "signature" : "hs._asm.undocumented.touchdevice.forcetouch.feedback(type, [immediate]) -> boolean",
        "type" : "Function",
        "returns" : [
          " * true if a feedback performer object exists within the current system, or false if it does not.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.forcetouch.feedback(type, [immediate]) -> boolean",
        "parameters" : [
          " * type - a string which must be one of the following values:",
          "   * \"generic\"   - A general haptic feedback pattern. Use this when no other feedback patterns apply.",
          "   * \"alignment\" - A haptic feedback pattern to be used in response to the alignment of an object the user is dragging around. For example, this pattern of feedback could be used in a drawing app when the user drags a shape into alignment with with another shape. Other scenarios where this type of feedback could be used might include scaling an object to fit within specific dimensions, positioning an object at a preferred location, or reaching the beginning\/minimum or end\/maximum of something, such as a track view in an audio\/video app.",
          "   * \"level\"     - A haptic feedback pattern to be used as the user moves between discrete levels of pressure. This pattern of feedback is used by multilevel accelerator buttons.",
          " * immediate - an optional boolean, default false, indicating whether the feedback should occur immediately (true) or when the screen has finished updating (false)",
          ""
        ]
      }
    ],
    "doc" : "Some experimentation with force touch devices. Currently this submodule doesn't utilize undocumented methods, but is included here because of the related nature of its function.  It is also hoped that a deeper investigation of the MultitouchSupport framework may lead to more interesting uses for haptic feedback.\n\nRequires 10.11 or later.\nBased in part on code from https:\/\/eternalstorms.wordpress.com\/2015\/11\/16\/how-to-detect-force-touch-capable-devices-on-the-mac\/ and https:\/\/github.com\/eternalstorms\/NSBeginAlertSheet-using-Blocks",
    "name" : "hs._asm.undocumented.touchdevice.forcetouch"
  },
  {
    "Constant" : [

    ],
    "submodules" : [

    ],
    "Function" : [

    ],
    "Variable" : [

    ],
    "stripped_doc" : [

    ],
    "desc" : "This module allows you to watch for the attaching and detaching of Apple Multitouch devices like the Magic Trackpad and the Force Touch Trackpad.",
    "Deprecated" : [

    ],
    "type" : "Module",
    "Constructor" : [
      {
        "desc" : "Creates a new Multitouch device watcher",
        "stripped_doc" : [
          "Creates a new Multitouch device watcher",
          ""
        ],
        "name" : "new",
        "doc" : "Creates a new Multitouch device watcher\n\nParameters:\n * `fn` - an optional function which will be invoked when a multitouch trackpad is added or removed  from the system. See also [hs._asm.undocumented.touchdevice.watcher:callback](#callback).\n\nReturns:\n * the watcherObject or nil if there was an error creating the watcher.\n\nNotes:\n * This constructor creates the watcher, but does not start it. See [hs._asm.undocumented.touchdevice.watcher:start](#start).\n * For details about the callback function, see [hs._asm.undocumented.touchdevice.watcher:callback](#callback).",
        "notes" : [
          " * This constructor creates the watcher, but does not start it. See [hs._asm.undocumented.touchdevice.watcher:start](#start).",
          " * For details about the callback function, see [hs._asm.undocumented.touchdevice.watcher:callback](#callback)."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher.new([fn]) -> watcherObject | nil",
        "type" : "Constructor",
        "returns" : [
          " * the watcherObject or nil if there was an error creating the watcher.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher.new([fn]) -> watcherObject | nil",
        "parameters" : [
          " * `fn` - an optional function which will be invoked when a multitouch trackpad is added or removed  from the system. See also [hs._asm.undocumented.touchdevice.watcher:callback](#callback).",
          ""
        ]
      }
    ],
    "Field" : [

    ],
    "Method" : [
      {
        "desc" : "Get or change the callback function assigned to the watcher.",
        "stripped_doc" : [
          "Get or change the callback function assigned to the watcher.",
          ""
        ],
        "name" : "callback",
        "doc" : "Get or change the callback function assigned to the watcher.\n\nParameters:\n * `fn` - an optional function or explicit `nil` which will replace the existing callback if provided. An explicit `nil` will remove the existing callback, if any, without replacing it.\n\nReturns:\n * if an argument is provided, returns the watcherObject; otherwise returns the callback function, if defined, or nil if no callback function is currently assigned.\n\nNotes:\n * The callback function should expect 2 arguments and return none:\n   * `state`   - a string specifying whether a new device was added (\"add\") or an existing device was removed (\"remove\").\n   * `mtID`    - an integer specifying the multitouch ID for the device which has been added or removed. See the documentation for `hs._asm.undocumented.touchdevice` for how to use this ID.",
        "notes" : [
          " * The callback function should expect 2 arguments and return none:",
          "   * `state`   - a string specifying whether a new device was added (\"add\") or an existing device was removed (\"remove\").",
          "   * `mtID`    - an integer specifying the multitouch ID for the device which has been added or removed. See the documentation for `hs._asm.undocumented.touchdevice` for how to use this ID."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher:callback([fn | nil]) -> watcherObject | function | nil",
        "type" : "Method",
        "returns" : [
          " * if an argument is provided, returns the watcherObject; otherwise returns the callback function, if defined, or nil if no callback function is currently assigned.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher:callback([fn | nil]) -> watcherObject | function | nil",
        "parameters" : [
          " * `fn` - an optional function or explicit `nil` which will replace the existing callback if provided. An explicit `nil` will remove the existing callback, if any, without replacing it.",
          ""
        ]
      },
      {
        "desc" : "Starts the watcher so that multitouch devices being added or removed will trigger a callback.",
        "stripped_doc" : [
          "Starts the watcher so that multitouch devices being added or removed will trigger a callback.",
          ""
        ],
        "name" : "start",
        "doc" : "Starts the watcher so that multitouch devices being added or removed will trigger a callback.\n\nParameters:\n * `includeExisting` - an optional boolean, default false, indicating whether or not existing devices detected when the watcher starts should trigger immediate \"add\" callbacks or not. Existing devices will still trigger \"remove\" callbacks when they are removed, even if this argument is false or unset.\n\nReturns:\n * the watcherObject\n\nNotes:\n * in initial testing, the built in pre forcetouch trackpad on a 2014 MacBook Pro is not detected by this watcher, even when this method is passed `true`. It is uncertain at this time if this will also be the case for more modern machines or not. However since the built in device cannot be removed, the impact is minimal, as built in devices are still detected by `hs._asm.undocumented.touchdevice.devices()`.",
        "notes" : [
          " * in initial testing, the built in pre forcetouch trackpad on a 2014 MacBook Pro is not detected by this watcher, even when this method is passed `true`. It is uncertain at this time if this will also be the case for more modern machines or not. However since the built in device cannot be removed, the impact is minimal, as built in devices are still detected by `hs._asm.undocumented.touchdevice.devices()`."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher:start([includeExisting]) -> watcherObject",
        "type" : "Method",
        "returns" : [
          " * the watcherObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher:start([includeExisting]) -> watcherObject",
        "parameters" : [
          " * `includeExisting` - an optional boolean, default false, indicating whether or not existing devices detected when the watcher starts should trigger immediate \"add\" callbacks or not. Existing devices will still trigger \"remove\" callbacks when they are removed, even if this argument is false or unset.",
          ""
        ]
      },
      {
        "desc" : "Stops the watcher so that callbacks for multitouch devices being added or removed are no longer triggered.",
        "stripped_doc" : [
          "Stops the watcher so that callbacks for multitouch devices being added or removed are no longer triggered.",
          ""
        ],
        "name" : "stop",
        "doc" : "Stops the watcher so that callbacks for multitouch devices being added or removed are no longer triggered.\n\nParameters:\n * None\n\nReturns:\n * the watcherObject",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher:stop() -> watcherObject",
        "type" : "Method",
        "returns" : [
          " * the watcherObject"
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher:stop() -> watcherObject",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Returns whether or not the watcher is currently active.",
        "stripped_doc" : [
          "Returns whether or not the watcher is currently active.",
          ""
        ],
        "name" : "isRunning",
        "doc" : "Returns whether or not the watcher is currently active.\n\nParameters:\n * None\n\nReturns:\n * true of the watcher is running or false if it is not.",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher:isRunning() -> boolean",
        "type" : "Method",
        "returns" : [
          " * true of the watcher is running or false if it is not."
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher:isRunning() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      }
    ],
    "Command" : [

    ],
    "items" : [
      {
        "desc" : "Creates a new Multitouch device watcher",
        "stripped_doc" : [
          "Creates a new Multitouch device watcher",
          ""
        ],
        "name" : "new",
        "doc" : "Creates a new Multitouch device watcher\n\nParameters:\n * `fn` - an optional function which will be invoked when a multitouch trackpad is added or removed  from the system. See also [hs._asm.undocumented.touchdevice.watcher:callback](#callback).\n\nReturns:\n * the watcherObject or nil if there was an error creating the watcher.\n\nNotes:\n * This constructor creates the watcher, but does not start it. See [hs._asm.undocumented.touchdevice.watcher:start](#start).\n * For details about the callback function, see [hs._asm.undocumented.touchdevice.watcher:callback](#callback).",
        "notes" : [
          " * This constructor creates the watcher, but does not start it. See [hs._asm.undocumented.touchdevice.watcher:start](#start).",
          " * For details about the callback function, see [hs._asm.undocumented.touchdevice.watcher:callback](#callback)."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher.new([fn]) -> watcherObject | nil",
        "type" : "Constructor",
        "returns" : [
          " * the watcherObject or nil if there was an error creating the watcher.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher.new([fn]) -> watcherObject | nil",
        "parameters" : [
          " * `fn` - an optional function which will be invoked when a multitouch trackpad is added or removed  from the system. See also [hs._asm.undocumented.touchdevice.watcher:callback](#callback).",
          ""
        ]
      },
      {
        "desc" : "Get or change the callback function assigned to the watcher.",
        "stripped_doc" : [
          "Get or change the callback function assigned to the watcher.",
          ""
        ],
        "name" : "callback",
        "doc" : "Get or change the callback function assigned to the watcher.\n\nParameters:\n * `fn` - an optional function or explicit `nil` which will replace the existing callback if provided. An explicit `nil` will remove the existing callback, if any, without replacing it.\n\nReturns:\n * if an argument is provided, returns the watcherObject; otherwise returns the callback function, if defined, or nil if no callback function is currently assigned.\n\nNotes:\n * The callback function should expect 2 arguments and return none:\n   * `state`   - a string specifying whether a new device was added (\"add\") or an existing device was removed (\"remove\").\n   * `mtID`    - an integer specifying the multitouch ID for the device which has been added or removed. See the documentation for `hs._asm.undocumented.touchdevice` for how to use this ID.",
        "notes" : [
          " * The callback function should expect 2 arguments and return none:",
          "   * `state`   - a string specifying whether a new device was added (\"add\") or an existing device was removed (\"remove\").",
          "   * `mtID`    - an integer specifying the multitouch ID for the device which has been added or removed. See the documentation for `hs._asm.undocumented.touchdevice` for how to use this ID."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher:callback([fn | nil]) -> watcherObject | function | nil",
        "type" : "Method",
        "returns" : [
          " * if an argument is provided, returns the watcherObject; otherwise returns the callback function, if defined, or nil if no callback function is currently assigned.",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher:callback([fn | nil]) -> watcherObject | function | nil",
        "parameters" : [
          " * `fn` - an optional function or explicit `nil` which will replace the existing callback if provided. An explicit `nil` will remove the existing callback, if any, without replacing it.",
          ""
        ]
      },
      {
        "desc" : "Returns whether or not the watcher is currently active.",
        "stripped_doc" : [
          "Returns whether or not the watcher is currently active.",
          ""
        ],
        "name" : "isRunning",
        "doc" : "Returns whether or not the watcher is currently active.\n\nParameters:\n * None\n\nReturns:\n * true of the watcher is running or false if it is not.",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher:isRunning() -> boolean",
        "type" : "Method",
        "returns" : [
          " * true of the watcher is running or false if it is not."
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher:isRunning() -> boolean",
        "parameters" : [
          " * None",
          ""
        ]
      },
      {
        "desc" : "Starts the watcher so that multitouch devices being added or removed will trigger a callback.",
        "stripped_doc" : [
          "Starts the watcher so that multitouch devices being added or removed will trigger a callback.",
          ""
        ],
        "name" : "start",
        "doc" : "Starts the watcher so that multitouch devices being added or removed will trigger a callback.\n\nParameters:\n * `includeExisting` - an optional boolean, default false, indicating whether or not existing devices detected when the watcher starts should trigger immediate \"add\" callbacks or not. Existing devices will still trigger \"remove\" callbacks when they are removed, even if this argument is false or unset.\n\nReturns:\n * the watcherObject\n\nNotes:\n * in initial testing, the built in pre forcetouch trackpad on a 2014 MacBook Pro is not detected by this watcher, even when this method is passed `true`. It is uncertain at this time if this will also be the case for more modern machines or not. However since the built in device cannot be removed, the impact is minimal, as built in devices are still detected by `hs._asm.undocumented.touchdevice.devices()`.",
        "notes" : [
          " * in initial testing, the built in pre forcetouch trackpad on a 2014 MacBook Pro is not detected by this watcher, even when this method is passed `true`. It is uncertain at this time if this will also be the case for more modern machines or not. However since the built in device cannot be removed, the impact is minimal, as built in devices are still detected by `hs._asm.undocumented.touchdevice.devices()`."
        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher:start([includeExisting]) -> watcherObject",
        "type" : "Method",
        "returns" : [
          " * the watcherObject",
          ""
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher:start([includeExisting]) -> watcherObject",
        "parameters" : [
          " * `includeExisting` - an optional boolean, default false, indicating whether or not existing devices detected when the watcher starts should trigger immediate \"add\" callbacks or not. Existing devices will still trigger \"remove\" callbacks when they are removed, even if this argument is false or unset.",
          ""
        ]
      },
      {
        "desc" : "Stops the watcher so that callbacks for multitouch devices being added or removed are no longer triggered.",
        "stripped_doc" : [
          "Stops the watcher so that callbacks for multitouch devices being added or removed are no longer triggered.",
          ""
        ],
        "name" : "stop",
        "doc" : "Stops the watcher so that callbacks for multitouch devices being added or removed are no longer triggered.\n\nParameters:\n * None\n\nReturns:\n * the watcherObject",
        "notes" : [

        ],
        "signature" : "hs._asm.undocumented.touchdevice.watcher:stop() -> watcherObject",
        "type" : "Method",
        "returns" : [
          " * the watcherObject"
        ],
        "def" : "hs._asm.undocumented.touchdevice.watcher:stop() -> watcherObject",
        "parameters" : [
          " * None",
          ""
        ]
      }
    ],
    "doc" : "This module allows you to watch for the attaching and detaching of Apple Multitouch devices like the Magic Trackpad and the Force Touch Trackpad.\n\nOn a MacBook Pro, mid 2014, this module does not detect the presence of the built in pre-force touch trackpad, even when passing `true` to [hs._asm.undocumented.touchdevice.watcher:start](#start), as it uses a different IOService identifier than the external devices I have available to me for testing. I do not know if newer laptops will have this same limitation.",
    "name" : "hs._asm.undocumented.touchdevice.watcher"
  }
]
